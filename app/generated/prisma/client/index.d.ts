
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model assignment
 * 
 */
export type assignment = $Result.DefaultSelection<Prisma.$assignmentPayload>
/**
 * Model assignment_submission
 * 
 */
export type assignment_submission = $Result.DefaultSelection<Prisma.$assignment_submissionPayload>
/**
 * Model question
 * 
 */
export type question = $Result.DefaultSelection<Prisma.$questionPayload>
/**
 * Model question_submission
 * 
 */
export type question_submission = $Result.DefaultSelection<Prisma.$question_submissionPayload>
/**
 * Model classroom
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type classroom = $Result.DefaultSelection<Prisma.$classroomPayload>
/**
 * Model student
 * 
 */
export type student = $Result.DefaultSelection<Prisma.$studentPayload>
/**
 * Model student_classroom
 * 
 */
export type student_classroom = $Result.DefaultSelection<Prisma.$student_classroomPayload>
/**
 * Model teacher
 * 
 */
export type teacher = $Result.DefaultSelection<Prisma.$teacherPayload>
/**
 * Model teacher_classroom
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type teacher_classroom = $Result.DefaultSelection<Prisma.$teacher_classroomPayload>
/**
 * Model scholarship
 * 
 */
export type scholarship = $Result.DefaultSelection<Prisma.$scholarshipPayload>
/**
 * Model student_scholarship
 * 
 */
export type student_scholarship = $Result.DefaultSelection<Prisma.$student_scholarshipPayload>
/**
 * Model post
 * 
 */
export type post = $Result.DefaultSelection<Prisma.$postPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model admin
 * 
 */
export type admin = $Result.DefaultSelection<Prisma.$adminPayload>
/**
 * Model organization
 * 
 */
export type organization = $Result.DefaultSelection<Prisma.$organizationPayload>
/**
 * Model user_organization
 * 
 */
export type user_organization = $Result.DefaultSelection<Prisma.$user_organizationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT',
  GUEST: 'GUEST'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assignments
 * const assignments = await prisma.assignment.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assignments
   * const assignments = await prisma.assignment.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.assignment`: Exposes CRUD operations for the **assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.assignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment_submission`: Exposes CRUD operations for the **assignment_submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignment_submissions
    * const assignment_submissions = await prisma.assignment_submission.findMany()
    * ```
    */
  get assignment_submission(): Prisma.assignment_submissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.questionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question_submission`: Exposes CRUD operations for the **question_submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Question_submissions
    * const question_submissions = await prisma.question_submission.findMany()
    * ```
    */
  get question_submission(): Prisma.question_submissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classroom`: Exposes CRUD operations for the **classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classrooms
    * const classrooms = await prisma.classroom.findMany()
    * ```
    */
  get classroom(): Prisma.classroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.studentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_classroom`: Exposes CRUD operations for the **student_classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_classrooms
    * const student_classrooms = await prisma.student_classroom.findMany()
    * ```
    */
  get student_classroom(): Prisma.student_classroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.teacherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher_classroom`: Exposes CRUD operations for the **teacher_classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teacher_classrooms
    * const teacher_classrooms = await prisma.teacher_classroom.findMany()
    * ```
    */
  get teacher_classroom(): Prisma.teacher_classroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scholarship`: Exposes CRUD operations for the **scholarship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Scholarships
    * const scholarships = await prisma.scholarship.findMany()
    * ```
    */
  get scholarship(): Prisma.scholarshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_scholarship`: Exposes CRUD operations for the **student_scholarship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_scholarships
    * const student_scholarships = await prisma.student_scholarship.findMany()
    * ```
    */
  get student_scholarship(): Prisma.student_scholarshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.postDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.adminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.organizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_organization`: Exposes CRUD operations for the **user_organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_organizations
    * const user_organizations = await prisma.user_organization.findMany()
    * ```
    */
  get user_organization(): Prisma.user_organizationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    assignment: 'assignment',
    assignment_submission: 'assignment_submission',
    question: 'question',
    question_submission: 'question_submission',
    classroom: 'classroom',
    student: 'student',
    student_classroom: 'student_classroom',
    teacher: 'teacher',
    teacher_classroom: 'teacher_classroom',
    scholarship: 'scholarship',
    student_scholarship: 'student_scholarship',
    post: 'post',
    user: 'user',
    admin: 'admin',
    organization: 'organization',
    user_organization: 'user_organization'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "assignment" | "assignment_submission" | "question" | "question_submission" | "classroom" | "student" | "student_classroom" | "teacher" | "teacher_classroom" | "scholarship" | "student_scholarship" | "post" | "user" | "admin" | "organization" | "user_organization"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      assignment: {
        payload: Prisma.$assignmentPayload<ExtArgs>
        fields: Prisma.assignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          findFirst: {
            args: Prisma.assignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          findMany: {
            args: Prisma.assignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>[]
          }
          create: {
            args: Prisma.assignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          createMany: {
            args: Prisma.assignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>[]
          }
          delete: {
            args: Prisma.assignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          update: {
            args: Prisma.assignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          deleteMany: {
            args: Prisma.assignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>[]
          }
          upsert: {
            args: Prisma.assignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.assignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.assignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      assignment_submission: {
        payload: Prisma.$assignment_submissionPayload<ExtArgs>
        fields: Prisma.assignment_submissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assignment_submissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assignment_submissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          findFirst: {
            args: Prisma.assignment_submissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assignment_submissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          findMany: {
            args: Prisma.assignment_submissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>[]
          }
          create: {
            args: Prisma.assignment_submissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          createMany: {
            args: Prisma.assignment_submissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assignment_submissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>[]
          }
          delete: {
            args: Prisma.assignment_submissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          update: {
            args: Prisma.assignment_submissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          deleteMany: {
            args: Prisma.assignment_submissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assignment_submissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assignment_submissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>[]
          }
          upsert: {
            args: Prisma.assignment_submissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignment_submissionPayload>
          }
          aggregate: {
            args: Prisma.Assignment_submissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment_submission>
          }
          groupBy: {
            args: Prisma.assignment_submissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Assignment_submissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.assignment_submissionCountArgs<ExtArgs>
            result: $Utils.Optional<Assignment_submissionCountAggregateOutputType> | number
          }
        }
      }
      question: {
        payload: Prisma.$questionPayload<ExtArgs>
        fields: Prisma.questionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findFirst: {
            args: Prisma.questionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          findMany: {
            args: Prisma.questionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          create: {
            args: Prisma.questionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          createMany: {
            args: Prisma.questionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.questionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          delete: {
            args: Prisma.questionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          update: {
            args: Prisma.questionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          deleteMany: {
            args: Prisma.questionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.questionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>[]
          }
          upsert: {
            args: Prisma.questionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.questionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      question_submission: {
        payload: Prisma.$question_submissionPayload<ExtArgs>
        fields: Prisma.question_submissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.question_submissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.question_submissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          findFirst: {
            args: Prisma.question_submissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.question_submissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          findMany: {
            args: Prisma.question_submissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>[]
          }
          create: {
            args: Prisma.question_submissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          createMany: {
            args: Prisma.question_submissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.question_submissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>[]
          }
          delete: {
            args: Prisma.question_submissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          update: {
            args: Prisma.question_submissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          deleteMany: {
            args: Prisma.question_submissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.question_submissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.question_submissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>[]
          }
          upsert: {
            args: Prisma.question_submissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$question_submissionPayload>
          }
          aggregate: {
            args: Prisma.Question_submissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion_submission>
          }
          groupBy: {
            args: Prisma.question_submissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Question_submissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.question_submissionCountArgs<ExtArgs>
            result: $Utils.Optional<Question_submissionCountAggregateOutputType> | number
          }
        }
      }
      classroom: {
        payload: Prisma.$classroomPayload<ExtArgs>
        fields: Prisma.classroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.classroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.classroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          findFirst: {
            args: Prisma.classroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.classroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          findMany: {
            args: Prisma.classroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>[]
          }
          create: {
            args: Prisma.classroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          createMany: {
            args: Prisma.classroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.classroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>[]
          }
          delete: {
            args: Prisma.classroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          update: {
            args: Prisma.classroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          deleteMany: {
            args: Prisma.classroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.classroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.classroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>[]
          }
          upsert: {
            args: Prisma.classroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$classroomPayload>
          }
          aggregate: {
            args: Prisma.ClassroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroom>
          }
          groupBy: {
            args: Prisma.classroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.classroomCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCountAggregateOutputType> | number
          }
        }
      }
      student: {
        payload: Prisma.$studentPayload<ExtArgs>
        fields: Prisma.studentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findFirst: {
            args: Prisma.studentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          findMany: {
            args: Prisma.studentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          create: {
            args: Prisma.studentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          createMany: {
            args: Prisma.studentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          delete: {
            args: Prisma.studentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          update: {
            args: Prisma.studentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          deleteMany: {
            args: Prisma.studentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>[]
          }
          upsert: {
            args: Prisma.studentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.studentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      student_classroom: {
        payload: Prisma.$student_classroomPayload<ExtArgs>
        fields: Prisma.student_classroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_classroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_classroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          findFirst: {
            args: Prisma.student_classroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_classroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          findMany: {
            args: Prisma.student_classroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>[]
          }
          create: {
            args: Prisma.student_classroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          createMany: {
            args: Prisma.student_classroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_classroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>[]
          }
          delete: {
            args: Prisma.student_classroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          update: {
            args: Prisma.student_classroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          deleteMany: {
            args: Prisma.student_classroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_classroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.student_classroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>[]
          }
          upsert: {
            args: Prisma.student_classroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_classroomPayload>
          }
          aggregate: {
            args: Prisma.Student_classroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_classroom>
          }
          groupBy: {
            args: Prisma.student_classroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_classroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_classroomCountArgs<ExtArgs>
            result: $Utils.Optional<Student_classroomCountAggregateOutputType> | number
          }
        }
      }
      teacher: {
        payload: Prisma.$teacherPayload<ExtArgs>
        fields: Prisma.teacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          findFirst: {
            args: Prisma.teacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          findMany: {
            args: Prisma.teacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          create: {
            args: Prisma.teacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          createMany: {
            args: Prisma.teacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          delete: {
            args: Prisma.teacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          update: {
            args: Prisma.teacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          deleteMany: {
            args: Prisma.teacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teacherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>[]
          }
          upsert: {
            args: Prisma.teacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.teacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.teacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      teacher_classroom: {
        payload: Prisma.$teacher_classroomPayload<ExtArgs>
        fields: Prisma.teacher_classroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teacher_classroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teacher_classroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          findFirst: {
            args: Prisma.teacher_classroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teacher_classroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          findMany: {
            args: Prisma.teacher_classroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>[]
          }
          create: {
            args: Prisma.teacher_classroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          createMany: {
            args: Prisma.teacher_classroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teacher_classroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>[]
          }
          delete: {
            args: Prisma.teacher_classroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          update: {
            args: Prisma.teacher_classroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          deleteMany: {
            args: Prisma.teacher_classroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teacher_classroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teacher_classroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>[]
          }
          upsert: {
            args: Prisma.teacher_classroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_classroomPayload>
          }
          aggregate: {
            args: Prisma.Teacher_classroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher_classroom>
          }
          groupBy: {
            args: Prisma.teacher_classroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<Teacher_classroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.teacher_classroomCountArgs<ExtArgs>
            result: $Utils.Optional<Teacher_classroomCountAggregateOutputType> | number
          }
        }
      }
      scholarship: {
        payload: Prisma.$scholarshipPayload<ExtArgs>
        fields: Prisma.scholarshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.scholarshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.scholarshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          findFirst: {
            args: Prisma.scholarshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.scholarshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          findMany: {
            args: Prisma.scholarshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>[]
          }
          create: {
            args: Prisma.scholarshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          createMany: {
            args: Prisma.scholarshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.scholarshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>[]
          }
          delete: {
            args: Prisma.scholarshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          update: {
            args: Prisma.scholarshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          deleteMany: {
            args: Prisma.scholarshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.scholarshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.scholarshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>[]
          }
          upsert: {
            args: Prisma.scholarshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$scholarshipPayload>
          }
          aggregate: {
            args: Prisma.ScholarshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScholarship>
          }
          groupBy: {
            args: Prisma.scholarshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScholarshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.scholarshipCountArgs<ExtArgs>
            result: $Utils.Optional<ScholarshipCountAggregateOutputType> | number
          }
        }
      }
      student_scholarship: {
        payload: Prisma.$student_scholarshipPayload<ExtArgs>
        fields: Prisma.student_scholarshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_scholarshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_scholarshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          findFirst: {
            args: Prisma.student_scholarshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_scholarshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          findMany: {
            args: Prisma.student_scholarshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>[]
          }
          create: {
            args: Prisma.student_scholarshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          createMany: {
            args: Prisma.student_scholarshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_scholarshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>[]
          }
          delete: {
            args: Prisma.student_scholarshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          update: {
            args: Prisma.student_scholarshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          deleteMany: {
            args: Prisma.student_scholarshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_scholarshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.student_scholarshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>[]
          }
          upsert: {
            args: Prisma.student_scholarshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_scholarshipPayload>
          }
          aggregate: {
            args: Prisma.Student_scholarshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_scholarship>
          }
          groupBy: {
            args: Prisma.student_scholarshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_scholarshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_scholarshipCountArgs<ExtArgs>
            result: $Utils.Optional<Student_scholarshipCountAggregateOutputType> | number
          }
        }
      }
      post: {
        payload: Prisma.$postPayload<ExtArgs>
        fields: Prisma.postFieldRefs
        operations: {
          findUnique: {
            args: Prisma.postFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.postFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          findFirst: {
            args: Prisma.postFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.postFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          findMany: {
            args: Prisma.postFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          create: {
            args: Prisma.postCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          createMany: {
            args: Prisma.postCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.postCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          delete: {
            args: Prisma.postDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          update: {
            args: Prisma.postUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          deleteMany: {
            args: Prisma.postDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.postUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.postUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          upsert: {
            args: Prisma.postUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.postGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.postCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      admin: {
        payload: Prisma.$adminPayload<ExtArgs>
        fields: Prisma.adminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.adminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.adminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findFirst: {
            args: Prisma.adminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.adminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          findMany: {
            args: Prisma.adminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          create: {
            args: Prisma.adminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          createMany: {
            args: Prisma.adminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.adminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          delete: {
            args: Prisma.adminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          update: {
            args: Prisma.adminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          deleteMany: {
            args: Prisma.adminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.adminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.adminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>[]
          }
          upsert: {
            args: Prisma.adminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$adminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.adminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.adminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      organization: {
        payload: Prisma.$organizationPayload<ExtArgs>
        fields: Prisma.organizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.organizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.organizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findFirst: {
            args: Prisma.organizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.organizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          findMany: {
            args: Prisma.organizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>[]
          }
          create: {
            args: Prisma.organizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          createMany: {
            args: Prisma.organizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.organizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>[]
          }
          delete: {
            args: Prisma.organizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          update: {
            args: Prisma.organizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          deleteMany: {
            args: Prisma.organizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.organizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.organizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>[]
          }
          upsert: {
            args: Prisma.organizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$organizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.organizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.organizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      user_organization: {
        payload: Prisma.$user_organizationPayload<ExtArgs>
        fields: Prisma.user_organizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_organizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_organizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          findFirst: {
            args: Prisma.user_organizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_organizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          findMany: {
            args: Prisma.user_organizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>[]
          }
          create: {
            args: Prisma.user_organizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          createMany: {
            args: Prisma.user_organizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_organizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>[]
          }
          delete: {
            args: Prisma.user_organizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          update: {
            args: Prisma.user_organizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          deleteMany: {
            args: Prisma.user_organizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_organizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_organizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>[]
          }
          upsert: {
            args: Prisma.user_organizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_organizationPayload>
          }
          aggregate: {
            args: Prisma.User_organizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_organization>
          }
          groupBy: {
            args: Prisma.user_organizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_organizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_organizationCountArgs<ExtArgs>
            result: $Utils.Optional<User_organizationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    assignment?: assignmentOmit
    assignment_submission?: assignment_submissionOmit
    question?: questionOmit
    question_submission?: question_submissionOmit
    classroom?: classroomOmit
    student?: studentOmit
    student_classroom?: student_classroomOmit
    teacher?: teacherOmit
    teacher_classroom?: teacher_classroomOmit
    scholarship?: scholarshipOmit
    student_scholarship?: student_scholarshipOmit
    post?: postOmit
    user?: userOmit
    admin?: adminOmit
    organization?: organizationOmit
    user_organization?: user_organizationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    assignment_submission: number
    question: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | AssignmentCountOutputTypeCountAssignment_submissionArgs
    question?: boolean | AssignmentCountOutputTypeCountQuestionArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountAssignment_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignment_submissionWhereInput
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
  }


  /**
   * Count Type Assignment_submissionCountOutputType
   */

  export type Assignment_submissionCountOutputType = {
    question_submission: number
  }

  export type Assignment_submissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_submission?: boolean | Assignment_submissionCountOutputTypeCountQuestion_submissionArgs
  }

  // Custom InputTypes
  /**
   * Assignment_submissionCountOutputType without action
   */
  export type Assignment_submissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment_submissionCountOutputType
     */
    select?: Assignment_submissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Assignment_submissionCountOutputType without action
   */
  export type Assignment_submissionCountOutputTypeCountQuestion_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_submissionWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    question_submission: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question_submission?: boolean | QuestionCountOutputTypeCountQuestion_submissionArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountQuestion_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_submissionWhereInput
  }


  /**
   * Count Type ClassroomCountOutputType
   */

  export type ClassroomCountOutputType = {
    student_classroom: number
    teacher_classroom: number
    assignment: number
  }

  export type ClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_classroom?: boolean | ClassroomCountOutputTypeCountStudent_classroomArgs
    teacher_classroom?: boolean | ClassroomCountOutputTypeCountTeacher_classroomArgs
    assignment?: boolean | ClassroomCountOutputTypeCountAssignmentArgs
  }

  // Custom InputTypes
  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomCountOutputType
     */
    select?: ClassroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountStudent_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_classroomWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountTeacher_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacher_classroomWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    assignment_submission: number
    student_classroom: number
    question_submission: number
    student_scholarship: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | StudentCountOutputTypeCountAssignment_submissionArgs
    student_classroom?: boolean | StudentCountOutputTypeCountStudent_classroomArgs
    question_submission?: boolean | StudentCountOutputTypeCountQuestion_submissionArgs
    student_scholarship?: boolean | StudentCountOutputTypeCountStudent_scholarshipArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAssignment_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignment_submissionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_classroomWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountQuestion_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_submissionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudent_scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_scholarshipWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    teacher_classroom: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher_classroom?: boolean | TeacherCountOutputTypeCountTeacher_classroomArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountTeacher_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacher_classroomWhereInput
  }


  /**
   * Count Type ScholarshipCountOutputType
   */

  export type ScholarshipCountOutputType = {
    student_scholarship: number
  }

  export type ScholarshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_scholarship?: boolean | ScholarshipCountOutputTypeCountStudent_scholarshipArgs
  }

  // Custom InputTypes
  /**
   * ScholarshipCountOutputType without action
   */
  export type ScholarshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScholarshipCountOutputType
     */
    select?: ScholarshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScholarshipCountOutputType without action
   */
  export type ScholarshipCountOutputTypeCountStudent_scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_scholarshipWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    user_organization: number
    post: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_organization?: boolean | UserCountOutputTypeCountUser_organizationArgs
    post?: boolean | UserCountOutputTypeCountPostArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_organizationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    scholarship: number
    user_organization: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | OrganizationCountOutputTypeCountScholarshipArgs
    user_organization?: boolean | OrganizationCountOutputTypeCountUser_organizationArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountScholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scholarshipWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUser_organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_organizationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    assignment_id: number | null
    classroom_id: number | null
    assignment_number: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    assignment_id: number | null
    classroom_id: number | null
    assignment_number: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    assignment_id: number | null
    classroom_id: number | null
    name: string | null
    description: string | null
    assignment_number: number | null
    due_date: Date | null
    created_at: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    assignment_id: number | null
    classroom_id: number | null
    name: string | null
    description: string | null
    assignment_number: number | null
    due_date: Date | null
    created_at: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    assignment_id: number
    classroom_id: number
    name: number
    description: number
    assignment_number: number
    due_date: number
    created_at: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    assignment_id?: true
    classroom_id?: true
    assignment_number?: true
  }

  export type AssignmentSumAggregateInputType = {
    assignment_id?: true
    classroom_id?: true
    assignment_number?: true
  }

  export type AssignmentMinAggregateInputType = {
    assignment_id?: true
    classroom_id?: true
    name?: true
    description?: true
    assignment_number?: true
    due_date?: true
    created_at?: true
  }

  export type AssignmentMaxAggregateInputType = {
    assignment_id?: true
    classroom_id?: true
    name?: true
    description?: true
    assignment_number?: true
    due_date?: true
    created_at?: true
  }

  export type AssignmentCountAggregateInputType = {
    assignment_id?: true
    classroom_id?: true
    name?: true
    description?: true
    assignment_number?: true
    due_date?: true
    created_at?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignment to aggregate.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type assignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentWhereInput
    orderBy?: assignmentOrderByWithAggregationInput | assignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: assignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    assignment_id: number
    classroom_id: number
    name: string
    description: string | null
    assignment_number: number | null
    due_date: Date
    created_at: Date | null
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends assignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type assignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    assignment_number?: boolean
    due_date?: boolean
    created_at?: boolean
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
    assignment_submission?: boolean | assignment$assignment_submissionArgs<ExtArgs>
    question?: boolean | assignment$questionArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type assignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    assignment_number?: boolean
    due_date?: boolean
    created_at?: boolean
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type assignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    assignment_number?: boolean
    due_date?: boolean
    created_at?: boolean
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type assignmentSelectScalar = {
    assignment_id?: boolean
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    assignment_number?: boolean
    due_date?: boolean
    created_at?: boolean
  }

  export type assignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"assignment_id" | "classroom_id" | "name" | "description" | "assignment_number" | "due_date" | "created_at", ExtArgs["result"]["assignment"]>
  export type assignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
    assignment_submission?: boolean | assignment$assignment_submissionArgs<ExtArgs>
    question?: boolean | assignment$questionArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type assignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }
  export type assignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }

  export type $assignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assignment"
    objects: {
      classroom: Prisma.$classroomPayload<ExtArgs>
      assignment_submission: Prisma.$assignment_submissionPayload<ExtArgs>[]
      question: Prisma.$questionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_id: number
      classroom_id: number
      name: string
      description: string | null
      assignment_number: number | null
      due_date: Date
      created_at: Date | null
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type assignmentGetPayload<S extends boolean | null | undefined | assignmentDefaultArgs> = $Result.GetResult<Prisma.$assignmentPayload, S>

  type assignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface assignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assignment'], meta: { name: 'assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {assignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assignmentFindUniqueArgs>(args: SelectSubset<T, assignmentFindUniqueArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, assignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assignmentFindFirstArgs>(args?: SelectSubset<T, assignmentFindFirstArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, assignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const assignmentWithAssignment_idOnly = await prisma.assignment.findMany({ select: { assignment_id: true } })
     * 
     */
    findMany<T extends assignmentFindManyArgs>(args?: SelectSubset<T, assignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {assignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends assignmentCreateArgs>(args: SelectSubset<T, assignmentCreateArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {assignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assignmentCreateManyArgs>(args?: SelectSubset<T, assignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {assignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `assignment_id`
     * const assignmentWithAssignment_idOnly = await prisma.assignment.createManyAndReturn({
     *   select: { assignment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, assignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {assignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends assignmentDeleteArgs>(args: SelectSubset<T, assignmentDeleteArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {assignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assignmentUpdateArgs>(args: SelectSubset<T, assignmentUpdateArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {assignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assignmentDeleteManyArgs>(args?: SelectSubset<T, assignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assignmentUpdateManyArgs>(args: SelectSubset<T, assignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {assignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `assignment_id`
     * const assignmentWithAssignment_idOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { assignment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, assignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {assignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends assignmentUpsertArgs>(args: SelectSubset<T, assignmentUpsertArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends assignmentCountArgs>(
      args?: Subset<T, assignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assignmentGroupByArgs['orderBy'] }
        : { orderBy?: assignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assignment model
   */
  readonly fields: assignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classroom<T extends classroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classroomDefaultArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignment_submission<T extends assignment$assignment_submissionArgs<ExtArgs> = {}>(args?: Subset<T, assignment$assignment_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    question<T extends assignment$questionArgs<ExtArgs> = {}>(args?: Subset<T, assignment$questionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assignment model
   */
  interface assignmentFieldRefs {
    readonly assignment_id: FieldRef<"assignment", 'Int'>
    readonly classroom_id: FieldRef<"assignment", 'Int'>
    readonly name: FieldRef<"assignment", 'String'>
    readonly description: FieldRef<"assignment", 'String'>
    readonly assignment_number: FieldRef<"assignment", 'Int'>
    readonly due_date: FieldRef<"assignment", 'DateTime'>
    readonly created_at: FieldRef<"assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * assignment findUnique
   */
  export type assignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment findUniqueOrThrow
   */
  export type assignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment findFirst
   */
  export type assignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment findFirstOrThrow
   */
  export type assignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter, which assignment to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment findMany
   */
  export type assignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignments.
     */
    cursor?: assignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * assignment create
   */
  export type assignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a assignment.
     */
    data: XOR<assignmentCreateInput, assignmentUncheckedCreateInput>
  }

  /**
   * assignment createMany
   */
  export type assignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assignments.
     */
    data: assignmentCreateManyInput | assignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignment createManyAndReturn
   */
  export type assignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * The data used to create many assignments.
     */
    data: assignmentCreateManyInput | assignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignment update
   */
  export type assignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a assignment.
     */
    data: XOR<assignmentUpdateInput, assignmentUncheckedUpdateInput>
    /**
     * Choose, which assignment to update.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment updateMany
   */
  export type assignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentUpdateManyMutationInput, assignmentUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
  }

  /**
   * assignment updateManyAndReturn
   */
  export type assignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentUpdateManyMutationInput, assignmentUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignment upsert
   */
  export type assignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the assignment to update in case it exists.
     */
    where: assignmentWhereUniqueInput
    /**
     * In case the assignment found by the `where` argument doesn't exist, create a new assignment with this data.
     */
    create: XOR<assignmentCreateInput, assignmentUncheckedCreateInput>
    /**
     * In case the assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assignmentUpdateInput, assignmentUncheckedUpdateInput>
  }

  /**
   * assignment delete
   */
  export type assignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    /**
     * Filter which assignment to delete.
     */
    where: assignmentWhereUniqueInput
  }

  /**
   * assignment deleteMany
   */
  export type assignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to delete
     */
    where?: assignmentWhereInput
    /**
     * Limit how many assignments to delete.
     */
    limit?: number
  }

  /**
   * assignment.assignment_submission
   */
  export type assignment$assignment_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    where?: assignment_submissionWhereInput
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    cursor?: assignment_submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Assignment_submissionScalarFieldEnum | Assignment_submissionScalarFieldEnum[]
  }

  /**
   * assignment.question
   */
  export type assignment$questionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    where?: questionWhereInput
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    cursor?: questionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * assignment without action
   */
  export type assignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
  }


  /**
   * Model assignment_submission
   */

  export type AggregateAssignment_submission = {
    _count: Assignment_submissionCountAggregateOutputType | null
    _avg: Assignment_submissionAvgAggregateOutputType | null
    _sum: Assignment_submissionSumAggregateOutputType | null
    _min: Assignment_submissionMinAggregateOutputType | null
    _max: Assignment_submissionMaxAggregateOutputType | null
  }

  export type Assignment_submissionAvgAggregateOutputType = {
    assignment_submission_id: number | null
    assignment_id: number | null
    student_id: number | null
  }

  export type Assignment_submissionSumAggregateOutputType = {
    assignment_submission_id: number | null
    assignment_id: number | null
    student_id: number | null
  }

  export type Assignment_submissionMinAggregateOutputType = {
    assignment_submission_id: number | null
    assignment_id: number | null
    student_id: number | null
    s3_path: string | null
    submitted_at: Date | null
  }

  export type Assignment_submissionMaxAggregateOutputType = {
    assignment_submission_id: number | null
    assignment_id: number | null
    student_id: number | null
    s3_path: string | null
    submitted_at: Date | null
  }

  export type Assignment_submissionCountAggregateOutputType = {
    assignment_submission_id: number
    assignment_id: number
    student_id: number
    s3_path: number
    submitted_at: number
    _all: number
  }


  export type Assignment_submissionAvgAggregateInputType = {
    assignment_submission_id?: true
    assignment_id?: true
    student_id?: true
  }

  export type Assignment_submissionSumAggregateInputType = {
    assignment_submission_id?: true
    assignment_id?: true
    student_id?: true
  }

  export type Assignment_submissionMinAggregateInputType = {
    assignment_submission_id?: true
    assignment_id?: true
    student_id?: true
    s3_path?: true
    submitted_at?: true
  }

  export type Assignment_submissionMaxAggregateInputType = {
    assignment_submission_id?: true
    assignment_id?: true
    student_id?: true
    s3_path?: true
    submitted_at?: true
  }

  export type Assignment_submissionCountAggregateInputType = {
    assignment_submission_id?: true
    assignment_id?: true
    student_id?: true
    s3_path?: true
    submitted_at?: true
    _all?: true
  }

  export type Assignment_submissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignment_submission to aggregate.
     */
    where?: assignment_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignment_submissions to fetch.
     */
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assignment_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignment_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignment_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignment_submissions
    **/
    _count?: true | Assignment_submissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Assignment_submissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Assignment_submissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Assignment_submissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Assignment_submissionMaxAggregateInputType
  }

  export type GetAssignment_submissionAggregateType<T extends Assignment_submissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment_submission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment_submission[P]>
      : GetScalarType<T[P], AggregateAssignment_submission[P]>
  }




  export type assignment_submissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignment_submissionWhereInput
    orderBy?: assignment_submissionOrderByWithAggregationInput | assignment_submissionOrderByWithAggregationInput[]
    by: Assignment_submissionScalarFieldEnum[] | Assignment_submissionScalarFieldEnum
    having?: assignment_submissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Assignment_submissionCountAggregateInputType | true
    _avg?: Assignment_submissionAvgAggregateInputType
    _sum?: Assignment_submissionSumAggregateInputType
    _min?: Assignment_submissionMinAggregateInputType
    _max?: Assignment_submissionMaxAggregateInputType
  }

  export type Assignment_submissionGroupByOutputType = {
    assignment_submission_id: number
    assignment_id: number
    student_id: number
    s3_path: string
    submitted_at: Date | null
    _count: Assignment_submissionCountAggregateOutputType | null
    _avg: Assignment_submissionAvgAggregateOutputType | null
    _sum: Assignment_submissionSumAggregateOutputType | null
    _min: Assignment_submissionMinAggregateOutputType | null
    _max: Assignment_submissionMaxAggregateOutputType | null
  }

  type GetAssignment_submissionGroupByPayload<T extends assignment_submissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Assignment_submissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Assignment_submissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Assignment_submissionGroupByOutputType[P]>
            : GetScalarType<T[P], Assignment_submissionGroupByOutputType[P]>
        }
      >
    >


  export type assignment_submissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_submission_id?: boolean
    assignment_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    submitted_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
    question_submission?: boolean | assignment_submission$question_submissionArgs<ExtArgs>
    _count?: boolean | Assignment_submissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment_submission"]>

  export type assignment_submissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_submission_id?: boolean
    assignment_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    submitted_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment_submission"]>

  export type assignment_submissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_submission_id?: boolean
    assignment_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    submitted_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment_submission"]>

  export type assignment_submissionSelectScalar = {
    assignment_submission_id?: boolean
    assignment_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    submitted_at?: boolean
  }

  export type assignment_submissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"assignment_submission_id" | "assignment_id" | "student_id" | "s3_path" | "submitted_at", ExtArgs["result"]["assignment_submission"]>
  export type assignment_submissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
    question_submission?: boolean | assignment_submission$question_submissionArgs<ExtArgs>
    _count?: boolean | Assignment_submissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type assignment_submissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }
  export type assignment_submissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $assignment_submissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assignment_submission"
    objects: {
      assignment: Prisma.$assignmentPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs>
      question_submission: Prisma.$question_submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_submission_id: number
      assignment_id: number
      student_id: number
      s3_path: string
      submitted_at: Date | null
    }, ExtArgs["result"]["assignment_submission"]>
    composites: {}
  }

  type assignment_submissionGetPayload<S extends boolean | null | undefined | assignment_submissionDefaultArgs> = $Result.GetResult<Prisma.$assignment_submissionPayload, S>

  type assignment_submissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assignment_submissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Assignment_submissionCountAggregateInputType | true
    }

  export interface assignment_submissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assignment_submission'], meta: { name: 'assignment_submission' } }
    /**
     * Find zero or one Assignment_submission that matches the filter.
     * @param {assignment_submissionFindUniqueArgs} args - Arguments to find a Assignment_submission
     * @example
     * // Get one Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assignment_submissionFindUniqueArgs>(args: SelectSubset<T, assignment_submissionFindUniqueArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment_submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assignment_submissionFindUniqueOrThrowArgs} args - Arguments to find a Assignment_submission
     * @example
     * // Get one Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assignment_submissionFindUniqueOrThrowArgs>(args: SelectSubset<T, assignment_submissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment_submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionFindFirstArgs} args - Arguments to find a Assignment_submission
     * @example
     * // Get one Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assignment_submissionFindFirstArgs>(args?: SelectSubset<T, assignment_submissionFindFirstArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment_submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionFindFirstOrThrowArgs} args - Arguments to find a Assignment_submission
     * @example
     * // Get one Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assignment_submissionFindFirstOrThrowArgs>(args?: SelectSubset<T, assignment_submissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignment_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignment_submissions
     * const assignment_submissions = await prisma.assignment_submission.findMany()
     * 
     * // Get first 10 Assignment_submissions
     * const assignment_submissions = await prisma.assignment_submission.findMany({ take: 10 })
     * 
     * // Only select the `assignment_submission_id`
     * const assignment_submissionWithAssignment_submission_idOnly = await prisma.assignment_submission.findMany({ select: { assignment_submission_id: true } })
     * 
     */
    findMany<T extends assignment_submissionFindManyArgs>(args?: SelectSubset<T, assignment_submissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment_submission.
     * @param {assignment_submissionCreateArgs} args - Arguments to create a Assignment_submission.
     * @example
     * // Create one Assignment_submission
     * const Assignment_submission = await prisma.assignment_submission.create({
     *   data: {
     *     // ... data to create a Assignment_submission
     *   }
     * })
     * 
     */
    create<T extends assignment_submissionCreateArgs>(args: SelectSubset<T, assignment_submissionCreateArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignment_submissions.
     * @param {assignment_submissionCreateManyArgs} args - Arguments to create many Assignment_submissions.
     * @example
     * // Create many Assignment_submissions
     * const assignment_submission = await prisma.assignment_submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assignment_submissionCreateManyArgs>(args?: SelectSubset<T, assignment_submissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignment_submissions and returns the data saved in the database.
     * @param {assignment_submissionCreateManyAndReturnArgs} args - Arguments to create many Assignment_submissions.
     * @example
     * // Create many Assignment_submissions
     * const assignment_submission = await prisma.assignment_submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignment_submissions and only return the `assignment_submission_id`
     * const assignment_submissionWithAssignment_submission_idOnly = await prisma.assignment_submission.createManyAndReturn({
     *   select: { assignment_submission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assignment_submissionCreateManyAndReturnArgs>(args?: SelectSubset<T, assignment_submissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment_submission.
     * @param {assignment_submissionDeleteArgs} args - Arguments to delete one Assignment_submission.
     * @example
     * // Delete one Assignment_submission
     * const Assignment_submission = await prisma.assignment_submission.delete({
     *   where: {
     *     // ... filter to delete one Assignment_submission
     *   }
     * })
     * 
     */
    delete<T extends assignment_submissionDeleteArgs>(args: SelectSubset<T, assignment_submissionDeleteArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment_submission.
     * @param {assignment_submissionUpdateArgs} args - Arguments to update one Assignment_submission.
     * @example
     * // Update one Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assignment_submissionUpdateArgs>(args: SelectSubset<T, assignment_submissionUpdateArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignment_submissions.
     * @param {assignment_submissionDeleteManyArgs} args - Arguments to filter Assignment_submissions to delete.
     * @example
     * // Delete a few Assignment_submissions
     * const { count } = await prisma.assignment_submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assignment_submissionDeleteManyArgs>(args?: SelectSubset<T, assignment_submissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignment_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignment_submissions
     * const assignment_submission = await prisma.assignment_submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assignment_submissionUpdateManyArgs>(args: SelectSubset<T, assignment_submissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignment_submissions and returns the data updated in the database.
     * @param {assignment_submissionUpdateManyAndReturnArgs} args - Arguments to update many Assignment_submissions.
     * @example
     * // Update many Assignment_submissions
     * const assignment_submission = await prisma.assignment_submission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignment_submissions and only return the `assignment_submission_id`
     * const assignment_submissionWithAssignment_submission_idOnly = await prisma.assignment_submission.updateManyAndReturn({
     *   select: { assignment_submission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assignment_submissionUpdateManyAndReturnArgs>(args: SelectSubset<T, assignment_submissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment_submission.
     * @param {assignment_submissionUpsertArgs} args - Arguments to update or create a Assignment_submission.
     * @example
     * // Update or create a Assignment_submission
     * const assignment_submission = await prisma.assignment_submission.upsert({
     *   create: {
     *     // ... data to create a Assignment_submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment_submission we want to update
     *   }
     * })
     */
    upsert<T extends assignment_submissionUpsertArgs>(args: SelectSubset<T, assignment_submissionUpsertArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignment_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionCountArgs} args - Arguments to filter Assignment_submissions to count.
     * @example
     * // Count the number of Assignment_submissions
     * const count = await prisma.assignment_submission.count({
     *   where: {
     *     // ... the filter for the Assignment_submissions we want to count
     *   }
     * })
    **/
    count<T extends assignment_submissionCountArgs>(
      args?: Subset<T, assignment_submissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Assignment_submissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment_submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Assignment_submissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Assignment_submissionAggregateArgs>(args: Subset<T, Assignment_submissionAggregateArgs>): Prisma.PrismaPromise<GetAssignment_submissionAggregateType<T>>

    /**
     * Group by Assignment_submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignment_submissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assignment_submissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assignment_submissionGroupByArgs['orderBy'] }
        : { orderBy?: assignment_submissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assignment_submissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignment_submissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assignment_submission model
   */
  readonly fields: assignment_submissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignment_submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assignment_submissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends assignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, assignmentDefaultArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question_submission<T extends assignment_submission$question_submissionArgs<ExtArgs> = {}>(args?: Subset<T, assignment_submission$question_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assignment_submission model
   */
  interface assignment_submissionFieldRefs {
    readonly assignment_submission_id: FieldRef<"assignment_submission", 'Int'>
    readonly assignment_id: FieldRef<"assignment_submission", 'Int'>
    readonly student_id: FieldRef<"assignment_submission", 'Int'>
    readonly s3_path: FieldRef<"assignment_submission", 'String'>
    readonly submitted_at: FieldRef<"assignment_submission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * assignment_submission findUnique
   */
  export type assignment_submissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter, which assignment_submission to fetch.
     */
    where: assignment_submissionWhereUniqueInput
  }

  /**
   * assignment_submission findUniqueOrThrow
   */
  export type assignment_submissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter, which assignment_submission to fetch.
     */
    where: assignment_submissionWhereUniqueInput
  }

  /**
   * assignment_submission findFirst
   */
  export type assignment_submissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter, which assignment_submission to fetch.
     */
    where?: assignment_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignment_submissions to fetch.
     */
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignment_submissions.
     */
    cursor?: assignment_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignment_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignment_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignment_submissions.
     */
    distinct?: Assignment_submissionScalarFieldEnum | Assignment_submissionScalarFieldEnum[]
  }

  /**
   * assignment_submission findFirstOrThrow
   */
  export type assignment_submissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter, which assignment_submission to fetch.
     */
    where?: assignment_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignment_submissions to fetch.
     */
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignment_submissions.
     */
    cursor?: assignment_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignment_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignment_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignment_submissions.
     */
    distinct?: Assignment_submissionScalarFieldEnum | Assignment_submissionScalarFieldEnum[]
  }

  /**
   * assignment_submission findMany
   */
  export type assignment_submissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter, which assignment_submissions to fetch.
     */
    where?: assignment_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignment_submissions to fetch.
     */
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignment_submissions.
     */
    cursor?: assignment_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignment_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignment_submissions.
     */
    skip?: number
    distinct?: Assignment_submissionScalarFieldEnum | Assignment_submissionScalarFieldEnum[]
  }

  /**
   * assignment_submission create
   */
  export type assignment_submissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * The data needed to create a assignment_submission.
     */
    data: XOR<assignment_submissionCreateInput, assignment_submissionUncheckedCreateInput>
  }

  /**
   * assignment_submission createMany
   */
  export type assignment_submissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assignment_submissions.
     */
    data: assignment_submissionCreateManyInput | assignment_submissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignment_submission createManyAndReturn
   */
  export type assignment_submissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * The data used to create many assignment_submissions.
     */
    data: assignment_submissionCreateManyInput | assignment_submissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignment_submission update
   */
  export type assignment_submissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * The data needed to update a assignment_submission.
     */
    data: XOR<assignment_submissionUpdateInput, assignment_submissionUncheckedUpdateInput>
    /**
     * Choose, which assignment_submission to update.
     */
    where: assignment_submissionWhereUniqueInput
  }

  /**
   * assignment_submission updateMany
   */
  export type assignment_submissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assignment_submissions.
     */
    data: XOR<assignment_submissionUpdateManyMutationInput, assignment_submissionUncheckedUpdateManyInput>
    /**
     * Filter which assignment_submissions to update
     */
    where?: assignment_submissionWhereInput
    /**
     * Limit how many assignment_submissions to update.
     */
    limit?: number
  }

  /**
   * assignment_submission updateManyAndReturn
   */
  export type assignment_submissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * The data used to update assignment_submissions.
     */
    data: XOR<assignment_submissionUpdateManyMutationInput, assignment_submissionUncheckedUpdateManyInput>
    /**
     * Filter which assignment_submissions to update
     */
    where?: assignment_submissionWhereInput
    /**
     * Limit how many assignment_submissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignment_submission upsert
   */
  export type assignment_submissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * The filter to search for the assignment_submission to update in case it exists.
     */
    where: assignment_submissionWhereUniqueInput
    /**
     * In case the assignment_submission found by the `where` argument doesn't exist, create a new assignment_submission with this data.
     */
    create: XOR<assignment_submissionCreateInput, assignment_submissionUncheckedCreateInput>
    /**
     * In case the assignment_submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assignment_submissionUpdateInput, assignment_submissionUncheckedUpdateInput>
  }

  /**
   * assignment_submission delete
   */
  export type assignment_submissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    /**
     * Filter which assignment_submission to delete.
     */
    where: assignment_submissionWhereUniqueInput
  }

  /**
   * assignment_submission deleteMany
   */
  export type assignment_submissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignment_submissions to delete
     */
    where?: assignment_submissionWhereInput
    /**
     * Limit how many assignment_submissions to delete.
     */
    limit?: number
  }

  /**
   * assignment_submission.question_submission
   */
  export type assignment_submission$question_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    where?: question_submissionWhereInput
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    cursor?: question_submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * assignment_submission without action
   */
  export type assignment_submissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
  }


  /**
   * Model question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    question_id: number | null
    assignment_id: number | null
    question_number: number | null
  }

  export type QuestionSumAggregateOutputType = {
    question_id: number | null
    assignment_id: number | null
    question_number: number | null
  }

  export type QuestionMinAggregateOutputType = {
    question_id: number | null
    assignment_id: number | null
    question_number: number | null
    name: string | null
    prompt: string | null
    example_solution_s3_path: string | null
    accepted_file_types: string | null
    created_at: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    question_id: number | null
    assignment_id: number | null
    question_number: number | null
    name: string | null
    prompt: string | null
    example_solution_s3_path: string | null
    accepted_file_types: string | null
    created_at: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    question_id: number
    assignment_id: number
    question_number: number
    name: number
    prompt: number
    example_solution_s3_path: number
    accepted_file_types: number
    created_at: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    question_id?: true
    assignment_id?: true
    question_number?: true
  }

  export type QuestionSumAggregateInputType = {
    question_id?: true
    assignment_id?: true
    question_number?: true
  }

  export type QuestionMinAggregateInputType = {
    question_id?: true
    assignment_id?: true
    question_number?: true
    name?: true
    prompt?: true
    example_solution_s3_path?: true
    accepted_file_types?: true
    created_at?: true
  }

  export type QuestionMaxAggregateInputType = {
    question_id?: true
    assignment_id?: true
    question_number?: true
    name?: true
    prompt?: true
    example_solution_s3_path?: true
    accepted_file_types?: true
    created_at?: true
  }

  export type QuestionCountAggregateInputType = {
    question_id?: true
    assignment_id?: true
    question_number?: true
    name?: true
    prompt?: true
    example_solution_s3_path?: true
    accepted_file_types?: true
    created_at?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question to aggregate.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type questionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionWhereInput
    orderBy?: questionOrderByWithAggregationInput | questionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: questionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    question_id: number
    assignment_id: number
    question_number: number | null
    name: string | null
    prompt: string | null
    example_solution_s3_path: string | null
    accepted_file_types: string | null
    created_at: Date | null
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends questionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type questionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    assignment_id?: boolean
    question_number?: boolean
    name?: boolean
    prompt?: boolean
    example_solution_s3_path?: boolean
    accepted_file_types?: boolean
    created_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    question_submission?: boolean | question$question_submissionArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    assignment_id?: boolean
    question_number?: boolean
    name?: boolean
    prompt?: boolean
    example_solution_s3_path?: boolean
    accepted_file_types?: boolean
    created_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_id?: boolean
    assignment_id?: boolean
    question_number?: boolean
    name?: boolean
    prompt?: boolean
    example_solution_s3_path?: boolean
    accepted_file_types?: boolean
    created_at?: boolean
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type questionSelectScalar = {
    question_id?: boolean
    assignment_id?: boolean
    question_number?: boolean
    name?: boolean
    prompt?: boolean
    example_solution_s3_path?: boolean
    accepted_file_types?: boolean
    created_at?: boolean
  }

  export type questionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"question_id" | "assignment_id" | "question_number" | "name" | "prompt" | "example_solution_s3_path" | "accepted_file_types" | "created_at", ExtArgs["result"]["question"]>
  export type questionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
    question_submission?: boolean | question$question_submissionArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type questionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
  }
  export type questionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | assignmentDefaultArgs<ExtArgs>
  }

  export type $questionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question"
    objects: {
      assignment: Prisma.$assignmentPayload<ExtArgs>
      question_submission: Prisma.$question_submissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      question_id: number
      assignment_id: number
      question_number: number | null
      name: string | null
      prompt: string | null
      example_solution_s3_path: string | null
      accepted_file_types: string | null
      created_at: Date | null
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type questionGetPayload<S extends boolean | null | undefined | questionDefaultArgs> = $Result.GetResult<Prisma.$questionPayload, S>

  type questionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface questionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question'], meta: { name: 'question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {questionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionFindUniqueArgs>(args: SelectSubset<T, questionFindUniqueArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionFindUniqueOrThrowArgs>(args: SelectSubset<T, questionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionFindFirstArgs>(args?: SelectSubset<T, questionFindFirstArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionFindFirstOrThrowArgs>(args?: SelectSubset<T, questionFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.findMany({ select: { question_id: true } })
     * 
     */
    findMany<T extends questionFindManyArgs>(args?: SelectSubset<T, questionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {questionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends questionCreateArgs>(args: SelectSubset<T, questionCreateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {questionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionCreateManyArgs>(args?: SelectSubset<T, questionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {questionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.createManyAndReturn({
     *   select: { question_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends questionCreateManyAndReturnArgs>(args?: SelectSubset<T, questionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {questionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends questionDeleteArgs>(args: SelectSubset<T, questionDeleteArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {questionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionUpdateArgs>(args: SelectSubset<T, questionUpdateArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {questionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionDeleteManyArgs>(args?: SelectSubset<T, questionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionUpdateManyArgs>(args: SelectSubset<T, questionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {questionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `question_id`
     * const questionWithQuestion_idOnly = await prisma.question.updateManyAndReturn({
     *   select: { question_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends questionUpdateManyAndReturnArgs>(args: SelectSubset<T, questionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {questionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends questionUpsertArgs>(args: SelectSubset<T, questionUpsertArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionCountArgs>(
      args?: Subset<T, questionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionGroupByArgs['orderBy'] }
        : { orderBy?: questionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question model
   */
  readonly fields: questionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends assignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, assignmentDefaultArgs<ExtArgs>>): Prisma__assignmentClient<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question_submission<T extends question$question_submissionArgs<ExtArgs> = {}>(args?: Subset<T, question$question_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question model
   */
  interface questionFieldRefs {
    readonly question_id: FieldRef<"question", 'Int'>
    readonly assignment_id: FieldRef<"question", 'Int'>
    readonly question_number: FieldRef<"question", 'Int'>
    readonly name: FieldRef<"question", 'String'>
    readonly prompt: FieldRef<"question", 'String'>
    readonly example_solution_s3_path: FieldRef<"question", 'String'>
    readonly accepted_file_types: FieldRef<"question", 'String'>
    readonly created_at: FieldRef<"question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question findUnique
   */
  export type questionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findUniqueOrThrow
   */
  export type questionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question findFirst
   */
  export type questionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findFirstOrThrow
   */
  export type questionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which question to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question findMany
   */
  export type questionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionOrderByWithRelationInput | questionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * question create
   */
  export type questionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to create a question.
     */
    data: XOR<questionCreateInput, questionUncheckedCreateInput>
  }

  /**
   * question createMany
   */
  export type questionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionCreateManyInput | questionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question createManyAndReturn
   */
  export type questionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * The data used to create many questions.
     */
    data: questionCreateManyInput | questionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * question update
   */
  export type questionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The data needed to update a question.
     */
    data: XOR<questionUpdateInput, questionUncheckedUpdateInput>
    /**
     * Choose, which question to update.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question updateMany
   */
  export type questionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * question updateManyAndReturn
   */
  export type questionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * The data used to update questions.
     */
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * question upsert
   */
  export type questionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * The filter to search for the question to update in case it exists.
     */
    where: questionWhereUniqueInput
    /**
     * In case the question found by the `where` argument doesn't exist, create a new question with this data.
     */
    create: XOR<questionCreateInput, questionUncheckedCreateInput>
    /**
     * In case the question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionUpdateInput, questionUncheckedUpdateInput>
  }

  /**
   * question delete
   */
  export type questionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
    /**
     * Filter which question to delete.
     */
    where: questionWhereUniqueInput
  }

  /**
   * question deleteMany
   */
  export type questionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionWhereInput
    /**
     * Limit how many questions to delete.
     */
    limit?: number
  }

  /**
   * question.question_submission
   */
  export type question$question_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    where?: question_submissionWhereInput
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    cursor?: question_submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * question without action
   */
  export type questionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question
     */
    select?: questionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question
     */
    omit?: questionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionInclude<ExtArgs> | null
  }


  /**
   * Model question_submission
   */

  export type AggregateQuestion_submission = {
    _count: Question_submissionCountAggregateOutputType | null
    _avg: Question_submissionAvgAggregateOutputType | null
    _sum: Question_submissionSumAggregateOutputType | null
    _min: Question_submissionMinAggregateOutputType | null
    _max: Question_submissionMaxAggregateOutputType | null
  }

  export type Question_submissionAvgAggregateOutputType = {
    question_submission_id: number | null
    assignment_submission_id: number | null
    question_id: number | null
    student_id: number | null
  }

  export type Question_submissionSumAggregateOutputType = {
    question_submission_id: number | null
    assignment_submission_id: number | null
    question_id: number | null
    student_id: number | null
  }

  export type Question_submissionMinAggregateOutputType = {
    question_submission_id: number | null
    assignment_submission_id: number | null
    question_id: number | null
    student_id: number | null
    s3_path: string | null
    created_at: Date | null
  }

  export type Question_submissionMaxAggregateOutputType = {
    question_submission_id: number | null
    assignment_submission_id: number | null
    question_id: number | null
    student_id: number | null
    s3_path: string | null
    created_at: Date | null
  }

  export type Question_submissionCountAggregateOutputType = {
    question_submission_id: number
    assignment_submission_id: number
    question_id: number
    student_id: number
    s3_path: number
    created_at: number
    _all: number
  }


  export type Question_submissionAvgAggregateInputType = {
    question_submission_id?: true
    assignment_submission_id?: true
    question_id?: true
    student_id?: true
  }

  export type Question_submissionSumAggregateInputType = {
    question_submission_id?: true
    assignment_submission_id?: true
    question_id?: true
    student_id?: true
  }

  export type Question_submissionMinAggregateInputType = {
    question_submission_id?: true
    assignment_submission_id?: true
    question_id?: true
    student_id?: true
    s3_path?: true
    created_at?: true
  }

  export type Question_submissionMaxAggregateInputType = {
    question_submission_id?: true
    assignment_submission_id?: true
    question_id?: true
    student_id?: true
    s3_path?: true
    created_at?: true
  }

  export type Question_submissionCountAggregateInputType = {
    question_submission_id?: true
    assignment_submission_id?: true
    question_id?: true
    student_id?: true
    s3_path?: true
    created_at?: true
    _all?: true
  }

  export type Question_submissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_submission to aggregate.
     */
    where?: question_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_submissions to fetch.
     */
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: question_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned question_submissions
    **/
    _count?: true | Question_submissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Question_submissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Question_submissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Question_submissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Question_submissionMaxAggregateInputType
  }

  export type GetQuestion_submissionAggregateType<T extends Question_submissionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion_submission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion_submission[P]>
      : GetScalarType<T[P], AggregateQuestion_submission[P]>
  }




  export type question_submissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: question_submissionWhereInput
    orderBy?: question_submissionOrderByWithAggregationInput | question_submissionOrderByWithAggregationInput[]
    by: Question_submissionScalarFieldEnum[] | Question_submissionScalarFieldEnum
    having?: question_submissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Question_submissionCountAggregateInputType | true
    _avg?: Question_submissionAvgAggregateInputType
    _sum?: Question_submissionSumAggregateInputType
    _min?: Question_submissionMinAggregateInputType
    _max?: Question_submissionMaxAggregateInputType
  }

  export type Question_submissionGroupByOutputType = {
    question_submission_id: number
    assignment_submission_id: number
    question_id: number
    student_id: number
    s3_path: string
    created_at: Date | null
    _count: Question_submissionCountAggregateOutputType | null
    _avg: Question_submissionAvgAggregateOutputType | null
    _sum: Question_submissionSumAggregateOutputType | null
    _min: Question_submissionMinAggregateOutputType | null
    _max: Question_submissionMaxAggregateOutputType | null
  }

  type GetQuestion_submissionGroupByPayload<T extends question_submissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Question_submissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Question_submissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Question_submissionGroupByOutputType[P]>
            : GetScalarType<T[P], Question_submissionGroupByOutputType[P]>
        }
      >
    >


  export type question_submissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_submission_id?: boolean
    assignment_submission_id?: boolean
    question_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    created_at?: boolean
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_submission"]>

  export type question_submissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_submission_id?: boolean
    assignment_submission_id?: boolean
    question_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    created_at?: boolean
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_submission"]>

  export type question_submissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    question_submission_id?: boolean
    assignment_submission_id?: boolean
    question_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    created_at?: boolean
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question_submission"]>

  export type question_submissionSelectScalar = {
    question_submission_id?: boolean
    assignment_submission_id?: boolean
    question_id?: boolean
    student_id?: boolean
    s3_path?: boolean
    created_at?: boolean
  }

  export type question_submissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"question_submission_id" | "assignment_submission_id" | "question_id" | "student_id" | "s3_path" | "created_at", ExtArgs["result"]["question_submission"]>
  export type question_submissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }
  export type question_submissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }
  export type question_submissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | assignment_submissionDefaultArgs<ExtArgs>
    question?: boolean | questionDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $question_submissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "question_submission"
    objects: {
      assignment_submission: Prisma.$assignment_submissionPayload<ExtArgs>
      question: Prisma.$questionPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      question_submission_id: number
      assignment_submission_id: number
      question_id: number
      student_id: number
      s3_path: string
      created_at: Date | null
    }, ExtArgs["result"]["question_submission"]>
    composites: {}
  }

  type question_submissionGetPayload<S extends boolean | null | undefined | question_submissionDefaultArgs> = $Result.GetResult<Prisma.$question_submissionPayload, S>

  type question_submissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<question_submissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Question_submissionCountAggregateInputType | true
    }

  export interface question_submissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['question_submission'], meta: { name: 'question_submission' } }
    /**
     * Find zero or one Question_submission that matches the filter.
     * @param {question_submissionFindUniqueArgs} args - Arguments to find a Question_submission
     * @example
     * // Get one Question_submission
     * const question_submission = await prisma.question_submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends question_submissionFindUniqueArgs>(args: SelectSubset<T, question_submissionFindUniqueArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question_submission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {question_submissionFindUniqueOrThrowArgs} args - Arguments to find a Question_submission
     * @example
     * // Get one Question_submission
     * const question_submission = await prisma.question_submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends question_submissionFindUniqueOrThrowArgs>(args: SelectSubset<T, question_submissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question_submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionFindFirstArgs} args - Arguments to find a Question_submission
     * @example
     * // Get one Question_submission
     * const question_submission = await prisma.question_submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends question_submissionFindFirstArgs>(args?: SelectSubset<T, question_submissionFindFirstArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question_submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionFindFirstOrThrowArgs} args - Arguments to find a Question_submission
     * @example
     * // Get one Question_submission
     * const question_submission = await prisma.question_submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends question_submissionFindFirstOrThrowArgs>(args?: SelectSubset<T, question_submissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Question_submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Question_submissions
     * const question_submissions = await prisma.question_submission.findMany()
     * 
     * // Get first 10 Question_submissions
     * const question_submissions = await prisma.question_submission.findMany({ take: 10 })
     * 
     * // Only select the `question_submission_id`
     * const question_submissionWithQuestion_submission_idOnly = await prisma.question_submission.findMany({ select: { question_submission_id: true } })
     * 
     */
    findMany<T extends question_submissionFindManyArgs>(args?: SelectSubset<T, question_submissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question_submission.
     * @param {question_submissionCreateArgs} args - Arguments to create a Question_submission.
     * @example
     * // Create one Question_submission
     * const Question_submission = await prisma.question_submission.create({
     *   data: {
     *     // ... data to create a Question_submission
     *   }
     * })
     * 
     */
    create<T extends question_submissionCreateArgs>(args: SelectSubset<T, question_submissionCreateArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Question_submissions.
     * @param {question_submissionCreateManyArgs} args - Arguments to create many Question_submissions.
     * @example
     * // Create many Question_submissions
     * const question_submission = await prisma.question_submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends question_submissionCreateManyArgs>(args?: SelectSubset<T, question_submissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Question_submissions and returns the data saved in the database.
     * @param {question_submissionCreateManyAndReturnArgs} args - Arguments to create many Question_submissions.
     * @example
     * // Create many Question_submissions
     * const question_submission = await prisma.question_submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Question_submissions and only return the `question_submission_id`
     * const question_submissionWithQuestion_submission_idOnly = await prisma.question_submission.createManyAndReturn({
     *   select: { question_submission_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends question_submissionCreateManyAndReturnArgs>(args?: SelectSubset<T, question_submissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question_submission.
     * @param {question_submissionDeleteArgs} args - Arguments to delete one Question_submission.
     * @example
     * // Delete one Question_submission
     * const Question_submission = await prisma.question_submission.delete({
     *   where: {
     *     // ... filter to delete one Question_submission
     *   }
     * })
     * 
     */
    delete<T extends question_submissionDeleteArgs>(args: SelectSubset<T, question_submissionDeleteArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question_submission.
     * @param {question_submissionUpdateArgs} args - Arguments to update one Question_submission.
     * @example
     * // Update one Question_submission
     * const question_submission = await prisma.question_submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends question_submissionUpdateArgs>(args: SelectSubset<T, question_submissionUpdateArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Question_submissions.
     * @param {question_submissionDeleteManyArgs} args - Arguments to filter Question_submissions to delete.
     * @example
     * // Delete a few Question_submissions
     * const { count } = await prisma.question_submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends question_submissionDeleteManyArgs>(args?: SelectSubset<T, question_submissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Question_submissions
     * const question_submission = await prisma.question_submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends question_submissionUpdateManyArgs>(args: SelectSubset<T, question_submissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Question_submissions and returns the data updated in the database.
     * @param {question_submissionUpdateManyAndReturnArgs} args - Arguments to update many Question_submissions.
     * @example
     * // Update many Question_submissions
     * const question_submission = await prisma.question_submission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Question_submissions and only return the `question_submission_id`
     * const question_submissionWithQuestion_submission_idOnly = await prisma.question_submission.updateManyAndReturn({
     *   select: { question_submission_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends question_submissionUpdateManyAndReturnArgs>(args: SelectSubset<T, question_submissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question_submission.
     * @param {question_submissionUpsertArgs} args - Arguments to update or create a Question_submission.
     * @example
     * // Update or create a Question_submission
     * const question_submission = await prisma.question_submission.upsert({
     *   create: {
     *     // ... data to create a Question_submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question_submission we want to update
     *   }
     * })
     */
    upsert<T extends question_submissionUpsertArgs>(args: SelectSubset<T, question_submissionUpsertArgs<ExtArgs>>): Prisma__question_submissionClient<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Question_submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionCountArgs} args - Arguments to filter Question_submissions to count.
     * @example
     * // Count the number of Question_submissions
     * const count = await prisma.question_submission.count({
     *   where: {
     *     // ... the filter for the Question_submissions we want to count
     *   }
     * })
    **/
    count<T extends question_submissionCountArgs>(
      args?: Subset<T, question_submissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Question_submissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question_submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Question_submissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Question_submissionAggregateArgs>(args: Subset<T, Question_submissionAggregateArgs>): Prisma.PrismaPromise<GetQuestion_submissionAggregateType<T>>

    /**
     * Group by Question_submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {question_submissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends question_submissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: question_submissionGroupByArgs['orderBy'] }
        : { orderBy?: question_submissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, question_submissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestion_submissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the question_submission model
   */
  readonly fields: question_submissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for question_submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__question_submissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment_submission<T extends assignment_submissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, assignment_submissionDefaultArgs<ExtArgs>>): Prisma__assignment_submissionClient<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends questionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionDefaultArgs<ExtArgs>>): Prisma__questionClient<$Result.GetResult<Prisma.$questionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the question_submission model
   */
  interface question_submissionFieldRefs {
    readonly question_submission_id: FieldRef<"question_submission", 'Int'>
    readonly assignment_submission_id: FieldRef<"question_submission", 'Int'>
    readonly question_id: FieldRef<"question_submission", 'Int'>
    readonly student_id: FieldRef<"question_submission", 'Int'>
    readonly s3_path: FieldRef<"question_submission", 'String'>
    readonly created_at: FieldRef<"question_submission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * question_submission findUnique
   */
  export type question_submissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter, which question_submission to fetch.
     */
    where: question_submissionWhereUniqueInput
  }

  /**
   * question_submission findUniqueOrThrow
   */
  export type question_submissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter, which question_submission to fetch.
     */
    where: question_submissionWhereUniqueInput
  }

  /**
   * question_submission findFirst
   */
  export type question_submissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter, which question_submission to fetch.
     */
    where?: question_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_submissions to fetch.
     */
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_submissions.
     */
    cursor?: question_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_submissions.
     */
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * question_submission findFirstOrThrow
   */
  export type question_submissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter, which question_submission to fetch.
     */
    where?: question_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_submissions to fetch.
     */
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for question_submissions.
     */
    cursor?: question_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of question_submissions.
     */
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * question_submission findMany
   */
  export type question_submissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter, which question_submissions to fetch.
     */
    where?: question_submissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of question_submissions to fetch.
     */
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing question_submissions.
     */
    cursor?: question_submissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` question_submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` question_submissions.
     */
    skip?: number
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * question_submission create
   */
  export type question_submissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * The data needed to create a question_submission.
     */
    data: XOR<question_submissionCreateInput, question_submissionUncheckedCreateInput>
  }

  /**
   * question_submission createMany
   */
  export type question_submissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many question_submissions.
     */
    data: question_submissionCreateManyInput | question_submissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * question_submission createManyAndReturn
   */
  export type question_submissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * The data used to create many question_submissions.
     */
    data: question_submissionCreateManyInput | question_submissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * question_submission update
   */
  export type question_submissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * The data needed to update a question_submission.
     */
    data: XOR<question_submissionUpdateInput, question_submissionUncheckedUpdateInput>
    /**
     * Choose, which question_submission to update.
     */
    where: question_submissionWhereUniqueInput
  }

  /**
   * question_submission updateMany
   */
  export type question_submissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update question_submissions.
     */
    data: XOR<question_submissionUpdateManyMutationInput, question_submissionUncheckedUpdateManyInput>
    /**
     * Filter which question_submissions to update
     */
    where?: question_submissionWhereInput
    /**
     * Limit how many question_submissions to update.
     */
    limit?: number
  }

  /**
   * question_submission updateManyAndReturn
   */
  export type question_submissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * The data used to update question_submissions.
     */
    data: XOR<question_submissionUpdateManyMutationInput, question_submissionUncheckedUpdateManyInput>
    /**
     * Filter which question_submissions to update
     */
    where?: question_submissionWhereInput
    /**
     * Limit how many question_submissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * question_submission upsert
   */
  export type question_submissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * The filter to search for the question_submission to update in case it exists.
     */
    where: question_submissionWhereUniqueInput
    /**
     * In case the question_submission found by the `where` argument doesn't exist, create a new question_submission with this data.
     */
    create: XOR<question_submissionCreateInput, question_submissionUncheckedCreateInput>
    /**
     * In case the question_submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<question_submissionUpdateInput, question_submissionUncheckedUpdateInput>
  }

  /**
   * question_submission delete
   */
  export type question_submissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    /**
     * Filter which question_submission to delete.
     */
    where: question_submissionWhereUniqueInput
  }

  /**
   * question_submission deleteMany
   */
  export type question_submissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which question_submissions to delete
     */
    where?: question_submissionWhereInput
    /**
     * Limit how many question_submissions to delete.
     */
    limit?: number
  }

  /**
   * question_submission without action
   */
  export type question_submissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
  }


  /**
   * Model classroom
   */

  export type AggregateClassroom = {
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  export type ClassroomAvgAggregateOutputType = {
    classroom_id: number | null
  }

  export type ClassroomSumAggregateOutputType = {
    classroom_id: number | null
  }

  export type ClassroomMinAggregateOutputType = {
    classroom_id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClassroomMaxAggregateOutputType = {
    classroom_id: number | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ClassroomCountAggregateOutputType = {
    classroom_id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ClassroomAvgAggregateInputType = {
    classroom_id?: true
  }

  export type ClassroomSumAggregateInputType = {
    classroom_id?: true
  }

  export type ClassroomMinAggregateInputType = {
    classroom_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ClassroomMaxAggregateInputType = {
    classroom_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ClassroomCountAggregateInputType = {
    classroom_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classroom to aggregate.
     */
    where?: classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classrooms to fetch.
     */
    orderBy?: classroomOrderByWithRelationInput | classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned classrooms
    **/
    _count?: true | ClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMaxAggregateInputType
  }

  export type GetClassroomAggregateType<T extends ClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroom[P]>
      : GetScalarType<T[P], AggregateClassroom[P]>
  }




  export type classroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: classroomWhereInput
    orderBy?: classroomOrderByWithAggregationInput | classroomOrderByWithAggregationInput[]
    by: ClassroomScalarFieldEnum[] | ClassroomScalarFieldEnum
    having?: classroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCountAggregateInputType | true
    _avg?: ClassroomAvgAggregateInputType
    _sum?: ClassroomSumAggregateInputType
    _min?: ClassroomMinAggregateInputType
    _max?: ClassroomMaxAggregateInputType
  }

  export type ClassroomGroupByOutputType = {
    classroom_id: number
    name: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  type GetClassroomGroupByPayload<T extends classroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
        }
      >
    >


  export type classroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    student_classroom?: boolean | classroom$student_classroomArgs<ExtArgs>
    teacher_classroom?: boolean | classroom$teacher_classroomArgs<ExtArgs>
    assignment?: boolean | classroom$assignmentArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type classroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["classroom"]>

  export type classroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["classroom"]>

  export type classroomSelectScalar = {
    classroom_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type classroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classroom_id" | "name" | "description" | "created_at" | "updated_at", ExtArgs["result"]["classroom"]>
  export type classroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student_classroom?: boolean | classroom$student_classroomArgs<ExtArgs>
    teacher_classroom?: boolean | classroom$teacher_classroomArgs<ExtArgs>
    assignment?: boolean | classroom$assignmentArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type classroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type classroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $classroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "classroom"
    objects: {
      student_classroom: Prisma.$student_classroomPayload<ExtArgs>[]
      teacher_classroom: Prisma.$teacher_classroomPayload<ExtArgs>[]
      assignment: Prisma.$assignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      classroom_id: number
      name: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["classroom"]>
    composites: {}
  }

  type classroomGetPayload<S extends boolean | null | undefined | classroomDefaultArgs> = $Result.GetResult<Prisma.$classroomPayload, S>

  type classroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<classroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassroomCountAggregateInputType | true
    }

  export interface classroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['classroom'], meta: { name: 'classroom' } }
    /**
     * Find zero or one Classroom that matches the filter.
     * @param {classroomFindUniqueArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends classroomFindUniqueArgs>(args: SelectSubset<T, classroomFindUniqueArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {classroomFindUniqueOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends classroomFindUniqueOrThrowArgs>(args: SelectSubset<T, classroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomFindFirstArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends classroomFindFirstArgs>(args?: SelectSubset<T, classroomFindFirstArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomFindFirstOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends classroomFindFirstOrThrowArgs>(args?: SelectSubset<T, classroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classrooms
     * const classrooms = await prisma.classroom.findMany()
     * 
     * // Get first 10 Classrooms
     * const classrooms = await prisma.classroom.findMany({ take: 10 })
     * 
     * // Only select the `classroom_id`
     * const classroomWithClassroom_idOnly = await prisma.classroom.findMany({ select: { classroom_id: true } })
     * 
     */
    findMany<T extends classroomFindManyArgs>(args?: SelectSubset<T, classroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classroom.
     * @param {classroomCreateArgs} args - Arguments to create a Classroom.
     * @example
     * // Create one Classroom
     * const Classroom = await prisma.classroom.create({
     *   data: {
     *     // ... data to create a Classroom
     *   }
     * })
     * 
     */
    create<T extends classroomCreateArgs>(args: SelectSubset<T, classroomCreateArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classrooms.
     * @param {classroomCreateManyArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends classroomCreateManyArgs>(args?: SelectSubset<T, classroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classrooms and returns the data saved in the database.
     * @param {classroomCreateManyAndReturnArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classrooms and only return the `classroom_id`
     * const classroomWithClassroom_idOnly = await prisma.classroom.createManyAndReturn({
     *   select: { classroom_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends classroomCreateManyAndReturnArgs>(args?: SelectSubset<T, classroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classroom.
     * @param {classroomDeleteArgs} args - Arguments to delete one Classroom.
     * @example
     * // Delete one Classroom
     * const Classroom = await prisma.classroom.delete({
     *   where: {
     *     // ... filter to delete one Classroom
     *   }
     * })
     * 
     */
    delete<T extends classroomDeleteArgs>(args: SelectSubset<T, classroomDeleteArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classroom.
     * @param {classroomUpdateArgs} args - Arguments to update one Classroom.
     * @example
     * // Update one Classroom
     * const classroom = await prisma.classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends classroomUpdateArgs>(args: SelectSubset<T, classroomUpdateArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classrooms.
     * @param {classroomDeleteManyArgs} args - Arguments to filter Classrooms to delete.
     * @example
     * // Delete a few Classrooms
     * const { count } = await prisma.classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends classroomDeleteManyArgs>(args?: SelectSubset<T, classroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends classroomUpdateManyArgs>(args: SelectSubset<T, classroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms and returns the data updated in the database.
     * @param {classroomUpdateManyAndReturnArgs} args - Arguments to update many Classrooms.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classrooms and only return the `classroom_id`
     * const classroomWithClassroom_idOnly = await prisma.classroom.updateManyAndReturn({
     *   select: { classroom_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends classroomUpdateManyAndReturnArgs>(args: SelectSubset<T, classroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classroom.
     * @param {classroomUpsertArgs} args - Arguments to update or create a Classroom.
     * @example
     * // Update or create a Classroom
     * const classroom = await prisma.classroom.upsert({
     *   create: {
     *     // ... data to create a Classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classroom we want to update
     *   }
     * })
     */
    upsert<T extends classroomUpsertArgs>(args: SelectSubset<T, classroomUpsertArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomCountArgs} args - Arguments to filter Classrooms to count.
     * @example
     * // Count the number of Classrooms
     * const count = await prisma.classroom.count({
     *   where: {
     *     // ... the filter for the Classrooms we want to count
     *   }
     * })
    **/
    count<T extends classroomCountArgs>(
      args?: Subset<T, classroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomAggregateArgs>(args: Subset<T, ClassroomAggregateArgs>): Prisma.PrismaPromise<GetClassroomAggregateType<T>>

    /**
     * Group by Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {classroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends classroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: classroomGroupByArgs['orderBy'] }
        : { orderBy?: classroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, classroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the classroom model
   */
  readonly fields: classroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__classroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student_classroom<T extends classroom$student_classroomArgs<ExtArgs> = {}>(args?: Subset<T, classroom$student_classroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacher_classroom<T extends classroom$teacher_classroomArgs<ExtArgs> = {}>(args?: Subset<T, classroom$teacher_classroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignment<T extends classroom$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, classroom$assignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the classroom model
   */
  interface classroomFieldRefs {
    readonly classroom_id: FieldRef<"classroom", 'Int'>
    readonly name: FieldRef<"classroom", 'String'>
    readonly description: FieldRef<"classroom", 'String'>
    readonly created_at: FieldRef<"classroom", 'DateTime'>
    readonly updated_at: FieldRef<"classroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * classroom findUnique
   */
  export type classroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter, which classroom to fetch.
     */
    where: classroomWhereUniqueInput
  }

  /**
   * classroom findUniqueOrThrow
   */
  export type classroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter, which classroom to fetch.
     */
    where: classroomWhereUniqueInput
  }

  /**
   * classroom findFirst
   */
  export type classroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter, which classroom to fetch.
     */
    where?: classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classrooms to fetch.
     */
    orderBy?: classroomOrderByWithRelationInput | classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classrooms.
     */
    cursor?: classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * classroom findFirstOrThrow
   */
  export type classroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter, which classroom to fetch.
     */
    where?: classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classrooms to fetch.
     */
    orderBy?: classroomOrderByWithRelationInput | classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for classrooms.
     */
    cursor?: classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * classroom findMany
   */
  export type classroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter, which classrooms to fetch.
     */
    where?: classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of classrooms to fetch.
     */
    orderBy?: classroomOrderByWithRelationInput | classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing classrooms.
     */
    cursor?: classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` classrooms.
     */
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * classroom create
   */
  export type classroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * The data needed to create a classroom.
     */
    data: XOR<classroomCreateInput, classroomUncheckedCreateInput>
  }

  /**
   * classroom createMany
   */
  export type classroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many classrooms.
     */
    data: classroomCreateManyInput | classroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classroom createManyAndReturn
   */
  export type classroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * The data used to create many classrooms.
     */
    data: classroomCreateManyInput | classroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * classroom update
   */
  export type classroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * The data needed to update a classroom.
     */
    data: XOR<classroomUpdateInput, classroomUncheckedUpdateInput>
    /**
     * Choose, which classroom to update.
     */
    where: classroomWhereUniqueInput
  }

  /**
   * classroom updateMany
   */
  export type classroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update classrooms.
     */
    data: XOR<classroomUpdateManyMutationInput, classroomUncheckedUpdateManyInput>
    /**
     * Filter which classrooms to update
     */
    where?: classroomWhereInput
    /**
     * Limit how many classrooms to update.
     */
    limit?: number
  }

  /**
   * classroom updateManyAndReturn
   */
  export type classroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * The data used to update classrooms.
     */
    data: XOR<classroomUpdateManyMutationInput, classroomUncheckedUpdateManyInput>
    /**
     * Filter which classrooms to update
     */
    where?: classroomWhereInput
    /**
     * Limit how many classrooms to update.
     */
    limit?: number
  }

  /**
   * classroom upsert
   */
  export type classroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * The filter to search for the classroom to update in case it exists.
     */
    where: classroomWhereUniqueInput
    /**
     * In case the classroom found by the `where` argument doesn't exist, create a new classroom with this data.
     */
    create: XOR<classroomCreateInput, classroomUncheckedCreateInput>
    /**
     * In case the classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<classroomUpdateInput, classroomUncheckedUpdateInput>
  }

  /**
   * classroom delete
   */
  export type classroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
    /**
     * Filter which classroom to delete.
     */
    where: classroomWhereUniqueInput
  }

  /**
   * classroom deleteMany
   */
  export type classroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which classrooms to delete
     */
    where?: classroomWhereInput
    /**
     * Limit how many classrooms to delete.
     */
    limit?: number
  }

  /**
   * classroom.student_classroom
   */
  export type classroom$student_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    where?: student_classroomWhereInput
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    cursor?: student_classroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_classroomScalarFieldEnum | Student_classroomScalarFieldEnum[]
  }

  /**
   * classroom.teacher_classroom
   */
  export type classroom$teacher_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    where?: teacher_classroomWhereInput
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    cursor?: teacher_classroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teacher_classroomScalarFieldEnum | Teacher_classroomScalarFieldEnum[]
  }

  /**
   * classroom.assignment
   */
  export type classroom$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment
     */
    select?: assignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment
     */
    omit?: assignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentInclude<ExtArgs> | null
    where?: assignmentWhereInput
    orderBy?: assignmentOrderByWithRelationInput | assignmentOrderByWithRelationInput[]
    cursor?: assignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * classroom without action
   */
  export type classroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the classroom
     */
    select?: classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the classroom
     */
    omit?: classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: classroomInclude<ExtArgs> | null
  }


  /**
   * Model student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    student_id: number | null
    user_id: number | null
  }

  export type StudentSumAggregateOutputType = {
    student_id: number | null
    user_id: number | null
  }

  export type StudentMinAggregateOutputType = {
    student_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    student_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StudentCountAggregateOutputType = {
    student_id: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    student_id?: true
    user_id?: true
  }

  export type StudentSumAggregateInputType = {
    student_id?: true
    user_id?: true
  }

  export type StudentMinAggregateInputType = {
    student_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StudentMaxAggregateInputType = {
    student_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StudentCountAggregateInputType = {
    student_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student to aggregate.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type studentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentWhereInput
    orderBy?: studentOrderByWithAggregationInput | studentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: studentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    student_id: number
    user_id: number
    created_at: Date
    updated_at: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends studentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type studentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    assignment_submission?: boolean | student$assignment_submissionArgs<ExtArgs>
    student_classroom?: boolean | student$student_classroomArgs<ExtArgs>
    question_submission?: boolean | student$question_submissionArgs<ExtArgs>
    student_scholarship?: boolean | student$student_scholarshipArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type studentSelectScalar = {
    student_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type studentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_id" | "user_id" | "created_at" | "updated_at", ExtArgs["result"]["student"]>
  export type studentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment_submission?: boolean | student$assignment_submissionArgs<ExtArgs>
    student_classroom?: boolean | student$student_classroomArgs<ExtArgs>
    question_submission?: boolean | student$question_submissionArgs<ExtArgs>
    student_scholarship?: boolean | student$student_scholarshipArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type studentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $studentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student"
    objects: {
      assignment_submission: Prisma.$assignment_submissionPayload<ExtArgs>[]
      student_classroom: Prisma.$student_classroomPayload<ExtArgs>[]
      question_submission: Prisma.$question_submissionPayload<ExtArgs>[]
      student_scholarship: Prisma.$student_scholarshipPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_id: number
      user_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type studentGetPayload<S extends boolean | null | undefined | studentDefaultArgs> = $Result.GetResult<Prisma.$studentPayload, S>

  type studentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface studentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student'], meta: { name: 'student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {studentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentFindUniqueArgs>(args: SelectSubset<T, studentFindUniqueArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentFindUniqueOrThrowArgs>(args: SelectSubset<T, studentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentFindFirstArgs>(args?: SelectSubset<T, studentFindFirstArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentFindFirstOrThrowArgs>(args?: SelectSubset<T, studentFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.findMany({ select: { student_id: true } })
     * 
     */
    findMany<T extends studentFindManyArgs>(args?: SelectSubset<T, studentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {studentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends studentCreateArgs>(args: SelectSubset<T, studentCreateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentCreateManyArgs>(args?: SelectSubset<T, studentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.createManyAndReturn({
     *   select: { student_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentCreateManyAndReturnArgs>(args?: SelectSubset<T, studentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student.
     * @param {studentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends studentDeleteArgs>(args: SelectSubset<T, studentDeleteArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {studentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentUpdateArgs>(args: SelectSubset<T, studentUpdateArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentDeleteManyArgs>(args?: SelectSubset<T, studentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentUpdateManyArgs>(args: SelectSubset<T, studentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `student_id`
     * const studentWithStudent_idOnly = await prisma.student.updateManyAndReturn({
     *   select: { student_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentUpdateManyAndReturnArgs>(args: SelectSubset<T, studentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student.
     * @param {studentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends studentUpsertArgs>(args: SelectSubset<T, studentUpsertArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentCountArgs>(
      args?: Subset<T, studentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentGroupByArgs['orderBy'] }
        : { orderBy?: studentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student model
   */
  readonly fields: studentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment_submission<T extends student$assignment_submissionArgs<ExtArgs> = {}>(args?: Subset<T, student$assignment_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignment_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_classroom<T extends student$student_classroomArgs<ExtArgs> = {}>(args?: Subset<T, student$student_classroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    question_submission<T extends student$question_submissionArgs<ExtArgs> = {}>(args?: Subset<T, student$question_submissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$question_submissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_scholarship<T extends student$student_scholarshipArgs<ExtArgs> = {}>(args?: Subset<T, student$student_scholarshipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student model
   */
  interface studentFieldRefs {
    readonly student_id: FieldRef<"student", 'Int'>
    readonly user_id: FieldRef<"student", 'Int'>
    readonly created_at: FieldRef<"student", 'DateTime'>
    readonly updated_at: FieldRef<"student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student findUnique
   */
  export type studentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findUniqueOrThrow
   */
  export type studentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student findFirst
   */
  export type studentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findFirstOrThrow
   */
  export type studentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which student to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student findMany
   */
  export type studentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentOrderByWithRelationInput | studentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * student create
   */
  export type studentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to create a student.
     */
    data: XOR<studentCreateInput, studentUncheckedCreateInput>
  }

  /**
   * student createMany
   */
  export type studentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student createManyAndReturn
   */
  export type studentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentCreateManyInput | studentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student update
   */
  export type studentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The data needed to update a student.
     */
    data: XOR<studentUpdateInput, studentUncheckedUpdateInput>
    /**
     * Choose, which student to update.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student updateMany
   */
  export type studentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * student updateManyAndReturn
   */
  export type studentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentUpdateManyMutationInput, studentUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student upsert
   */
  export type studentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * The filter to search for the student to update in case it exists.
     */
    where: studentWhereUniqueInput
    /**
     * In case the student found by the `where` argument doesn't exist, create a new student with this data.
     */
    create: XOR<studentCreateInput, studentUncheckedCreateInput>
    /**
     * In case the student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentUpdateInput, studentUncheckedUpdateInput>
  }

  /**
   * student delete
   */
  export type studentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    /**
     * Filter which student to delete.
     */
    where: studentWhereUniqueInput
  }

  /**
   * student deleteMany
   */
  export type studentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * student.assignment_submission
   */
  export type student$assignment_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignment_submission
     */
    select?: assignment_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignment_submission
     */
    omit?: assignment_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignment_submissionInclude<ExtArgs> | null
    where?: assignment_submissionWhereInput
    orderBy?: assignment_submissionOrderByWithRelationInput | assignment_submissionOrderByWithRelationInput[]
    cursor?: assignment_submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Assignment_submissionScalarFieldEnum | Assignment_submissionScalarFieldEnum[]
  }

  /**
   * student.student_classroom
   */
  export type student$student_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    where?: student_classroomWhereInput
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    cursor?: student_classroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_classroomScalarFieldEnum | Student_classroomScalarFieldEnum[]
  }

  /**
   * student.question_submission
   */
  export type student$question_submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the question_submission
     */
    select?: question_submissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the question_submission
     */
    omit?: question_submissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: question_submissionInclude<ExtArgs> | null
    where?: question_submissionWhereInput
    orderBy?: question_submissionOrderByWithRelationInput | question_submissionOrderByWithRelationInput[]
    cursor?: question_submissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Question_submissionScalarFieldEnum | Question_submissionScalarFieldEnum[]
  }

  /**
   * student.student_scholarship
   */
  export type student$student_scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    where?: student_scholarshipWhereInput
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    cursor?: student_scholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_scholarshipScalarFieldEnum | Student_scholarshipScalarFieldEnum[]
  }

  /**
   * student without action
   */
  export type studentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
  }


  /**
   * Model student_classroom
   */

  export type AggregateStudent_classroom = {
    _count: Student_classroomCountAggregateOutputType | null
    _avg: Student_classroomAvgAggregateOutputType | null
    _sum: Student_classroomSumAggregateOutputType | null
    _min: Student_classroomMinAggregateOutputType | null
    _max: Student_classroomMaxAggregateOutputType | null
  }

  export type Student_classroomAvgAggregateOutputType = {
    student_classroom_id: number | null
    student_id: number | null
    classroom_id: number | null
  }

  export type Student_classroomSumAggregateOutputType = {
    student_classroom_id: number | null
    student_id: number | null
    classroom_id: number | null
  }

  export type Student_classroomMinAggregateOutputType = {
    student_classroom_id: number | null
    student_id: number | null
    classroom_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_classroomMaxAggregateOutputType = {
    student_classroom_id: number | null
    student_id: number | null
    classroom_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Student_classroomCountAggregateOutputType = {
    student_classroom_id: number
    student_id: number
    classroom_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Student_classroomAvgAggregateInputType = {
    student_classroom_id?: true
    student_id?: true
    classroom_id?: true
  }

  export type Student_classroomSumAggregateInputType = {
    student_classroom_id?: true
    student_id?: true
    classroom_id?: true
  }

  export type Student_classroomMinAggregateInputType = {
    student_classroom_id?: true
    student_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_classroomMaxAggregateInputType = {
    student_classroom_id?: true
    student_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Student_classroomCountAggregateInputType = {
    student_classroom_id?: true
    student_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Student_classroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_classroom to aggregate.
     */
    where?: student_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_classrooms to fetch.
     */
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_classrooms
    **/
    _count?: true | Student_classroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_classroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_classroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_classroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_classroomMaxAggregateInputType
  }

  export type GetStudent_classroomAggregateType<T extends Student_classroomAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_classroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_classroom[P]>
      : GetScalarType<T[P], AggregateStudent_classroom[P]>
  }




  export type student_classroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_classroomWhereInput
    orderBy?: student_classroomOrderByWithAggregationInput | student_classroomOrderByWithAggregationInput[]
    by: Student_classroomScalarFieldEnum[] | Student_classroomScalarFieldEnum
    having?: student_classroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_classroomCountAggregateInputType | true
    _avg?: Student_classroomAvgAggregateInputType
    _sum?: Student_classroomSumAggregateInputType
    _min?: Student_classroomMinAggregateInputType
    _max?: Student_classroomMaxAggregateInputType
  }

  export type Student_classroomGroupByOutputType = {
    student_classroom_id: number
    student_id: number
    classroom_id: number
    created_at: Date
    updated_at: Date
    _count: Student_classroomCountAggregateOutputType | null
    _avg: Student_classroomAvgAggregateOutputType | null
    _sum: Student_classroomSumAggregateOutputType | null
    _min: Student_classroomMinAggregateOutputType | null
    _max: Student_classroomMaxAggregateOutputType | null
  }

  type GetStudent_classroomGroupByPayload<T extends student_classroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_classroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_classroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_classroomGroupByOutputType[P]>
            : GetScalarType<T[P], Student_classroomGroupByOutputType[P]>
        }
      >
    >


  export type student_classroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_classroom_id?: boolean
    student_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_classroom"]>

  export type student_classroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_classroom_id?: boolean
    student_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_classroom"]>

  export type student_classroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_classroom_id?: boolean
    student_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_classroom"]>

  export type student_classroomSelectScalar = {
    student_classroom_id?: boolean
    student_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type student_classroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_classroom_id" | "student_id" | "classroom_id" | "created_at" | "updated_at", ExtArgs["result"]["student_classroom"]>
  export type student_classroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }
  export type student_classroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }
  export type student_classroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | studentDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }

  export type $student_classroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_classroom"
    objects: {
      student: Prisma.$studentPayload<ExtArgs>
      classroom: Prisma.$classroomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_classroom_id: number
      student_id: number
      classroom_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["student_classroom"]>
    composites: {}
  }

  type student_classroomGetPayload<S extends boolean | null | undefined | student_classroomDefaultArgs> = $Result.GetResult<Prisma.$student_classroomPayload, S>

  type student_classroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_classroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_classroomCountAggregateInputType | true
    }

  export interface student_classroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_classroom'], meta: { name: 'student_classroom' } }
    /**
     * Find zero or one Student_classroom that matches the filter.
     * @param {student_classroomFindUniqueArgs} args - Arguments to find a Student_classroom
     * @example
     * // Get one Student_classroom
     * const student_classroom = await prisma.student_classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_classroomFindUniqueArgs>(args: SelectSubset<T, student_classroomFindUniqueArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_classroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_classroomFindUniqueOrThrowArgs} args - Arguments to find a Student_classroom
     * @example
     * // Get one Student_classroom
     * const student_classroom = await prisma.student_classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_classroomFindUniqueOrThrowArgs>(args: SelectSubset<T, student_classroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomFindFirstArgs} args - Arguments to find a Student_classroom
     * @example
     * // Get one Student_classroom
     * const student_classroom = await prisma.student_classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_classroomFindFirstArgs>(args?: SelectSubset<T, student_classroomFindFirstArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomFindFirstOrThrowArgs} args - Arguments to find a Student_classroom
     * @example
     * // Get one Student_classroom
     * const student_classroom = await prisma.student_classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_classroomFindFirstOrThrowArgs>(args?: SelectSubset<T, student_classroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_classrooms
     * const student_classrooms = await prisma.student_classroom.findMany()
     * 
     * // Get first 10 Student_classrooms
     * const student_classrooms = await prisma.student_classroom.findMany({ take: 10 })
     * 
     * // Only select the `student_classroom_id`
     * const student_classroomWithStudent_classroom_idOnly = await prisma.student_classroom.findMany({ select: { student_classroom_id: true } })
     * 
     */
    findMany<T extends student_classroomFindManyArgs>(args?: SelectSubset<T, student_classroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_classroom.
     * @param {student_classroomCreateArgs} args - Arguments to create a Student_classroom.
     * @example
     * // Create one Student_classroom
     * const Student_classroom = await prisma.student_classroom.create({
     *   data: {
     *     // ... data to create a Student_classroom
     *   }
     * })
     * 
     */
    create<T extends student_classroomCreateArgs>(args: SelectSubset<T, student_classroomCreateArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_classrooms.
     * @param {student_classroomCreateManyArgs} args - Arguments to create many Student_classrooms.
     * @example
     * // Create many Student_classrooms
     * const student_classroom = await prisma.student_classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_classroomCreateManyArgs>(args?: SelectSubset<T, student_classroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_classrooms and returns the data saved in the database.
     * @param {student_classroomCreateManyAndReturnArgs} args - Arguments to create many Student_classrooms.
     * @example
     * // Create many Student_classrooms
     * const student_classroom = await prisma.student_classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_classrooms and only return the `student_classroom_id`
     * const student_classroomWithStudent_classroom_idOnly = await prisma.student_classroom.createManyAndReturn({
     *   select: { student_classroom_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_classroomCreateManyAndReturnArgs>(args?: SelectSubset<T, student_classroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student_classroom.
     * @param {student_classroomDeleteArgs} args - Arguments to delete one Student_classroom.
     * @example
     * // Delete one Student_classroom
     * const Student_classroom = await prisma.student_classroom.delete({
     *   where: {
     *     // ... filter to delete one Student_classroom
     *   }
     * })
     * 
     */
    delete<T extends student_classroomDeleteArgs>(args: SelectSubset<T, student_classroomDeleteArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_classroom.
     * @param {student_classroomUpdateArgs} args - Arguments to update one Student_classroom.
     * @example
     * // Update one Student_classroom
     * const student_classroom = await prisma.student_classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_classroomUpdateArgs>(args: SelectSubset<T, student_classroomUpdateArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_classrooms.
     * @param {student_classroomDeleteManyArgs} args - Arguments to filter Student_classrooms to delete.
     * @example
     * // Delete a few Student_classrooms
     * const { count } = await prisma.student_classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_classroomDeleteManyArgs>(args?: SelectSubset<T, student_classroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_classrooms
     * const student_classroom = await prisma.student_classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_classroomUpdateManyArgs>(args: SelectSubset<T, student_classroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_classrooms and returns the data updated in the database.
     * @param {student_classroomUpdateManyAndReturnArgs} args - Arguments to update many Student_classrooms.
     * @example
     * // Update many Student_classrooms
     * const student_classroom = await prisma.student_classroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Student_classrooms and only return the `student_classroom_id`
     * const student_classroomWithStudent_classroom_idOnly = await prisma.student_classroom.updateManyAndReturn({
     *   select: { student_classroom_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends student_classroomUpdateManyAndReturnArgs>(args: SelectSubset<T, student_classroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student_classroom.
     * @param {student_classroomUpsertArgs} args - Arguments to update or create a Student_classroom.
     * @example
     * // Update or create a Student_classroom
     * const student_classroom = await prisma.student_classroom.upsert({
     *   create: {
     *     // ... data to create a Student_classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_classroom we want to update
     *   }
     * })
     */
    upsert<T extends student_classroomUpsertArgs>(args: SelectSubset<T, student_classroomUpsertArgs<ExtArgs>>): Prisma__student_classroomClient<$Result.GetResult<Prisma.$student_classroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomCountArgs} args - Arguments to filter Student_classrooms to count.
     * @example
     * // Count the number of Student_classrooms
     * const count = await prisma.student_classroom.count({
     *   where: {
     *     // ... the filter for the Student_classrooms we want to count
     *   }
     * })
    **/
    count<T extends student_classroomCountArgs>(
      args?: Subset<T, student_classroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_classroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_classroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_classroomAggregateArgs>(args: Subset<T, Student_classroomAggregateArgs>): Prisma.PrismaPromise<GetStudent_classroomAggregateType<T>>

    /**
     * Group by Student_classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_classroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_classroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_classroomGroupByArgs['orderBy'] }
        : { orderBy?: student_classroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_classroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_classroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_classroom model
   */
  readonly fields: student_classroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_classroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends classroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classroomDefaultArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_classroom model
   */
  interface student_classroomFieldRefs {
    readonly student_classroom_id: FieldRef<"student_classroom", 'Int'>
    readonly student_id: FieldRef<"student_classroom", 'Int'>
    readonly classroom_id: FieldRef<"student_classroom", 'Int'>
    readonly created_at: FieldRef<"student_classroom", 'DateTime'>
    readonly updated_at: FieldRef<"student_classroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * student_classroom findUnique
   */
  export type student_classroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter, which student_classroom to fetch.
     */
    where: student_classroomWhereUniqueInput
  }

  /**
   * student_classroom findUniqueOrThrow
   */
  export type student_classroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter, which student_classroom to fetch.
     */
    where: student_classroomWhereUniqueInput
  }

  /**
   * student_classroom findFirst
   */
  export type student_classroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter, which student_classroom to fetch.
     */
    where?: student_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_classrooms to fetch.
     */
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_classrooms.
     */
    cursor?: student_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_classrooms.
     */
    distinct?: Student_classroomScalarFieldEnum | Student_classroomScalarFieldEnum[]
  }

  /**
   * student_classroom findFirstOrThrow
   */
  export type student_classroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter, which student_classroom to fetch.
     */
    where?: student_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_classrooms to fetch.
     */
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_classrooms.
     */
    cursor?: student_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_classrooms.
     */
    distinct?: Student_classroomScalarFieldEnum | Student_classroomScalarFieldEnum[]
  }

  /**
   * student_classroom findMany
   */
  export type student_classroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter, which student_classrooms to fetch.
     */
    where?: student_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_classrooms to fetch.
     */
    orderBy?: student_classroomOrderByWithRelationInput | student_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_classrooms.
     */
    cursor?: student_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_classrooms.
     */
    skip?: number
    distinct?: Student_classroomScalarFieldEnum | Student_classroomScalarFieldEnum[]
  }

  /**
   * student_classroom create
   */
  export type student_classroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * The data needed to create a student_classroom.
     */
    data: XOR<student_classroomCreateInput, student_classroomUncheckedCreateInput>
  }

  /**
   * student_classroom createMany
   */
  export type student_classroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_classrooms.
     */
    data: student_classroomCreateManyInput | student_classroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_classroom createManyAndReturn
   */
  export type student_classroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * The data used to create many student_classrooms.
     */
    data: student_classroomCreateManyInput | student_classroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_classroom update
   */
  export type student_classroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * The data needed to update a student_classroom.
     */
    data: XOR<student_classroomUpdateInput, student_classroomUncheckedUpdateInput>
    /**
     * Choose, which student_classroom to update.
     */
    where: student_classroomWhereUniqueInput
  }

  /**
   * student_classroom updateMany
   */
  export type student_classroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_classrooms.
     */
    data: XOR<student_classroomUpdateManyMutationInput, student_classroomUncheckedUpdateManyInput>
    /**
     * Filter which student_classrooms to update
     */
    where?: student_classroomWhereInput
    /**
     * Limit how many student_classrooms to update.
     */
    limit?: number
  }

  /**
   * student_classroom updateManyAndReturn
   */
  export type student_classroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * The data used to update student_classrooms.
     */
    data: XOR<student_classroomUpdateManyMutationInput, student_classroomUncheckedUpdateManyInput>
    /**
     * Filter which student_classrooms to update
     */
    where?: student_classroomWhereInput
    /**
     * Limit how many student_classrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_classroom upsert
   */
  export type student_classroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * The filter to search for the student_classroom to update in case it exists.
     */
    where: student_classroomWhereUniqueInput
    /**
     * In case the student_classroom found by the `where` argument doesn't exist, create a new student_classroom with this data.
     */
    create: XOR<student_classroomCreateInput, student_classroomUncheckedCreateInput>
    /**
     * In case the student_classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_classroomUpdateInput, student_classroomUncheckedUpdateInput>
  }

  /**
   * student_classroom delete
   */
  export type student_classroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
    /**
     * Filter which student_classroom to delete.
     */
    where: student_classroomWhereUniqueInput
  }

  /**
   * student_classroom deleteMany
   */
  export type student_classroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_classrooms to delete
     */
    where?: student_classroomWhereInput
    /**
     * Limit how many student_classrooms to delete.
     */
    limit?: number
  }

  /**
   * student_classroom without action
   */
  export type student_classroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_classroom
     */
    select?: student_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_classroom
     */
    omit?: student_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_classroomInclude<ExtArgs> | null
  }


  /**
   * Model teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    teacher_id: number | null
    user_id: number | null
  }

  export type TeacherSumAggregateOutputType = {
    teacher_id: number | null
    user_id: number | null
  }

  export type TeacherMinAggregateOutputType = {
    teacher_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    teacher_id: number | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    teacher_id: number
    user_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    teacher_id?: true
    user_id?: true
  }

  export type TeacherSumAggregateInputType = {
    teacher_id?: true
    user_id?: true
  }

  export type TeacherMinAggregateInputType = {
    teacher_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherMaxAggregateInputType = {
    teacher_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
  }

  export type TeacherCountAggregateInputType = {
    teacher_id?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher to aggregate.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type teacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacherWhereInput
    orderBy?: teacherOrderByWithAggregationInput | teacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: teacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    teacher_id: number
    user_id: number
    created_at: Date
    updated_at: Date
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends teacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type teacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
    teacher_classroom?: boolean | teacher$teacher_classroomArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type teacherSelectScalar = {
    teacher_id?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type teacherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"teacher_id" | "user_id" | "created_at" | "updated_at", ExtArgs["result"]["teacher"]>
  export type teacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
    teacher_classroom?: boolean | teacher$teacher_classroomArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type teacherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $teacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teacher"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
      teacher_classroom: Prisma.$teacher_classroomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      teacher_id: number
      user_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type teacherGetPayload<S extends boolean | null | undefined | teacherDefaultArgs> = $Result.GetResult<Prisma.$teacherPayload, S>

  type teacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teacherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface teacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teacher'], meta: { name: 'teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {teacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teacherFindUniqueArgs>(args: SelectSubset<T, teacherFindUniqueArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teacherFindUniqueOrThrowArgs>(args: SelectSubset<T, teacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teacherFindFirstArgs>(args?: SelectSubset<T, teacherFindFirstArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teacherFindFirstOrThrowArgs>(args?: SelectSubset<T, teacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.findMany({ select: { teacher_id: true } })
     * 
     */
    findMany<T extends teacherFindManyArgs>(args?: SelectSubset<T, teacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher.
     * @param {teacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends teacherCreateArgs>(args: SelectSubset<T, teacherCreateArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {teacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teacherCreateManyArgs>(args?: SelectSubset<T, teacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {teacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.createManyAndReturn({
     *   select: { teacher_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teacherCreateManyAndReturnArgs>(args?: SelectSubset<T, teacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher.
     * @param {teacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends teacherDeleteArgs>(args: SelectSubset<T, teacherDeleteArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher.
     * @param {teacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teacherUpdateArgs>(args: SelectSubset<T, teacherUpdateArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {teacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teacherDeleteManyArgs>(args?: SelectSubset<T, teacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teacherUpdateManyArgs>(args: SelectSubset<T, teacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {teacherUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `teacher_id`
     * const teacherWithTeacher_idOnly = await prisma.teacher.updateManyAndReturn({
     *   select: { teacher_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teacherUpdateManyAndReturnArgs>(args: SelectSubset<T, teacherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher.
     * @param {teacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends teacherUpsertArgs>(args: SelectSubset<T, teacherUpsertArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teacherCountArgs>(
      args?: Subset<T, teacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teacherGroupByArgs['orderBy'] }
        : { orderBy?: teacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teacher model
   */
  readonly fields: teacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher_classroom<T extends teacher$teacher_classroomArgs<ExtArgs> = {}>(args?: Subset<T, teacher$teacher_classroomArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teacher model
   */
  interface teacherFieldRefs {
    readonly teacher_id: FieldRef<"teacher", 'Int'>
    readonly user_id: FieldRef<"teacher", 'Int'>
    readonly created_at: FieldRef<"teacher", 'DateTime'>
    readonly updated_at: FieldRef<"teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teacher findUnique
   */
  export type teacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher findUniqueOrThrow
   */
  export type teacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher findFirst
   */
  export type teacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher findFirstOrThrow
   */
  export type teacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teacher to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher findMany
   */
  export type teacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teacherOrderByWithRelationInput | teacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * teacher create
   */
  export type teacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The data needed to create a teacher.
     */
    data: XOR<teacherCreateInput, teacherUncheckedCreateInput>
  }

  /**
   * teacher createMany
   */
  export type teacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teacherCreateManyInput | teacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teacher createManyAndReturn
   */
  export type teacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * The data used to create many teachers.
     */
    data: teacherCreateManyInput | teacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher update
   */
  export type teacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The data needed to update a teacher.
     */
    data: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
    /**
     * Choose, which teacher to update.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher updateMany
   */
  export type teacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
  }

  /**
   * teacher updateManyAndReturn
   */
  export type teacherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * The data used to update teachers.
     */
    data: XOR<teacherUpdateManyMutationInput, teacherUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher upsert
   */
  export type teacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * The filter to search for the teacher to update in case it exists.
     */
    where: teacherWhereUniqueInput
    /**
     * In case the teacher found by the `where` argument doesn't exist, create a new teacher with this data.
     */
    create: XOR<teacherCreateInput, teacherUncheckedCreateInput>
    /**
     * In case the teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teacherUpdateInput, teacherUncheckedUpdateInput>
  }

  /**
   * teacher delete
   */
  export type teacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    /**
     * Filter which teacher to delete.
     */
    where: teacherWhereUniqueInput
  }

  /**
   * teacher deleteMany
   */
  export type teacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teacherWhereInput
    /**
     * Limit how many teachers to delete.
     */
    limit?: number
  }

  /**
   * teacher.teacher_classroom
   */
  export type teacher$teacher_classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    where?: teacher_classroomWhereInput
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    cursor?: teacher_classroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teacher_classroomScalarFieldEnum | Teacher_classroomScalarFieldEnum[]
  }

  /**
   * teacher without action
   */
  export type teacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
  }


  /**
   * Model teacher_classroom
   */

  export type AggregateTeacher_classroom = {
    _count: Teacher_classroomCountAggregateOutputType | null
    _avg: Teacher_classroomAvgAggregateOutputType | null
    _sum: Teacher_classroomSumAggregateOutputType | null
    _min: Teacher_classroomMinAggregateOutputType | null
    _max: Teacher_classroomMaxAggregateOutputType | null
  }

  export type Teacher_classroomAvgAggregateOutputType = {
    teacher_classrood_id: number | null
    teacher_id: number | null
    classroom_id: number | null
  }

  export type Teacher_classroomSumAggregateOutputType = {
    teacher_classrood_id: number | null
    teacher_id: number | null
    classroom_id: number | null
  }

  export type Teacher_classroomMinAggregateOutputType = {
    teacher_classrood_id: number | null
    teacher_id: number | null
    classroom_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Teacher_classroomMaxAggregateOutputType = {
    teacher_classrood_id: number | null
    teacher_id: number | null
    classroom_id: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Teacher_classroomCountAggregateOutputType = {
    teacher_classrood_id: number
    teacher_id: number
    classroom_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Teacher_classroomAvgAggregateInputType = {
    teacher_classrood_id?: true
    teacher_id?: true
    classroom_id?: true
  }

  export type Teacher_classroomSumAggregateInputType = {
    teacher_classrood_id?: true
    teacher_id?: true
    classroom_id?: true
  }

  export type Teacher_classroomMinAggregateInputType = {
    teacher_classrood_id?: true
    teacher_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Teacher_classroomMaxAggregateInputType = {
    teacher_classrood_id?: true
    teacher_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Teacher_classroomCountAggregateInputType = {
    teacher_classrood_id?: true
    teacher_id?: true
    classroom_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Teacher_classroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher_classroom to aggregate.
     */
    where?: teacher_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_classrooms to fetch.
     */
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teacher_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teacher_classrooms
    **/
    _count?: true | Teacher_classroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Teacher_classroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Teacher_classroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Teacher_classroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Teacher_classroomMaxAggregateInputType
  }

  export type GetTeacher_classroomAggregateType<T extends Teacher_classroomAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher_classroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher_classroom[P]>
      : GetScalarType<T[P], AggregateTeacher_classroom[P]>
  }




  export type teacher_classroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacher_classroomWhereInput
    orderBy?: teacher_classroomOrderByWithAggregationInput | teacher_classroomOrderByWithAggregationInput[]
    by: Teacher_classroomScalarFieldEnum[] | Teacher_classroomScalarFieldEnum
    having?: teacher_classroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Teacher_classroomCountAggregateInputType | true
    _avg?: Teacher_classroomAvgAggregateInputType
    _sum?: Teacher_classroomSumAggregateInputType
    _min?: Teacher_classroomMinAggregateInputType
    _max?: Teacher_classroomMaxAggregateInputType
  }

  export type Teacher_classroomGroupByOutputType = {
    teacher_classrood_id: number
    teacher_id: number
    classroom_id: number
    created_at: Date
    updated_at: Date
    _count: Teacher_classroomCountAggregateOutputType | null
    _avg: Teacher_classroomAvgAggregateOutputType | null
    _sum: Teacher_classroomSumAggregateOutputType | null
    _min: Teacher_classroomMinAggregateOutputType | null
    _max: Teacher_classroomMaxAggregateOutputType | null
  }

  type GetTeacher_classroomGroupByPayload<T extends teacher_classroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Teacher_classroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Teacher_classroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Teacher_classroomGroupByOutputType[P]>
            : GetScalarType<T[P], Teacher_classroomGroupByOutputType[P]>
        }
      >
    >


  export type teacher_classroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_classrood_id?: boolean
    teacher_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_classroom"]>

  export type teacher_classroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_classrood_id?: boolean
    teacher_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_classroom"]>

  export type teacher_classroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacher_classrood_id?: boolean
    teacher_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_classroom"]>

  export type teacher_classroomSelectScalar = {
    teacher_classrood_id?: boolean
    teacher_id?: boolean
    classroom_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type teacher_classroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"teacher_classrood_id" | "teacher_id" | "classroom_id" | "created_at" | "updated_at", ExtArgs["result"]["teacher_classroom"]>
  export type teacher_classroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }
  export type teacher_classroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }
  export type teacher_classroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | teacherDefaultArgs<ExtArgs>
    classroom?: boolean | classroomDefaultArgs<ExtArgs>
  }

  export type $teacher_classroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teacher_classroom"
    objects: {
      teacher: Prisma.$teacherPayload<ExtArgs>
      classroom: Prisma.$classroomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teacher_classrood_id: number
      teacher_id: number
      classroom_id: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["teacher_classroom"]>
    composites: {}
  }

  type teacher_classroomGetPayload<S extends boolean | null | undefined | teacher_classroomDefaultArgs> = $Result.GetResult<Prisma.$teacher_classroomPayload, S>

  type teacher_classroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teacher_classroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Teacher_classroomCountAggregateInputType | true
    }

  export interface teacher_classroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teacher_classroom'], meta: { name: 'teacher_classroom' } }
    /**
     * Find zero or one Teacher_classroom that matches the filter.
     * @param {teacher_classroomFindUniqueArgs} args - Arguments to find a Teacher_classroom
     * @example
     * // Get one Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teacher_classroomFindUniqueArgs>(args: SelectSubset<T, teacher_classroomFindUniqueArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher_classroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teacher_classroomFindUniqueOrThrowArgs} args - Arguments to find a Teacher_classroom
     * @example
     * // Get one Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teacher_classroomFindUniqueOrThrowArgs>(args: SelectSubset<T, teacher_classroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher_classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomFindFirstArgs} args - Arguments to find a Teacher_classroom
     * @example
     * // Get one Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teacher_classroomFindFirstArgs>(args?: SelectSubset<T, teacher_classroomFindFirstArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher_classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomFindFirstOrThrowArgs} args - Arguments to find a Teacher_classroom
     * @example
     * // Get one Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teacher_classroomFindFirstOrThrowArgs>(args?: SelectSubset<T, teacher_classroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teacher_classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teacher_classrooms
     * const teacher_classrooms = await prisma.teacher_classroom.findMany()
     * 
     * // Get first 10 Teacher_classrooms
     * const teacher_classrooms = await prisma.teacher_classroom.findMany({ take: 10 })
     * 
     * // Only select the `teacher_classrood_id`
     * const teacher_classroomWithTeacher_classrood_idOnly = await prisma.teacher_classroom.findMany({ select: { teacher_classrood_id: true } })
     * 
     */
    findMany<T extends teacher_classroomFindManyArgs>(args?: SelectSubset<T, teacher_classroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher_classroom.
     * @param {teacher_classroomCreateArgs} args - Arguments to create a Teacher_classroom.
     * @example
     * // Create one Teacher_classroom
     * const Teacher_classroom = await prisma.teacher_classroom.create({
     *   data: {
     *     // ... data to create a Teacher_classroom
     *   }
     * })
     * 
     */
    create<T extends teacher_classroomCreateArgs>(args: SelectSubset<T, teacher_classroomCreateArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teacher_classrooms.
     * @param {teacher_classroomCreateManyArgs} args - Arguments to create many Teacher_classrooms.
     * @example
     * // Create many Teacher_classrooms
     * const teacher_classroom = await prisma.teacher_classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teacher_classroomCreateManyArgs>(args?: SelectSubset<T, teacher_classroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teacher_classrooms and returns the data saved in the database.
     * @param {teacher_classroomCreateManyAndReturnArgs} args - Arguments to create many Teacher_classrooms.
     * @example
     * // Create many Teacher_classrooms
     * const teacher_classroom = await prisma.teacher_classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teacher_classrooms and only return the `teacher_classrood_id`
     * const teacher_classroomWithTeacher_classrood_idOnly = await prisma.teacher_classroom.createManyAndReturn({
     *   select: { teacher_classrood_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teacher_classroomCreateManyAndReturnArgs>(args?: SelectSubset<T, teacher_classroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher_classroom.
     * @param {teacher_classroomDeleteArgs} args - Arguments to delete one Teacher_classroom.
     * @example
     * // Delete one Teacher_classroom
     * const Teacher_classroom = await prisma.teacher_classroom.delete({
     *   where: {
     *     // ... filter to delete one Teacher_classroom
     *   }
     * })
     * 
     */
    delete<T extends teacher_classroomDeleteArgs>(args: SelectSubset<T, teacher_classroomDeleteArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher_classroom.
     * @param {teacher_classroomUpdateArgs} args - Arguments to update one Teacher_classroom.
     * @example
     * // Update one Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teacher_classroomUpdateArgs>(args: SelectSubset<T, teacher_classroomUpdateArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teacher_classrooms.
     * @param {teacher_classroomDeleteManyArgs} args - Arguments to filter Teacher_classrooms to delete.
     * @example
     * // Delete a few Teacher_classrooms
     * const { count } = await prisma.teacher_classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teacher_classroomDeleteManyArgs>(args?: SelectSubset<T, teacher_classroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teacher_classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teacher_classrooms
     * const teacher_classroom = await prisma.teacher_classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teacher_classroomUpdateManyArgs>(args: SelectSubset<T, teacher_classroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teacher_classrooms and returns the data updated in the database.
     * @param {teacher_classroomUpdateManyAndReturnArgs} args - Arguments to update many Teacher_classrooms.
     * @example
     * // Update many Teacher_classrooms
     * const teacher_classroom = await prisma.teacher_classroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teacher_classrooms and only return the `teacher_classrood_id`
     * const teacher_classroomWithTeacher_classrood_idOnly = await prisma.teacher_classroom.updateManyAndReturn({
     *   select: { teacher_classrood_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teacher_classroomUpdateManyAndReturnArgs>(args: SelectSubset<T, teacher_classroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher_classroom.
     * @param {teacher_classroomUpsertArgs} args - Arguments to update or create a Teacher_classroom.
     * @example
     * // Update or create a Teacher_classroom
     * const teacher_classroom = await prisma.teacher_classroom.upsert({
     *   create: {
     *     // ... data to create a Teacher_classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher_classroom we want to update
     *   }
     * })
     */
    upsert<T extends teacher_classroomUpsertArgs>(args: SelectSubset<T, teacher_classroomUpsertArgs<ExtArgs>>): Prisma__teacher_classroomClient<$Result.GetResult<Prisma.$teacher_classroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teacher_classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomCountArgs} args - Arguments to filter Teacher_classrooms to count.
     * @example
     * // Count the number of Teacher_classrooms
     * const count = await prisma.teacher_classroom.count({
     *   where: {
     *     // ... the filter for the Teacher_classrooms we want to count
     *   }
     * })
    **/
    count<T extends teacher_classroomCountArgs>(
      args?: Subset<T, teacher_classroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Teacher_classroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher_classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Teacher_classroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Teacher_classroomAggregateArgs>(args: Subset<T, Teacher_classroomAggregateArgs>): Prisma.PrismaPromise<GetTeacher_classroomAggregateType<T>>

    /**
     * Group by Teacher_classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_classroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teacher_classroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teacher_classroomGroupByArgs['orderBy'] }
        : { orderBy?: teacher_classroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teacher_classroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacher_classroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teacher_classroom model
   */
  readonly fields: teacher_classroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teacher_classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teacher_classroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends teacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teacherDefaultArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends classroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, classroomDefaultArgs<ExtArgs>>): Prisma__classroomClient<$Result.GetResult<Prisma.$classroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teacher_classroom model
   */
  interface teacher_classroomFieldRefs {
    readonly teacher_classrood_id: FieldRef<"teacher_classroom", 'Int'>
    readonly teacher_id: FieldRef<"teacher_classroom", 'Int'>
    readonly classroom_id: FieldRef<"teacher_classroom", 'Int'>
    readonly created_at: FieldRef<"teacher_classroom", 'DateTime'>
    readonly updated_at: FieldRef<"teacher_classroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * teacher_classroom findUnique
   */
  export type teacher_classroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter, which teacher_classroom to fetch.
     */
    where: teacher_classroomWhereUniqueInput
  }

  /**
   * teacher_classroom findUniqueOrThrow
   */
  export type teacher_classroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter, which teacher_classroom to fetch.
     */
    where: teacher_classroomWhereUniqueInput
  }

  /**
   * teacher_classroom findFirst
   */
  export type teacher_classroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter, which teacher_classroom to fetch.
     */
    where?: teacher_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_classrooms to fetch.
     */
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teacher_classrooms.
     */
    cursor?: teacher_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teacher_classrooms.
     */
    distinct?: Teacher_classroomScalarFieldEnum | Teacher_classroomScalarFieldEnum[]
  }

  /**
   * teacher_classroom findFirstOrThrow
   */
  export type teacher_classroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter, which teacher_classroom to fetch.
     */
    where?: teacher_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_classrooms to fetch.
     */
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teacher_classrooms.
     */
    cursor?: teacher_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teacher_classrooms.
     */
    distinct?: Teacher_classroomScalarFieldEnum | Teacher_classroomScalarFieldEnum[]
  }

  /**
   * teacher_classroom findMany
   */
  export type teacher_classroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter, which teacher_classrooms to fetch.
     */
    where?: teacher_classroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_classrooms to fetch.
     */
    orderBy?: teacher_classroomOrderByWithRelationInput | teacher_classroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teacher_classrooms.
     */
    cursor?: teacher_classroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_classrooms.
     */
    skip?: number
    distinct?: Teacher_classroomScalarFieldEnum | Teacher_classroomScalarFieldEnum[]
  }

  /**
   * teacher_classroom create
   */
  export type teacher_classroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * The data needed to create a teacher_classroom.
     */
    data: XOR<teacher_classroomCreateInput, teacher_classroomUncheckedCreateInput>
  }

  /**
   * teacher_classroom createMany
   */
  export type teacher_classroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teacher_classrooms.
     */
    data: teacher_classroomCreateManyInput | teacher_classroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teacher_classroom createManyAndReturn
   */
  export type teacher_classroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * The data used to create many teacher_classrooms.
     */
    data: teacher_classroomCreateManyInput | teacher_classroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher_classroom update
   */
  export type teacher_classroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * The data needed to update a teacher_classroom.
     */
    data: XOR<teacher_classroomUpdateInput, teacher_classroomUncheckedUpdateInput>
    /**
     * Choose, which teacher_classroom to update.
     */
    where: teacher_classroomWhereUniqueInput
  }

  /**
   * teacher_classroom updateMany
   */
  export type teacher_classroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teacher_classrooms.
     */
    data: XOR<teacher_classroomUpdateManyMutationInput, teacher_classroomUncheckedUpdateManyInput>
    /**
     * Filter which teacher_classrooms to update
     */
    where?: teacher_classroomWhereInput
    /**
     * Limit how many teacher_classrooms to update.
     */
    limit?: number
  }

  /**
   * teacher_classroom updateManyAndReturn
   */
  export type teacher_classroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * The data used to update teacher_classrooms.
     */
    data: XOR<teacher_classroomUpdateManyMutationInput, teacher_classroomUncheckedUpdateManyInput>
    /**
     * Filter which teacher_classrooms to update
     */
    where?: teacher_classroomWhereInput
    /**
     * Limit how many teacher_classrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher_classroom upsert
   */
  export type teacher_classroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * The filter to search for the teacher_classroom to update in case it exists.
     */
    where: teacher_classroomWhereUniqueInput
    /**
     * In case the teacher_classroom found by the `where` argument doesn't exist, create a new teacher_classroom with this data.
     */
    create: XOR<teacher_classroomCreateInput, teacher_classroomUncheckedCreateInput>
    /**
     * In case the teacher_classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teacher_classroomUpdateInput, teacher_classroomUncheckedUpdateInput>
  }

  /**
   * teacher_classroom delete
   */
  export type teacher_classroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
    /**
     * Filter which teacher_classroom to delete.
     */
    where: teacher_classroomWhereUniqueInput
  }

  /**
   * teacher_classroom deleteMany
   */
  export type teacher_classroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher_classrooms to delete
     */
    where?: teacher_classroomWhereInput
    /**
     * Limit how many teacher_classrooms to delete.
     */
    limit?: number
  }

  /**
   * teacher_classroom without action
   */
  export type teacher_classroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_classroom
     */
    select?: teacher_classroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_classroom
     */
    omit?: teacher_classroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_classroomInclude<ExtArgs> | null
  }


  /**
   * Model scholarship
   */

  export type AggregateScholarship = {
    _count: ScholarshipCountAggregateOutputType | null
    _avg: ScholarshipAvgAggregateOutputType | null
    _sum: ScholarshipSumAggregateOutputType | null
    _min: ScholarshipMinAggregateOutputType | null
    _max: ScholarshipMaxAggregateOutputType | null
  }

  export type ScholarshipAvgAggregateOutputType = {
    scholarship_id: number | null
    organization_id: number | null
    gpa: Decimal | null
  }

  export type ScholarshipSumAggregateOutputType = {
    scholarship_id: number | null
    organization_id: number | null
    gpa: Decimal | null
  }

  export type ScholarshipMinAggregateOutputType = {
    scholarship_id: number | null
    name: string | null
    organization_id: number | null
    award: string | null
    description: string | null
    category: string | null
    eligibility: string | null
    region: string | null
    deadline: Date | null
    fafsa: boolean | null
    gpa: Decimal | null
    created_at: Date | null
  }

  export type ScholarshipMaxAggregateOutputType = {
    scholarship_id: number | null
    name: string | null
    organization_id: number | null
    award: string | null
    description: string | null
    category: string | null
    eligibility: string | null
    region: string | null
    deadline: Date | null
    fafsa: boolean | null
    gpa: Decimal | null
    created_at: Date | null
  }

  export type ScholarshipCountAggregateOutputType = {
    scholarship_id: number
    name: number
    organization_id: number
    award: number
    description: number
    category: number
    eligibility: number
    region: number
    deadline: number
    fafsa: number
    gpa: number
    created_at: number
    _all: number
  }


  export type ScholarshipAvgAggregateInputType = {
    scholarship_id?: true
    organization_id?: true
    gpa?: true
  }

  export type ScholarshipSumAggregateInputType = {
    scholarship_id?: true
    organization_id?: true
    gpa?: true
  }

  export type ScholarshipMinAggregateInputType = {
    scholarship_id?: true
    name?: true
    organization_id?: true
    award?: true
    description?: true
    category?: true
    eligibility?: true
    region?: true
    deadline?: true
    fafsa?: true
    gpa?: true
    created_at?: true
  }

  export type ScholarshipMaxAggregateInputType = {
    scholarship_id?: true
    name?: true
    organization_id?: true
    award?: true
    description?: true
    category?: true
    eligibility?: true
    region?: true
    deadline?: true
    fafsa?: true
    gpa?: true
    created_at?: true
  }

  export type ScholarshipCountAggregateInputType = {
    scholarship_id?: true
    name?: true
    organization_id?: true
    award?: true
    description?: true
    category?: true
    eligibility?: true
    region?: true
    deadline?: true
    fafsa?: true
    gpa?: true
    created_at?: true
    _all?: true
  }

  export type ScholarshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scholarship to aggregate.
     */
    where?: scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scholarships to fetch.
     */
    orderBy?: scholarshipOrderByWithRelationInput | scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned scholarships
    **/
    _count?: true | ScholarshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScholarshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScholarshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScholarshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScholarshipMaxAggregateInputType
  }

  export type GetScholarshipAggregateType<T extends ScholarshipAggregateArgs> = {
        [P in keyof T & keyof AggregateScholarship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScholarship[P]>
      : GetScalarType<T[P], AggregateScholarship[P]>
  }




  export type scholarshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: scholarshipWhereInput
    orderBy?: scholarshipOrderByWithAggregationInput | scholarshipOrderByWithAggregationInput[]
    by: ScholarshipScalarFieldEnum[] | ScholarshipScalarFieldEnum
    having?: scholarshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScholarshipCountAggregateInputType | true
    _avg?: ScholarshipAvgAggregateInputType
    _sum?: ScholarshipSumAggregateInputType
    _min?: ScholarshipMinAggregateInputType
    _max?: ScholarshipMaxAggregateInputType
  }

  export type ScholarshipGroupByOutputType = {
    scholarship_id: number
    name: string
    organization_id: number
    award: string | null
    description: string | null
    category: string | null
    eligibility: string | null
    region: string | null
    deadline: Date | null
    fafsa: boolean | null
    gpa: Decimal | null
    created_at: Date | null
    _count: ScholarshipCountAggregateOutputType | null
    _avg: ScholarshipAvgAggregateOutputType | null
    _sum: ScholarshipSumAggregateOutputType | null
    _min: ScholarshipMinAggregateOutputType | null
    _max: ScholarshipMaxAggregateOutputType | null
  }

  type GetScholarshipGroupByPayload<T extends scholarshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScholarshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScholarshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScholarshipGroupByOutputType[P]>
            : GetScalarType<T[P], ScholarshipGroupByOutputType[P]>
        }
      >
    >


  export type scholarshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scholarship_id?: boolean
    name?: boolean
    organization_id?: boolean
    award?: boolean
    description?: boolean
    category?: boolean
    eligibility?: boolean
    region?: boolean
    deadline?: boolean
    fafsa?: boolean
    gpa?: boolean
    created_at?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    student_scholarship?: boolean | scholarship$student_scholarshipArgs<ExtArgs>
    _count?: boolean | ScholarshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scholarship"]>

  export type scholarshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scholarship_id?: boolean
    name?: boolean
    organization_id?: boolean
    award?: boolean
    description?: boolean
    category?: boolean
    eligibility?: boolean
    region?: boolean
    deadline?: boolean
    fafsa?: boolean
    gpa?: boolean
    created_at?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scholarship"]>

  export type scholarshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scholarship_id?: boolean
    name?: boolean
    organization_id?: boolean
    award?: boolean
    description?: boolean
    category?: boolean
    eligibility?: boolean
    region?: boolean
    deadline?: boolean
    fafsa?: boolean
    gpa?: boolean
    created_at?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scholarship"]>

  export type scholarshipSelectScalar = {
    scholarship_id?: boolean
    name?: boolean
    organization_id?: boolean
    award?: boolean
    description?: boolean
    category?: boolean
    eligibility?: boolean
    region?: boolean
    deadline?: boolean
    fafsa?: boolean
    gpa?: boolean
    created_at?: boolean
  }

  export type scholarshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"scholarship_id" | "name" | "organization_id" | "award" | "description" | "category" | "eligibility" | "region" | "deadline" | "fafsa" | "gpa" | "created_at", ExtArgs["result"]["scholarship"]>
  export type scholarshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    student_scholarship?: boolean | scholarship$student_scholarshipArgs<ExtArgs>
    _count?: boolean | ScholarshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type scholarshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
  }
  export type scholarshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
  }

  export type $scholarshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "scholarship"
    objects: {
      organization: Prisma.$organizationPayload<ExtArgs>
      student_scholarship: Prisma.$student_scholarshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      scholarship_id: number
      name: string
      organization_id: number
      award: string | null
      description: string | null
      category: string | null
      eligibility: string | null
      region: string | null
      deadline: Date | null
      fafsa: boolean | null
      gpa: Prisma.Decimal | null
      created_at: Date | null
    }, ExtArgs["result"]["scholarship"]>
    composites: {}
  }

  type scholarshipGetPayload<S extends boolean | null | undefined | scholarshipDefaultArgs> = $Result.GetResult<Prisma.$scholarshipPayload, S>

  type scholarshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<scholarshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScholarshipCountAggregateInputType | true
    }

  export interface scholarshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['scholarship'], meta: { name: 'scholarship' } }
    /**
     * Find zero or one Scholarship that matches the filter.
     * @param {scholarshipFindUniqueArgs} args - Arguments to find a Scholarship
     * @example
     * // Get one Scholarship
     * const scholarship = await prisma.scholarship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends scholarshipFindUniqueArgs>(args: SelectSubset<T, scholarshipFindUniqueArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Scholarship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {scholarshipFindUniqueOrThrowArgs} args - Arguments to find a Scholarship
     * @example
     * // Get one Scholarship
     * const scholarship = await prisma.scholarship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends scholarshipFindUniqueOrThrowArgs>(args: SelectSubset<T, scholarshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scholarship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipFindFirstArgs} args - Arguments to find a Scholarship
     * @example
     * // Get one Scholarship
     * const scholarship = await prisma.scholarship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends scholarshipFindFirstArgs>(args?: SelectSubset<T, scholarshipFindFirstArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Scholarship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipFindFirstOrThrowArgs} args - Arguments to find a Scholarship
     * @example
     * // Get one Scholarship
     * const scholarship = await prisma.scholarship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends scholarshipFindFirstOrThrowArgs>(args?: SelectSubset<T, scholarshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Scholarships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Scholarships
     * const scholarships = await prisma.scholarship.findMany()
     * 
     * // Get first 10 Scholarships
     * const scholarships = await prisma.scholarship.findMany({ take: 10 })
     * 
     * // Only select the `scholarship_id`
     * const scholarshipWithScholarship_idOnly = await prisma.scholarship.findMany({ select: { scholarship_id: true } })
     * 
     */
    findMany<T extends scholarshipFindManyArgs>(args?: SelectSubset<T, scholarshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Scholarship.
     * @param {scholarshipCreateArgs} args - Arguments to create a Scholarship.
     * @example
     * // Create one Scholarship
     * const Scholarship = await prisma.scholarship.create({
     *   data: {
     *     // ... data to create a Scholarship
     *   }
     * })
     * 
     */
    create<T extends scholarshipCreateArgs>(args: SelectSubset<T, scholarshipCreateArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Scholarships.
     * @param {scholarshipCreateManyArgs} args - Arguments to create many Scholarships.
     * @example
     * // Create many Scholarships
     * const scholarship = await prisma.scholarship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends scholarshipCreateManyArgs>(args?: SelectSubset<T, scholarshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Scholarships and returns the data saved in the database.
     * @param {scholarshipCreateManyAndReturnArgs} args - Arguments to create many Scholarships.
     * @example
     * // Create many Scholarships
     * const scholarship = await prisma.scholarship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Scholarships and only return the `scholarship_id`
     * const scholarshipWithScholarship_idOnly = await prisma.scholarship.createManyAndReturn({
     *   select: { scholarship_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends scholarshipCreateManyAndReturnArgs>(args?: SelectSubset<T, scholarshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Scholarship.
     * @param {scholarshipDeleteArgs} args - Arguments to delete one Scholarship.
     * @example
     * // Delete one Scholarship
     * const Scholarship = await prisma.scholarship.delete({
     *   where: {
     *     // ... filter to delete one Scholarship
     *   }
     * })
     * 
     */
    delete<T extends scholarshipDeleteArgs>(args: SelectSubset<T, scholarshipDeleteArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Scholarship.
     * @param {scholarshipUpdateArgs} args - Arguments to update one Scholarship.
     * @example
     * // Update one Scholarship
     * const scholarship = await prisma.scholarship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends scholarshipUpdateArgs>(args: SelectSubset<T, scholarshipUpdateArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Scholarships.
     * @param {scholarshipDeleteManyArgs} args - Arguments to filter Scholarships to delete.
     * @example
     * // Delete a few Scholarships
     * const { count } = await prisma.scholarship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends scholarshipDeleteManyArgs>(args?: SelectSubset<T, scholarshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Scholarships
     * const scholarship = await prisma.scholarship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends scholarshipUpdateManyArgs>(args: SelectSubset<T, scholarshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Scholarships and returns the data updated in the database.
     * @param {scholarshipUpdateManyAndReturnArgs} args - Arguments to update many Scholarships.
     * @example
     * // Update many Scholarships
     * const scholarship = await prisma.scholarship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Scholarships and only return the `scholarship_id`
     * const scholarshipWithScholarship_idOnly = await prisma.scholarship.updateManyAndReturn({
     *   select: { scholarship_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends scholarshipUpdateManyAndReturnArgs>(args: SelectSubset<T, scholarshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Scholarship.
     * @param {scholarshipUpsertArgs} args - Arguments to update or create a Scholarship.
     * @example
     * // Update or create a Scholarship
     * const scholarship = await prisma.scholarship.upsert({
     *   create: {
     *     // ... data to create a Scholarship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Scholarship we want to update
     *   }
     * })
     */
    upsert<T extends scholarshipUpsertArgs>(args: SelectSubset<T, scholarshipUpsertArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Scholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipCountArgs} args - Arguments to filter Scholarships to count.
     * @example
     * // Count the number of Scholarships
     * const count = await prisma.scholarship.count({
     *   where: {
     *     // ... the filter for the Scholarships we want to count
     *   }
     * })
    **/
    count<T extends scholarshipCountArgs>(
      args?: Subset<T, scholarshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScholarshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Scholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScholarshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScholarshipAggregateArgs>(args: Subset<T, ScholarshipAggregateArgs>): Prisma.PrismaPromise<GetScholarshipAggregateType<T>>

    /**
     * Group by Scholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {scholarshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends scholarshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: scholarshipGroupByArgs['orderBy'] }
        : { orderBy?: scholarshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, scholarshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScholarshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the scholarship model
   */
  readonly fields: scholarshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for scholarship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__scholarshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends organizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationDefaultArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student_scholarship<T extends scholarship$student_scholarshipArgs<ExtArgs> = {}>(args?: Subset<T, scholarship$student_scholarshipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the scholarship model
   */
  interface scholarshipFieldRefs {
    readonly scholarship_id: FieldRef<"scholarship", 'Int'>
    readonly name: FieldRef<"scholarship", 'String'>
    readonly organization_id: FieldRef<"scholarship", 'Int'>
    readonly award: FieldRef<"scholarship", 'String'>
    readonly description: FieldRef<"scholarship", 'String'>
    readonly category: FieldRef<"scholarship", 'String'>
    readonly eligibility: FieldRef<"scholarship", 'String'>
    readonly region: FieldRef<"scholarship", 'String'>
    readonly deadline: FieldRef<"scholarship", 'DateTime'>
    readonly fafsa: FieldRef<"scholarship", 'Boolean'>
    readonly gpa: FieldRef<"scholarship", 'Decimal'>
    readonly created_at: FieldRef<"scholarship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * scholarship findUnique
   */
  export type scholarshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which scholarship to fetch.
     */
    where: scholarshipWhereUniqueInput
  }

  /**
   * scholarship findUniqueOrThrow
   */
  export type scholarshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which scholarship to fetch.
     */
    where: scholarshipWhereUniqueInput
  }

  /**
   * scholarship findFirst
   */
  export type scholarshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which scholarship to fetch.
     */
    where?: scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scholarships to fetch.
     */
    orderBy?: scholarshipOrderByWithRelationInput | scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scholarships.
     */
    cursor?: scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scholarships.
     */
    distinct?: ScholarshipScalarFieldEnum | ScholarshipScalarFieldEnum[]
  }

  /**
   * scholarship findFirstOrThrow
   */
  export type scholarshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which scholarship to fetch.
     */
    where?: scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scholarships to fetch.
     */
    orderBy?: scholarshipOrderByWithRelationInput | scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for scholarships.
     */
    cursor?: scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of scholarships.
     */
    distinct?: ScholarshipScalarFieldEnum | ScholarshipScalarFieldEnum[]
  }

  /**
   * scholarship findMany
   */
  export type scholarshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which scholarships to fetch.
     */
    where?: scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of scholarships to fetch.
     */
    orderBy?: scholarshipOrderByWithRelationInput | scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing scholarships.
     */
    cursor?: scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` scholarships.
     */
    skip?: number
    distinct?: ScholarshipScalarFieldEnum | ScholarshipScalarFieldEnum[]
  }

  /**
   * scholarship create
   */
  export type scholarshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * The data needed to create a scholarship.
     */
    data: XOR<scholarshipCreateInput, scholarshipUncheckedCreateInput>
  }

  /**
   * scholarship createMany
   */
  export type scholarshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many scholarships.
     */
    data: scholarshipCreateManyInput | scholarshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * scholarship createManyAndReturn
   */
  export type scholarshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * The data used to create many scholarships.
     */
    data: scholarshipCreateManyInput | scholarshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * scholarship update
   */
  export type scholarshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * The data needed to update a scholarship.
     */
    data: XOR<scholarshipUpdateInput, scholarshipUncheckedUpdateInput>
    /**
     * Choose, which scholarship to update.
     */
    where: scholarshipWhereUniqueInput
  }

  /**
   * scholarship updateMany
   */
  export type scholarshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update scholarships.
     */
    data: XOR<scholarshipUpdateManyMutationInput, scholarshipUncheckedUpdateManyInput>
    /**
     * Filter which scholarships to update
     */
    where?: scholarshipWhereInput
    /**
     * Limit how many scholarships to update.
     */
    limit?: number
  }

  /**
   * scholarship updateManyAndReturn
   */
  export type scholarshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * The data used to update scholarships.
     */
    data: XOR<scholarshipUpdateManyMutationInput, scholarshipUncheckedUpdateManyInput>
    /**
     * Filter which scholarships to update
     */
    where?: scholarshipWhereInput
    /**
     * Limit how many scholarships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * scholarship upsert
   */
  export type scholarshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * The filter to search for the scholarship to update in case it exists.
     */
    where: scholarshipWhereUniqueInput
    /**
     * In case the scholarship found by the `where` argument doesn't exist, create a new scholarship with this data.
     */
    create: XOR<scholarshipCreateInput, scholarshipUncheckedCreateInput>
    /**
     * In case the scholarship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<scholarshipUpdateInput, scholarshipUncheckedUpdateInput>
  }

  /**
   * scholarship delete
   */
  export type scholarshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    /**
     * Filter which scholarship to delete.
     */
    where: scholarshipWhereUniqueInput
  }

  /**
   * scholarship deleteMany
   */
  export type scholarshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which scholarships to delete
     */
    where?: scholarshipWhereInput
    /**
     * Limit how many scholarships to delete.
     */
    limit?: number
  }

  /**
   * scholarship.student_scholarship
   */
  export type scholarship$student_scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    where?: student_scholarshipWhereInput
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    cursor?: student_scholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_scholarshipScalarFieldEnum | Student_scholarshipScalarFieldEnum[]
  }

  /**
   * scholarship without action
   */
  export type scholarshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
  }


  /**
   * Model student_scholarship
   */

  export type AggregateStudent_scholarship = {
    _count: Student_scholarshipCountAggregateOutputType | null
    _avg: Student_scholarshipAvgAggregateOutputType | null
    _sum: Student_scholarshipSumAggregateOutputType | null
    _min: Student_scholarshipMinAggregateOutputType | null
    _max: Student_scholarshipMaxAggregateOutputType | null
  }

  export type Student_scholarshipAvgAggregateOutputType = {
    student_scholarship_id: number | null
    student_id: number | null
    scholarship_id: number | null
  }

  export type Student_scholarshipSumAggregateOutputType = {
    student_scholarship_id: number | null
    student_id: number | null
    scholarship_id: number | null
  }

  export type Student_scholarshipMinAggregateOutputType = {
    student_scholarship_id: number | null
    student_id: number | null
    scholarship_id: number | null
    is_bookmarked: boolean | null
  }

  export type Student_scholarshipMaxAggregateOutputType = {
    student_scholarship_id: number | null
    student_id: number | null
    scholarship_id: number | null
    is_bookmarked: boolean | null
  }

  export type Student_scholarshipCountAggregateOutputType = {
    student_scholarship_id: number
    student_id: number
    scholarship_id: number
    is_bookmarked: number
    _all: number
  }


  export type Student_scholarshipAvgAggregateInputType = {
    student_scholarship_id?: true
    student_id?: true
    scholarship_id?: true
  }

  export type Student_scholarshipSumAggregateInputType = {
    student_scholarship_id?: true
    student_id?: true
    scholarship_id?: true
  }

  export type Student_scholarshipMinAggregateInputType = {
    student_scholarship_id?: true
    student_id?: true
    scholarship_id?: true
    is_bookmarked?: true
  }

  export type Student_scholarshipMaxAggregateInputType = {
    student_scholarship_id?: true
    student_id?: true
    scholarship_id?: true
    is_bookmarked?: true
  }

  export type Student_scholarshipCountAggregateInputType = {
    student_scholarship_id?: true
    student_id?: true
    scholarship_id?: true
    is_bookmarked?: true
    _all?: true
  }

  export type Student_scholarshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_scholarship to aggregate.
     */
    where?: student_scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_scholarships to fetch.
     */
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_scholarships
    **/
    _count?: true | Student_scholarshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_scholarshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_scholarshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_scholarshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_scholarshipMaxAggregateInputType
  }

  export type GetStudent_scholarshipAggregateType<T extends Student_scholarshipAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_scholarship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_scholarship[P]>
      : GetScalarType<T[P], AggregateStudent_scholarship[P]>
  }




  export type student_scholarshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_scholarshipWhereInput
    orderBy?: student_scholarshipOrderByWithAggregationInput | student_scholarshipOrderByWithAggregationInput[]
    by: Student_scholarshipScalarFieldEnum[] | Student_scholarshipScalarFieldEnum
    having?: student_scholarshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_scholarshipCountAggregateInputType | true
    _avg?: Student_scholarshipAvgAggregateInputType
    _sum?: Student_scholarshipSumAggregateInputType
    _min?: Student_scholarshipMinAggregateInputType
    _max?: Student_scholarshipMaxAggregateInputType
  }

  export type Student_scholarshipGroupByOutputType = {
    student_scholarship_id: number
    student_id: number
    scholarship_id: number
    is_bookmarked: boolean | null
    _count: Student_scholarshipCountAggregateOutputType | null
    _avg: Student_scholarshipAvgAggregateOutputType | null
    _sum: Student_scholarshipSumAggregateOutputType | null
    _min: Student_scholarshipMinAggregateOutputType | null
    _max: Student_scholarshipMaxAggregateOutputType | null
  }

  type GetStudent_scholarshipGroupByPayload<T extends student_scholarshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_scholarshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_scholarshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_scholarshipGroupByOutputType[P]>
            : GetScalarType<T[P], Student_scholarshipGroupByOutputType[P]>
        }
      >
    >


  export type student_scholarshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_scholarship_id?: boolean
    student_id?: boolean
    scholarship_id?: boolean
    is_bookmarked?: boolean
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_scholarship"]>

  export type student_scholarshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_scholarship_id?: boolean
    student_id?: boolean
    scholarship_id?: boolean
    is_bookmarked?: boolean
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_scholarship"]>

  export type student_scholarshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    student_scholarship_id?: boolean
    student_id?: boolean
    scholarship_id?: boolean
    is_bookmarked?: boolean
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_scholarship"]>

  export type student_scholarshipSelectScalar = {
    student_scholarship_id?: boolean
    student_id?: boolean
    scholarship_id?: boolean
    is_bookmarked?: boolean
  }

  export type student_scholarshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"student_scholarship_id" | "student_id" | "scholarship_id" | "is_bookmarked", ExtArgs["result"]["student_scholarship"]>
  export type student_scholarshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }
  export type student_scholarshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }
  export type student_scholarshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | scholarshipDefaultArgs<ExtArgs>
    student?: boolean | studentDefaultArgs<ExtArgs>
  }

  export type $student_scholarshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_scholarship"
    objects: {
      scholarship: Prisma.$scholarshipPayload<ExtArgs>
      student: Prisma.$studentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      student_scholarship_id: number
      student_id: number
      scholarship_id: number
      is_bookmarked: boolean | null
    }, ExtArgs["result"]["student_scholarship"]>
    composites: {}
  }

  type student_scholarshipGetPayload<S extends boolean | null | undefined | student_scholarshipDefaultArgs> = $Result.GetResult<Prisma.$student_scholarshipPayload, S>

  type student_scholarshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_scholarshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_scholarshipCountAggregateInputType | true
    }

  export interface student_scholarshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_scholarship'], meta: { name: 'student_scholarship' } }
    /**
     * Find zero or one Student_scholarship that matches the filter.
     * @param {student_scholarshipFindUniqueArgs} args - Arguments to find a Student_scholarship
     * @example
     * // Get one Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_scholarshipFindUniqueArgs>(args: SelectSubset<T, student_scholarshipFindUniqueArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_scholarship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_scholarshipFindUniqueOrThrowArgs} args - Arguments to find a Student_scholarship
     * @example
     * // Get one Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_scholarshipFindUniqueOrThrowArgs>(args: SelectSubset<T, student_scholarshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_scholarship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipFindFirstArgs} args - Arguments to find a Student_scholarship
     * @example
     * // Get one Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_scholarshipFindFirstArgs>(args?: SelectSubset<T, student_scholarshipFindFirstArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_scholarship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipFindFirstOrThrowArgs} args - Arguments to find a Student_scholarship
     * @example
     * // Get one Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_scholarshipFindFirstOrThrowArgs>(args?: SelectSubset<T, student_scholarshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_scholarships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_scholarships
     * const student_scholarships = await prisma.student_scholarship.findMany()
     * 
     * // Get first 10 Student_scholarships
     * const student_scholarships = await prisma.student_scholarship.findMany({ take: 10 })
     * 
     * // Only select the `student_scholarship_id`
     * const student_scholarshipWithStudent_scholarship_idOnly = await prisma.student_scholarship.findMany({ select: { student_scholarship_id: true } })
     * 
     */
    findMany<T extends student_scholarshipFindManyArgs>(args?: SelectSubset<T, student_scholarshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_scholarship.
     * @param {student_scholarshipCreateArgs} args - Arguments to create a Student_scholarship.
     * @example
     * // Create one Student_scholarship
     * const Student_scholarship = await prisma.student_scholarship.create({
     *   data: {
     *     // ... data to create a Student_scholarship
     *   }
     * })
     * 
     */
    create<T extends student_scholarshipCreateArgs>(args: SelectSubset<T, student_scholarshipCreateArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_scholarships.
     * @param {student_scholarshipCreateManyArgs} args - Arguments to create many Student_scholarships.
     * @example
     * // Create many Student_scholarships
     * const student_scholarship = await prisma.student_scholarship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_scholarshipCreateManyArgs>(args?: SelectSubset<T, student_scholarshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_scholarships and returns the data saved in the database.
     * @param {student_scholarshipCreateManyAndReturnArgs} args - Arguments to create many Student_scholarships.
     * @example
     * // Create many Student_scholarships
     * const student_scholarship = await prisma.student_scholarship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_scholarships and only return the `student_scholarship_id`
     * const student_scholarshipWithStudent_scholarship_idOnly = await prisma.student_scholarship.createManyAndReturn({
     *   select: { student_scholarship_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_scholarshipCreateManyAndReturnArgs>(args?: SelectSubset<T, student_scholarshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student_scholarship.
     * @param {student_scholarshipDeleteArgs} args - Arguments to delete one Student_scholarship.
     * @example
     * // Delete one Student_scholarship
     * const Student_scholarship = await prisma.student_scholarship.delete({
     *   where: {
     *     // ... filter to delete one Student_scholarship
     *   }
     * })
     * 
     */
    delete<T extends student_scholarshipDeleteArgs>(args: SelectSubset<T, student_scholarshipDeleteArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_scholarship.
     * @param {student_scholarshipUpdateArgs} args - Arguments to update one Student_scholarship.
     * @example
     * // Update one Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_scholarshipUpdateArgs>(args: SelectSubset<T, student_scholarshipUpdateArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_scholarships.
     * @param {student_scholarshipDeleteManyArgs} args - Arguments to filter Student_scholarships to delete.
     * @example
     * // Delete a few Student_scholarships
     * const { count } = await prisma.student_scholarship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_scholarshipDeleteManyArgs>(args?: SelectSubset<T, student_scholarshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_scholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_scholarships
     * const student_scholarship = await prisma.student_scholarship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_scholarshipUpdateManyArgs>(args: SelectSubset<T, student_scholarshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_scholarships and returns the data updated in the database.
     * @param {student_scholarshipUpdateManyAndReturnArgs} args - Arguments to update many Student_scholarships.
     * @example
     * // Update many Student_scholarships
     * const student_scholarship = await prisma.student_scholarship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Student_scholarships and only return the `student_scholarship_id`
     * const student_scholarshipWithStudent_scholarship_idOnly = await prisma.student_scholarship.updateManyAndReturn({
     *   select: { student_scholarship_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends student_scholarshipUpdateManyAndReturnArgs>(args: SelectSubset<T, student_scholarshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student_scholarship.
     * @param {student_scholarshipUpsertArgs} args - Arguments to update or create a Student_scholarship.
     * @example
     * // Update or create a Student_scholarship
     * const student_scholarship = await prisma.student_scholarship.upsert({
     *   create: {
     *     // ... data to create a Student_scholarship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_scholarship we want to update
     *   }
     * })
     */
    upsert<T extends student_scholarshipUpsertArgs>(args: SelectSubset<T, student_scholarshipUpsertArgs<ExtArgs>>): Prisma__student_scholarshipClient<$Result.GetResult<Prisma.$student_scholarshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_scholarships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipCountArgs} args - Arguments to filter Student_scholarships to count.
     * @example
     * // Count the number of Student_scholarships
     * const count = await prisma.student_scholarship.count({
     *   where: {
     *     // ... the filter for the Student_scholarships we want to count
     *   }
     * })
    **/
    count<T extends student_scholarshipCountArgs>(
      args?: Subset<T, student_scholarshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_scholarshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_scholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_scholarshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_scholarshipAggregateArgs>(args: Subset<T, Student_scholarshipAggregateArgs>): Prisma.PrismaPromise<GetStudent_scholarshipAggregateType<T>>

    /**
     * Group by Student_scholarship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_scholarshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_scholarshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_scholarshipGroupByArgs['orderBy'] }
        : { orderBy?: student_scholarshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_scholarshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_scholarshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_scholarship model
   */
  readonly fields: student_scholarshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_scholarship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_scholarshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scholarship<T extends scholarshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, scholarshipDefaultArgs<ExtArgs>>): Prisma__scholarshipClient<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends studentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentDefaultArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_scholarship model
   */
  interface student_scholarshipFieldRefs {
    readonly student_scholarship_id: FieldRef<"student_scholarship", 'Int'>
    readonly student_id: FieldRef<"student_scholarship", 'Int'>
    readonly scholarship_id: FieldRef<"student_scholarship", 'Int'>
    readonly is_bookmarked: FieldRef<"student_scholarship", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * student_scholarship findUnique
   */
  export type student_scholarshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which student_scholarship to fetch.
     */
    where: student_scholarshipWhereUniqueInput
  }

  /**
   * student_scholarship findUniqueOrThrow
   */
  export type student_scholarshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which student_scholarship to fetch.
     */
    where: student_scholarshipWhereUniqueInput
  }

  /**
   * student_scholarship findFirst
   */
  export type student_scholarshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which student_scholarship to fetch.
     */
    where?: student_scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_scholarships to fetch.
     */
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_scholarships.
     */
    cursor?: student_scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_scholarships.
     */
    distinct?: Student_scholarshipScalarFieldEnum | Student_scholarshipScalarFieldEnum[]
  }

  /**
   * student_scholarship findFirstOrThrow
   */
  export type student_scholarshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which student_scholarship to fetch.
     */
    where?: student_scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_scholarships to fetch.
     */
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_scholarships.
     */
    cursor?: student_scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_scholarships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_scholarships.
     */
    distinct?: Student_scholarshipScalarFieldEnum | Student_scholarshipScalarFieldEnum[]
  }

  /**
   * student_scholarship findMany
   */
  export type student_scholarshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter, which student_scholarships to fetch.
     */
    where?: student_scholarshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_scholarships to fetch.
     */
    orderBy?: student_scholarshipOrderByWithRelationInput | student_scholarshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_scholarships.
     */
    cursor?: student_scholarshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_scholarships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_scholarships.
     */
    skip?: number
    distinct?: Student_scholarshipScalarFieldEnum | Student_scholarshipScalarFieldEnum[]
  }

  /**
   * student_scholarship create
   */
  export type student_scholarshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * The data needed to create a student_scholarship.
     */
    data: XOR<student_scholarshipCreateInput, student_scholarshipUncheckedCreateInput>
  }

  /**
   * student_scholarship createMany
   */
  export type student_scholarshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_scholarships.
     */
    data: student_scholarshipCreateManyInput | student_scholarshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_scholarship createManyAndReturn
   */
  export type student_scholarshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * The data used to create many student_scholarships.
     */
    data: student_scholarshipCreateManyInput | student_scholarshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_scholarship update
   */
  export type student_scholarshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * The data needed to update a student_scholarship.
     */
    data: XOR<student_scholarshipUpdateInput, student_scholarshipUncheckedUpdateInput>
    /**
     * Choose, which student_scholarship to update.
     */
    where: student_scholarshipWhereUniqueInput
  }

  /**
   * student_scholarship updateMany
   */
  export type student_scholarshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_scholarships.
     */
    data: XOR<student_scholarshipUpdateManyMutationInput, student_scholarshipUncheckedUpdateManyInput>
    /**
     * Filter which student_scholarships to update
     */
    where?: student_scholarshipWhereInput
    /**
     * Limit how many student_scholarships to update.
     */
    limit?: number
  }

  /**
   * student_scholarship updateManyAndReturn
   */
  export type student_scholarshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * The data used to update student_scholarships.
     */
    data: XOR<student_scholarshipUpdateManyMutationInput, student_scholarshipUncheckedUpdateManyInput>
    /**
     * Filter which student_scholarships to update
     */
    where?: student_scholarshipWhereInput
    /**
     * Limit how many student_scholarships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_scholarship upsert
   */
  export type student_scholarshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * The filter to search for the student_scholarship to update in case it exists.
     */
    where: student_scholarshipWhereUniqueInput
    /**
     * In case the student_scholarship found by the `where` argument doesn't exist, create a new student_scholarship with this data.
     */
    create: XOR<student_scholarshipCreateInput, student_scholarshipUncheckedCreateInput>
    /**
     * In case the student_scholarship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_scholarshipUpdateInput, student_scholarshipUncheckedUpdateInput>
  }

  /**
   * student_scholarship delete
   */
  export type student_scholarshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
    /**
     * Filter which student_scholarship to delete.
     */
    where: student_scholarshipWhereUniqueInput
  }

  /**
   * student_scholarship deleteMany
   */
  export type student_scholarshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_scholarships to delete
     */
    where?: student_scholarshipWhereInput
    /**
     * Limit how many student_scholarships to delete.
     */
    limit?: number
  }

  /**
   * student_scholarship without action
   */
  export type student_scholarshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_scholarship
     */
    select?: student_scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_scholarship
     */
    omit?: student_scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_scholarshipInclude<ExtArgs> | null
  }


  /**
   * Model post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    post_id: number | null
    author_id: number | null
  }

  export type PostSumAggregateOutputType = {
    post_id: number | null
    author_id: number | null
  }

  export type PostMinAggregateOutputType = {
    post_id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    author_id: number | null
  }

  export type PostMaxAggregateOutputType = {
    post_id: number | null
    title: string | null
    content: string | null
    published: boolean | null
    author_id: number | null
  }

  export type PostCountAggregateOutputType = {
    post_id: number
    title: number
    content: number
    published: number
    author_id: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    post_id?: true
    author_id?: true
  }

  export type PostSumAggregateInputType = {
    post_id?: true
    author_id?: true
  }

  export type PostMinAggregateInputType = {
    post_id?: true
    title?: true
    content?: true
    published?: true
    author_id?: true
  }

  export type PostMaxAggregateInputType = {
    post_id?: true
    title?: true
    content?: true
    published?: true
    author_id?: true
  }

  export type PostCountAggregateInputType = {
    post_id?: true
    title?: true
    content?: true
    published?: true
    author_id?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post to aggregate.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type postGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postWhereInput
    orderBy?: postOrderByWithAggregationInput | postOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: postScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    post_id: number
    title: string
    content: string | null
    published: boolean
    author_id: number | null
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends postGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type postSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    author_id?: boolean
    author?: boolean | post$authorArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    author_id?: boolean
    author?: boolean | post$authorArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    author_id?: boolean
    author?: boolean | post$authorArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectScalar = {
    post_id?: boolean
    title?: boolean
    content?: boolean
    published?: boolean
    author_id?: boolean
  }

  export type postOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"post_id" | "title" | "content" | "published" | "author_id", ExtArgs["result"]["post"]>
  export type postInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | post$authorArgs<ExtArgs>
  }
  export type postIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | post$authorArgs<ExtArgs>
  }
  export type postIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | post$authorArgs<ExtArgs>
  }

  export type $postPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post"
    objects: {
      author: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      post_id: number
      title: string
      content: string | null
      published: boolean
      author_id: number | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type postGetPayload<S extends boolean | null | undefined | postDefaultArgs> = $Result.GetResult<Prisma.$postPayload, S>

  type postCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<postFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface postDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post'], meta: { name: 'post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {postFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends postFindUniqueArgs>(args: SelectSubset<T, postFindUniqueArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {postFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends postFindUniqueOrThrowArgs>(args: SelectSubset<T, postFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends postFindFirstArgs>(args?: SelectSubset<T, postFindFirstArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends postFindFirstOrThrowArgs>(args?: SelectSubset<T, postFindFirstOrThrowArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `post_id`
     * const postWithPost_idOnly = await prisma.post.findMany({ select: { post_id: true } })
     * 
     */
    findMany<T extends postFindManyArgs>(args?: SelectSubset<T, postFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {postCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends postCreateArgs>(args: SelectSubset<T, postCreateArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {postCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends postCreateManyArgs>(args?: SelectSubset<T, postCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {postCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `post_id`
     * const postWithPost_idOnly = await prisma.post.createManyAndReturn({
     *   select: { post_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends postCreateManyAndReturnArgs>(args?: SelectSubset<T, postCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {postDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends postDeleteArgs>(args: SelectSubset<T, postDeleteArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {postUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends postUpdateArgs>(args: SelectSubset<T, postUpdateArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {postDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends postDeleteManyArgs>(args?: SelectSubset<T, postDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends postUpdateManyArgs>(args: SelectSubset<T, postUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {postUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `post_id`
     * const postWithPost_idOnly = await prisma.post.updateManyAndReturn({
     *   select: { post_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends postUpdateManyAndReturnArgs>(args: SelectSubset<T, postUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {postUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends postUpsertArgs>(args: SelectSubset<T, postUpsertArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postCountArgs>(
      args?: Subset<T, postCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends postGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: postGroupByArgs['orderBy'] }
        : { orderBy?: postGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, postGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post model
   */
  readonly fields: postFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__postClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends post$authorArgs<ExtArgs> = {}>(args?: Subset<T, post$authorArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post model
   */
  interface postFieldRefs {
    readonly post_id: FieldRef<"post", 'Int'>
    readonly title: FieldRef<"post", 'String'>
    readonly content: FieldRef<"post", 'String'>
    readonly published: FieldRef<"post", 'Boolean'>
    readonly author_id: FieldRef<"post", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * post findUnique
   */
  export type postFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where: postWhereUniqueInput
  }

  /**
   * post findUniqueOrThrow
   */
  export type postFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where: postWhereUniqueInput
  }

  /**
   * post findFirst
   */
  export type postFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post findFirstOrThrow
   */
  export type postFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post findMany
   */
  export type postFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post create
   */
  export type postCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The data needed to create a post.
     */
    data: XOR<postCreateInput, postUncheckedCreateInput>
  }

  /**
   * post createMany
   */
  export type postCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many posts.
     */
    data: postCreateManyInput | postCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post createManyAndReturn
   */
  export type postCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * The data used to create many posts.
     */
    data: postCreateManyInput | postCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * post update
   */
  export type postUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The data needed to update a post.
     */
    data: XOR<postUpdateInput, postUncheckedUpdateInput>
    /**
     * Choose, which post to update.
     */
    where: postWhereUniqueInput
  }

  /**
   * post updateMany
   */
  export type postUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update posts.
     */
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
  }

  /**
   * post updateManyAndReturn
   */
  export type postUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * The data used to update posts.
     */
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * post upsert
   */
  export type postUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The filter to search for the post to update in case it exists.
     */
    where: postWhereUniqueInput
    /**
     * In case the post found by the `where` argument doesn't exist, create a new post with this data.
     */
    create: XOR<postCreateInput, postUncheckedCreateInput>
    /**
     * In case the post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<postUpdateInput, postUncheckedUpdateInput>
  }

  /**
   * post delete
   */
  export type postDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter which post to delete.
     */
    where: postWhereUniqueInput
  }

  /**
   * post deleteMany
   */
  export type postDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to delete
     */
    where?: postWhereInput
    /**
     * Limit how many posts to delete.
     */
    limit?: number
  }

  /**
   * post.author
   */
  export type post$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * post without action
   */
  export type postDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    user_id: number | null
  }

  export type UserSumAggregateOutputType = {
    user_id: number | null
  }

  export type UserMinAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    role: $Enums.UserRole | null
    payment_info: string | null
    invite_code: string | null
    signup_complete: boolean | null
    created_at: Date | null
    updated_at: Date | null
    city: string | null
    state: string | null
    country: string | null
    timezone: string | null
  }

  export type UserMaxAggregateOutputType = {
    user_id: number | null
    name: string | null
    email: string | null
    role: $Enums.UserRole | null
    payment_info: string | null
    invite_code: string | null
    signup_complete: boolean | null
    created_at: Date | null
    updated_at: Date | null
    city: string | null
    state: string | null
    country: string | null
    timezone: string | null
  }

  export type UserCountAggregateOutputType = {
    user_id: number
    name: number
    email: number
    role: number
    payment_info: number
    invite_code: number
    signup_complete: number
    created_at: number
    updated_at: number
    city: number
    state: number
    country: number
    timezone: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    user_id?: true
  }

  export type UserSumAggregateInputType = {
    user_id?: true
  }

  export type UserMinAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    role?: true
    payment_info?: true
    invite_code?: true
    signup_complete?: true
    created_at?: true
    updated_at?: true
    city?: true
    state?: true
    country?: true
    timezone?: true
  }

  export type UserMaxAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    role?: true
    payment_info?: true
    invite_code?: true
    signup_complete?: true
    created_at?: true
    updated_at?: true
    city?: true
    state?: true
    country?: true
    timezone?: true
  }

  export type UserCountAggregateInputType = {
    user_id?: true
    name?: true
    email?: true
    role?: true
    payment_info?: true
    invite_code?: true
    signup_complete?: true
    created_at?: true
    updated_at?: true
    city?: true
    state?: true
    country?: true
    timezone?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    user_id: number
    name: string | null
    email: string
    role: $Enums.UserRole
    payment_info: string | null
    invite_code: string | null
    signup_complete: boolean | null
    created_at: Date | null
    updated_at: Date | null
    city: string | null
    state: string | null
    country: string | null
    timezone: string | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    payment_info?: boolean
    invite_code?: boolean
    signup_complete?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    timezone?: boolean
    admin?: boolean | user$adminArgs<ExtArgs>
    user_organization?: boolean | user$user_organizationArgs<ExtArgs>
    student?: boolean | user$studentArgs<ExtArgs>
    teacher?: boolean | user$teacherArgs<ExtArgs>
    post?: boolean | user$postArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    payment_info?: boolean
    invite_code?: boolean
    signup_complete?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    timezone?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    payment_info?: boolean
    invite_code?: boolean
    signup_complete?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    timezone?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    user_id?: boolean
    name?: boolean
    email?: boolean
    role?: boolean
    payment_info?: boolean
    invite_code?: boolean
    signup_complete?: boolean
    created_at?: boolean
    updated_at?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    timezone?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "name" | "email" | "role" | "payment_info" | "invite_code" | "signup_complete" | "created_at" | "updated_at" | "city" | "state" | "country" | "timezone", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | user$adminArgs<ExtArgs>
    user_organization?: boolean | user$user_organizationArgs<ExtArgs>
    student?: boolean | user$studentArgs<ExtArgs>
    teacher?: boolean | user$teacherArgs<ExtArgs>
    post?: boolean | user$postArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      admin: Prisma.$adminPayload<ExtArgs> | null
      user_organization: Prisma.$user_organizationPayload<ExtArgs>[]
      student: Prisma.$studentPayload<ExtArgs> | null
      teacher: Prisma.$teacherPayload<ExtArgs> | null
      post: Prisma.$postPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      name: string | null
      email: string
      role: $Enums.UserRole
      payment_info: string | null
      invite_code: string | null
      signup_complete: boolean | null
      created_at: Date | null
      updated_at: Date | null
      city: string | null
      state: string | null
      country: string | null
      timezone: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const userWithUser_idOnly = await prisma.user.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `user_id`
     * const userWithUser_idOnly = await prisma.user.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends user$adminArgs<ExtArgs> = {}>(args?: Subset<T, user$adminArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_organization<T extends user$user_organizationArgs<ExtArgs> = {}>(args?: Subset<T, user$user_organizationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student<T extends user$studentArgs<ExtArgs> = {}>(args?: Subset<T, user$studentArgs<ExtArgs>>): Prisma__studentClient<$Result.GetResult<Prisma.$studentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends user$teacherArgs<ExtArgs> = {}>(args?: Subset<T, user$teacherArgs<ExtArgs>>): Prisma__teacherClient<$Result.GetResult<Prisma.$teacherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post<T extends user$postArgs<ExtArgs> = {}>(args?: Subset<T, user$postArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly user_id: FieldRef<"user", 'Int'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'UserRole'>
    readonly payment_info: FieldRef<"user", 'String'>
    readonly invite_code: FieldRef<"user", 'String'>
    readonly signup_complete: FieldRef<"user", 'Boolean'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly city: FieldRef<"user", 'String'>
    readonly state: FieldRef<"user", 'String'>
    readonly country: FieldRef<"user", 'String'>
    readonly timezone: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.admin
   */
  export type user$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    where?: adminWhereInput
  }

  /**
   * user.user_organization
   */
  export type user$user_organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    where?: user_organizationWhereInput
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    cursor?: user_organizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_organizationScalarFieldEnum | User_organizationScalarFieldEnum[]
  }

  /**
   * user.student
   */
  export type user$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student
     */
    select?: studentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student
     */
    omit?: studentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentInclude<ExtArgs> | null
    where?: studentWhereInput
  }

  /**
   * user.teacher
   */
  export type user$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher
     */
    select?: teacherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher
     */
    omit?: teacherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacherInclude<ExtArgs> | null
    where?: teacherWhereInput
  }

  /**
   * user.post
   */
  export type user$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    where?: postWhereInput
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    cursor?: postWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminSumAggregateOutputType = {
    admin_id: number | null
    user_id: number | null
  }

  export type AdminMinAggregateOutputType = {
    admin_id: number | null
    is_active: boolean | null
    user_id: number | null
  }

  export type AdminMaxAggregateOutputType = {
    admin_id: number | null
    is_active: boolean | null
    user_id: number | null
  }

  export type AdminCountAggregateOutputType = {
    admin_id: number
    is_active: number
    user_id: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminSumAggregateInputType = {
    admin_id?: true
    user_id?: true
  }

  export type AdminMinAggregateInputType = {
    admin_id?: true
    is_active?: true
    user_id?: true
  }

  export type AdminMaxAggregateInputType = {
    admin_id?: true
    is_active?: true
    user_id?: true
  }

  export type AdminCountAggregateInputType = {
    admin_id?: true
    is_active?: true
    user_id?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin to aggregate.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type adminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: adminWhereInput
    orderBy?: adminOrderByWithAggregationInput | adminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: adminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    admin_id: number
    is_active: boolean | null
    user_id: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends adminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type adminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    is_active?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    is_active?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    admin_id?: boolean
    is_active?: boolean
    user_id?: boolean
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type adminSelectScalar = {
    admin_id?: boolean
    is_active?: boolean
    user_id?: boolean
  }

  export type adminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"admin_id" | "is_active" | "user_id", ExtArgs["result"]["admin"]>
  export type adminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type adminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type adminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $adminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin"
    objects: {
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      admin_id: number
      is_active: boolean | null
      user_id: number
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type adminGetPayload<S extends boolean | null | undefined | adminDefaultArgs> = $Result.GetResult<Prisma.$adminPayload, S>

  type adminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<adminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface adminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin'], meta: { name: 'admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {adminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends adminFindUniqueArgs>(args: SelectSubset<T, adminFindUniqueArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {adminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends adminFindUniqueOrThrowArgs>(args: SelectSubset<T, adminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends adminFindFirstArgs>(args?: SelectSubset<T, adminFindFirstArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends adminFindFirstOrThrowArgs>(args?: SelectSubset<T, adminFindFirstOrThrowArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.findMany({ select: { admin_id: true } })
     * 
     */
    findMany<T extends adminFindManyArgs>(args?: SelectSubset<T, adminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {adminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends adminCreateArgs>(args: SelectSubset<T, adminCreateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {adminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends adminCreateManyArgs>(args?: SelectSubset<T, adminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {adminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.createManyAndReturn({
     *   select: { admin_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends adminCreateManyAndReturnArgs>(args?: SelectSubset<T, adminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {adminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends adminDeleteArgs>(args: SelectSubset<T, adminDeleteArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {adminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends adminUpdateArgs>(args: SelectSubset<T, adminUpdateArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {adminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends adminDeleteManyArgs>(args?: SelectSubset<T, adminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends adminUpdateManyArgs>(args: SelectSubset<T, adminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {adminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `admin_id`
     * const adminWithAdmin_idOnly = await prisma.admin.updateManyAndReturn({
     *   select: { admin_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends adminUpdateManyAndReturnArgs>(args: SelectSubset<T, adminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {adminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends adminUpsertArgs>(args: SelectSubset<T, adminUpsertArgs<ExtArgs>>): Prisma__adminClient<$Result.GetResult<Prisma.$adminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends adminCountArgs>(
      args?: Subset<T, adminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {adminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends adminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: adminGroupByArgs['orderBy'] }
        : { orderBy?: adminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, adminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin model
   */
  readonly fields: adminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__adminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin model
   */
  interface adminFieldRefs {
    readonly admin_id: FieldRef<"admin", 'Int'>
    readonly is_active: FieldRef<"admin", 'Boolean'>
    readonly user_id: FieldRef<"admin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * admin findUnique
   */
  export type adminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findUniqueOrThrow
   */
  export type adminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin findFirst
   */
  export type adminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findFirstOrThrow
   */
  export type adminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admin to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin findMany
   */
  export type adminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter, which admins to fetch.
     */
    where?: adminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admins to fetch.
     */
    orderBy?: adminOrderByWithRelationInput | adminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admins.
     */
    cursor?: adminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * admin create
   */
  export type adminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to create a admin.
     */
    data: XOR<adminCreateInput, adminUncheckedCreateInput>
  }

  /**
   * admin createMany
   */
  export type adminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin createManyAndReturn
   */
  export type adminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to create many admins.
     */
    data: adminCreateManyInput | adminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin update
   */
  export type adminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The data needed to update a admin.
     */
    data: XOR<adminUpdateInput, adminUncheckedUpdateInput>
    /**
     * Choose, which admin to update.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin updateMany
   */
  export type adminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
  }

  /**
   * admin updateManyAndReturn
   */
  export type adminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * The data used to update admins.
     */
    data: XOR<adminUpdateManyMutationInput, adminUncheckedUpdateManyInput>
    /**
     * Filter which admins to update
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin upsert
   */
  export type adminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * The filter to search for the admin to update in case it exists.
     */
    where: adminWhereUniqueInput
    /**
     * In case the admin found by the `where` argument doesn't exist, create a new admin with this data.
     */
    create: XOR<adminCreateInput, adminUncheckedCreateInput>
    /**
     * In case the admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<adminUpdateInput, adminUncheckedUpdateInput>
  }

  /**
   * admin delete
   */
  export type adminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
    /**
     * Filter which admin to delete.
     */
    where: adminWhereUniqueInput
  }

  /**
   * admin deleteMany
   */
  export type adminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admins to delete
     */
    where?: adminWhereInput
    /**
     * Limit how many admins to delete.
     */
    limit?: number
  }

  /**
   * admin without action
   */
  export type adminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin
     */
    select?: adminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin
     */
    omit?: adminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: adminInclude<ExtArgs> | null
  }


  /**
   * Model organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    organization_id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    organization_id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    organization_id: number | null
    name: string | null
    description: string | null
    website: string | null
    old_id: string | null
  }

  export type OrganizationMaxAggregateOutputType = {
    organization_id: number | null
    name: string | null
    description: string | null
    website: string | null
    old_id: string | null
  }

  export type OrganizationCountAggregateOutputType = {
    organization_id: number
    name: number
    description: number
    website: number
    old_id: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    organization_id?: true
  }

  export type OrganizationSumAggregateInputType = {
    organization_id?: true
  }

  export type OrganizationMinAggregateInputType = {
    organization_id?: true
    name?: true
    description?: true
    website?: true
    old_id?: true
  }

  export type OrganizationMaxAggregateInputType = {
    organization_id?: true
    name?: true
    description?: true
    website?: true
    old_id?: true
  }

  export type OrganizationCountAggregateInputType = {
    organization_id?: true
    name?: true
    description?: true
    website?: true
    old_id?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organization to aggregate.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type organizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: organizationWhereInput
    orderBy?: organizationOrderByWithAggregationInput | organizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: organizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    organization_id: number
    name: string | null
    description: string | null
    website: string | null
    old_id: string | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends organizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type organizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    old_id?: boolean
    scholarship?: boolean | organization$scholarshipArgs<ExtArgs>
    user_organization?: boolean | organization$user_organizationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type organizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    old_id?: boolean
  }, ExtArgs["result"]["organization"]>

  export type organizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    organization_id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    old_id?: boolean
  }, ExtArgs["result"]["organization"]>

  export type organizationSelectScalar = {
    organization_id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    old_id?: boolean
  }

  export type organizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"organization_id" | "name" | "description" | "website" | "old_id", ExtArgs["result"]["organization"]>
  export type organizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scholarship?: boolean | organization$scholarshipArgs<ExtArgs>
    user_organization?: boolean | organization$user_organizationArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type organizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type organizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $organizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "organization"
    objects: {
      scholarship: Prisma.$scholarshipPayload<ExtArgs>[]
      user_organization: Prisma.$user_organizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      organization_id: number
      name: string | null
      description: string | null
      website: string | null
      old_id: string | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type organizationGetPayload<S extends boolean | null | undefined | organizationDefaultArgs> = $Result.GetResult<Prisma.$organizationPayload, S>

  type organizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<organizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface organizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['organization'], meta: { name: 'organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {organizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends organizationFindUniqueArgs>(args: SelectSubset<T, organizationFindUniqueArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {organizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends organizationFindUniqueOrThrowArgs>(args: SelectSubset<T, organizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends organizationFindFirstArgs>(args?: SelectSubset<T, organizationFindFirstArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends organizationFindFirstOrThrowArgs>(args?: SelectSubset<T, organizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `organization_id`
     * const organizationWithOrganization_idOnly = await prisma.organization.findMany({ select: { organization_id: true } })
     * 
     */
    findMany<T extends organizationFindManyArgs>(args?: SelectSubset<T, organizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {organizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends organizationCreateArgs>(args: SelectSubset<T, organizationCreateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {organizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends organizationCreateManyArgs>(args?: SelectSubset<T, organizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {organizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `organization_id`
     * const organizationWithOrganization_idOnly = await prisma.organization.createManyAndReturn({
     *   select: { organization_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends organizationCreateManyAndReturnArgs>(args?: SelectSubset<T, organizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {organizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends organizationDeleteArgs>(args: SelectSubset<T, organizationDeleteArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {organizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends organizationUpdateArgs>(args: SelectSubset<T, organizationUpdateArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {organizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends organizationDeleteManyArgs>(args?: SelectSubset<T, organizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends organizationUpdateManyArgs>(args: SelectSubset<T, organizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {organizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `organization_id`
     * const organizationWithOrganization_idOnly = await prisma.organization.updateManyAndReturn({
     *   select: { organization_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends organizationUpdateManyAndReturnArgs>(args: SelectSubset<T, organizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {organizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends organizationUpsertArgs>(args: SelectSubset<T, organizationUpsertArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends organizationCountArgs>(
      args?: Subset<T, organizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends organizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: organizationGroupByArgs['orderBy'] }
        : { orderBy?: organizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, organizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the organization model
   */
  readonly fields: organizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__organizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scholarship<T extends organization$scholarshipArgs<ExtArgs> = {}>(args?: Subset<T, organization$scholarshipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$scholarshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_organization<T extends organization$user_organizationArgs<ExtArgs> = {}>(args?: Subset<T, organization$user_organizationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the organization model
   */
  interface organizationFieldRefs {
    readonly organization_id: FieldRef<"organization", 'Int'>
    readonly name: FieldRef<"organization", 'String'>
    readonly description: FieldRef<"organization", 'String'>
    readonly website: FieldRef<"organization", 'String'>
    readonly old_id: FieldRef<"organization", 'String'>
  }
    

  // Custom InputTypes
  /**
   * organization findUnique
   */
  export type organizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findUniqueOrThrow
   */
  export type organizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization findFirst
   */
  export type organizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findFirstOrThrow
   */
  export type organizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organization to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization findMany
   */
  export type organizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter, which organizations to fetch.
     */
    where?: organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organizations to fetch.
     */
    orderBy?: organizationOrderByWithRelationInput | organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organizations.
     */
    cursor?: organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * organization create
   */
  export type organizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The data needed to create a organization.
     */
    data?: XOR<organizationCreateInput, organizationUncheckedCreateInput>
  }

  /**
   * organization createMany
   */
  export type organizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many organizations.
     */
    data: organizationCreateManyInput | organizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organization createManyAndReturn
   */
  export type organizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * The data used to create many organizations.
     */
    data: organizationCreateManyInput | organizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * organization update
   */
  export type organizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The data needed to update a organization.
     */
    data: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
    /**
     * Choose, which organization to update.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization updateMany
   */
  export type organizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationUpdateManyMutationInput, organizationUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organization updateManyAndReturn
   */
  export type organizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * The data used to update organizations.
     */
    data: XOR<organizationUpdateManyMutationInput, organizationUncheckedUpdateManyInput>
    /**
     * Filter which organizations to update
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to update.
     */
    limit?: number
  }

  /**
   * organization upsert
   */
  export type organizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * The filter to search for the organization to update in case it exists.
     */
    where: organizationWhereUniqueInput
    /**
     * In case the organization found by the `where` argument doesn't exist, create a new organization with this data.
     */
    create: XOR<organizationCreateInput, organizationUncheckedCreateInput>
    /**
     * In case the organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<organizationUpdateInput, organizationUncheckedUpdateInput>
  }

  /**
   * organization delete
   */
  export type organizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
    /**
     * Filter which organization to delete.
     */
    where: organizationWhereUniqueInput
  }

  /**
   * organization deleteMany
   */
  export type organizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which organizations to delete
     */
    where?: organizationWhereInput
    /**
     * Limit how many organizations to delete.
     */
    limit?: number
  }

  /**
   * organization.scholarship
   */
  export type organization$scholarshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the scholarship
     */
    select?: scholarshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the scholarship
     */
    omit?: scholarshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: scholarshipInclude<ExtArgs> | null
    where?: scholarshipWhereInput
    orderBy?: scholarshipOrderByWithRelationInput | scholarshipOrderByWithRelationInput[]
    cursor?: scholarshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScholarshipScalarFieldEnum | ScholarshipScalarFieldEnum[]
  }

  /**
   * organization.user_organization
   */
  export type organization$user_organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    where?: user_organizationWhereInput
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    cursor?: user_organizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_organizationScalarFieldEnum | User_organizationScalarFieldEnum[]
  }

  /**
   * organization without action
   */
  export type organizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the organization
     */
    select?: organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the organization
     */
    omit?: organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: organizationInclude<ExtArgs> | null
  }


  /**
   * Model user_organization
   */

  export type AggregateUser_organization = {
    _count: User_organizationCountAggregateOutputType | null
    _avg: User_organizationAvgAggregateOutputType | null
    _sum: User_organizationSumAggregateOutputType | null
    _min: User_organizationMinAggregateOutputType | null
    _max: User_organizationMaxAggregateOutputType | null
  }

  export type User_organizationAvgAggregateOutputType = {
    user_organization_id: number | null
    user_id: number | null
    organization_id: number | null
  }

  export type User_organizationSumAggregateOutputType = {
    user_organization_id: number | null
    user_id: number | null
    organization_id: number | null
  }

  export type User_organizationMinAggregateOutputType = {
    user_organization_id: number | null
    user_id: number | null
    organization_id: number | null
  }

  export type User_organizationMaxAggregateOutputType = {
    user_organization_id: number | null
    user_id: number | null
    organization_id: number | null
  }

  export type User_organizationCountAggregateOutputType = {
    user_organization_id: number
    user_id: number
    organization_id: number
    _all: number
  }


  export type User_organizationAvgAggregateInputType = {
    user_organization_id?: true
    user_id?: true
    organization_id?: true
  }

  export type User_organizationSumAggregateInputType = {
    user_organization_id?: true
    user_id?: true
    organization_id?: true
  }

  export type User_organizationMinAggregateInputType = {
    user_organization_id?: true
    user_id?: true
    organization_id?: true
  }

  export type User_organizationMaxAggregateInputType = {
    user_organization_id?: true
    user_id?: true
    organization_id?: true
  }

  export type User_organizationCountAggregateInputType = {
    user_organization_id?: true
    user_id?: true
    organization_id?: true
    _all?: true
  }

  export type User_organizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_organization to aggregate.
     */
    where?: user_organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_organizations to fetch.
     */
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_organizations
    **/
    _count?: true | User_organizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_organizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_organizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_organizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_organizationMaxAggregateInputType
  }

  export type GetUser_organizationAggregateType<T extends User_organizationAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_organization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_organization[P]>
      : GetScalarType<T[P], AggregateUser_organization[P]>
  }




  export type user_organizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_organizationWhereInput
    orderBy?: user_organizationOrderByWithAggregationInput | user_organizationOrderByWithAggregationInput[]
    by: User_organizationScalarFieldEnum[] | User_organizationScalarFieldEnum
    having?: user_organizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_organizationCountAggregateInputType | true
    _avg?: User_organizationAvgAggregateInputType
    _sum?: User_organizationSumAggregateInputType
    _min?: User_organizationMinAggregateInputType
    _max?: User_organizationMaxAggregateInputType
  }

  export type User_organizationGroupByOutputType = {
    user_organization_id: number
    user_id: number
    organization_id: number
    _count: User_organizationCountAggregateOutputType | null
    _avg: User_organizationAvgAggregateOutputType | null
    _sum: User_organizationSumAggregateOutputType | null
    _min: User_organizationMinAggregateOutputType | null
    _max: User_organizationMaxAggregateOutputType | null
  }

  type GetUser_organizationGroupByPayload<T extends user_organizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_organizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_organizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_organizationGroupByOutputType[P]>
            : GetScalarType<T[P], User_organizationGroupByOutputType[P]>
        }
      >
    >


  export type user_organizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_organization_id?: boolean
    user_id?: boolean
    organization_id?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_organization"]>

  export type user_organizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_organization_id?: boolean
    user_id?: boolean
    organization_id?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_organization"]>

  export type user_organizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_organization_id?: boolean
    user_id?: boolean
    organization_id?: boolean
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_organization"]>

  export type user_organizationSelectScalar = {
    user_organization_id?: boolean
    user_id?: boolean
    organization_id?: boolean
  }

  export type user_organizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_organization_id" | "user_id" | "organization_id", ExtArgs["result"]["user_organization"]>
  export type user_organizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type user_organizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type user_organizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | organizationDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $user_organizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_organization"
    objects: {
      organization: Prisma.$organizationPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_organization_id: number
      user_id: number
      organization_id: number
    }, ExtArgs["result"]["user_organization"]>
    composites: {}
  }

  type user_organizationGetPayload<S extends boolean | null | undefined | user_organizationDefaultArgs> = $Result.GetResult<Prisma.$user_organizationPayload, S>

  type user_organizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_organizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_organizationCountAggregateInputType | true
    }

  export interface user_organizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_organization'], meta: { name: 'user_organization' } }
    /**
     * Find zero or one User_organization that matches the filter.
     * @param {user_organizationFindUniqueArgs} args - Arguments to find a User_organization
     * @example
     * // Get one User_organization
     * const user_organization = await prisma.user_organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_organizationFindUniqueArgs>(args: SelectSubset<T, user_organizationFindUniqueArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_organizationFindUniqueOrThrowArgs} args - Arguments to find a User_organization
     * @example
     * // Get one User_organization
     * const user_organization = await prisma.user_organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_organizationFindUniqueOrThrowArgs>(args: SelectSubset<T, user_organizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationFindFirstArgs} args - Arguments to find a User_organization
     * @example
     * // Get one User_organization
     * const user_organization = await prisma.user_organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_organizationFindFirstArgs>(args?: SelectSubset<T, user_organizationFindFirstArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationFindFirstOrThrowArgs} args - Arguments to find a User_organization
     * @example
     * // Get one User_organization
     * const user_organization = await prisma.user_organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_organizationFindFirstOrThrowArgs>(args?: SelectSubset<T, user_organizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_organizations
     * const user_organizations = await prisma.user_organization.findMany()
     * 
     * // Get first 10 User_organizations
     * const user_organizations = await prisma.user_organization.findMany({ take: 10 })
     * 
     * // Only select the `user_organization_id`
     * const user_organizationWithUser_organization_idOnly = await prisma.user_organization.findMany({ select: { user_organization_id: true } })
     * 
     */
    findMany<T extends user_organizationFindManyArgs>(args?: SelectSubset<T, user_organizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_organization.
     * @param {user_organizationCreateArgs} args - Arguments to create a User_organization.
     * @example
     * // Create one User_organization
     * const User_organization = await prisma.user_organization.create({
     *   data: {
     *     // ... data to create a User_organization
     *   }
     * })
     * 
     */
    create<T extends user_organizationCreateArgs>(args: SelectSubset<T, user_organizationCreateArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_organizations.
     * @param {user_organizationCreateManyArgs} args - Arguments to create many User_organizations.
     * @example
     * // Create many User_organizations
     * const user_organization = await prisma.user_organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_organizationCreateManyArgs>(args?: SelectSubset<T, user_organizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_organizations and returns the data saved in the database.
     * @param {user_organizationCreateManyAndReturnArgs} args - Arguments to create many User_organizations.
     * @example
     * // Create many User_organizations
     * const user_organization = await prisma.user_organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_organizations and only return the `user_organization_id`
     * const user_organizationWithUser_organization_idOnly = await prisma.user_organization.createManyAndReturn({
     *   select: { user_organization_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_organizationCreateManyAndReturnArgs>(args?: SelectSubset<T, user_organizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_organization.
     * @param {user_organizationDeleteArgs} args - Arguments to delete one User_organization.
     * @example
     * // Delete one User_organization
     * const User_organization = await prisma.user_organization.delete({
     *   where: {
     *     // ... filter to delete one User_organization
     *   }
     * })
     * 
     */
    delete<T extends user_organizationDeleteArgs>(args: SelectSubset<T, user_organizationDeleteArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_organization.
     * @param {user_organizationUpdateArgs} args - Arguments to update one User_organization.
     * @example
     * // Update one User_organization
     * const user_organization = await prisma.user_organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_organizationUpdateArgs>(args: SelectSubset<T, user_organizationUpdateArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_organizations.
     * @param {user_organizationDeleteManyArgs} args - Arguments to filter User_organizations to delete.
     * @example
     * // Delete a few User_organizations
     * const { count } = await prisma.user_organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_organizationDeleteManyArgs>(args?: SelectSubset<T, user_organizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_organizations
     * const user_organization = await prisma.user_organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_organizationUpdateManyArgs>(args: SelectSubset<T, user_organizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_organizations and returns the data updated in the database.
     * @param {user_organizationUpdateManyAndReturnArgs} args - Arguments to update many User_organizations.
     * @example
     * // Update many User_organizations
     * const user_organization = await prisma.user_organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_organizations and only return the `user_organization_id`
     * const user_organizationWithUser_organization_idOnly = await prisma.user_organization.updateManyAndReturn({
     *   select: { user_organization_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_organizationUpdateManyAndReturnArgs>(args: SelectSubset<T, user_organizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_organization.
     * @param {user_organizationUpsertArgs} args - Arguments to update or create a User_organization.
     * @example
     * // Update or create a User_organization
     * const user_organization = await prisma.user_organization.upsert({
     *   create: {
     *     // ... data to create a User_organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_organization we want to update
     *   }
     * })
     */
    upsert<T extends user_organizationUpsertArgs>(args: SelectSubset<T, user_organizationUpsertArgs<ExtArgs>>): Prisma__user_organizationClient<$Result.GetResult<Prisma.$user_organizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationCountArgs} args - Arguments to filter User_organizations to count.
     * @example
     * // Count the number of User_organizations
     * const count = await prisma.user_organization.count({
     *   where: {
     *     // ... the filter for the User_organizations we want to count
     *   }
     * })
    **/
    count<T extends user_organizationCountArgs>(
      args?: Subset<T, user_organizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_organizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_organizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_organizationAggregateArgs>(args: Subset<T, User_organizationAggregateArgs>): Prisma.PrismaPromise<GetUser_organizationAggregateType<T>>

    /**
     * Group by User_organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_organizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_organizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_organizationGroupByArgs['orderBy'] }
        : { orderBy?: user_organizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_organizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_organizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_organization model
   */
  readonly fields: user_organizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_organizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends organizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, organizationDefaultArgs<ExtArgs>>): Prisma__organizationClient<$Result.GetResult<Prisma.$organizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_organization model
   */
  interface user_organizationFieldRefs {
    readonly user_organization_id: FieldRef<"user_organization", 'Int'>
    readonly user_id: FieldRef<"user_organization", 'Int'>
    readonly organization_id: FieldRef<"user_organization", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_organization findUnique
   */
  export type user_organizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter, which user_organization to fetch.
     */
    where: user_organizationWhereUniqueInput
  }

  /**
   * user_organization findUniqueOrThrow
   */
  export type user_organizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter, which user_organization to fetch.
     */
    where: user_organizationWhereUniqueInput
  }

  /**
   * user_organization findFirst
   */
  export type user_organizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter, which user_organization to fetch.
     */
    where?: user_organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_organizations to fetch.
     */
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_organizations.
     */
    cursor?: user_organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_organizations.
     */
    distinct?: User_organizationScalarFieldEnum | User_organizationScalarFieldEnum[]
  }

  /**
   * user_organization findFirstOrThrow
   */
  export type user_organizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter, which user_organization to fetch.
     */
    where?: user_organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_organizations to fetch.
     */
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_organizations.
     */
    cursor?: user_organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_organizations.
     */
    distinct?: User_organizationScalarFieldEnum | User_organizationScalarFieldEnum[]
  }

  /**
   * user_organization findMany
   */
  export type user_organizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter, which user_organizations to fetch.
     */
    where?: user_organizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_organizations to fetch.
     */
    orderBy?: user_organizationOrderByWithRelationInput | user_organizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_organizations.
     */
    cursor?: user_organizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_organizations.
     */
    skip?: number
    distinct?: User_organizationScalarFieldEnum | User_organizationScalarFieldEnum[]
  }

  /**
   * user_organization create
   */
  export type user_organizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * The data needed to create a user_organization.
     */
    data: XOR<user_organizationCreateInput, user_organizationUncheckedCreateInput>
  }

  /**
   * user_organization createMany
   */
  export type user_organizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_organizations.
     */
    data: user_organizationCreateManyInput | user_organizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_organization createManyAndReturn
   */
  export type user_organizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * The data used to create many user_organizations.
     */
    data: user_organizationCreateManyInput | user_organizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_organization update
   */
  export type user_organizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * The data needed to update a user_organization.
     */
    data: XOR<user_organizationUpdateInput, user_organizationUncheckedUpdateInput>
    /**
     * Choose, which user_organization to update.
     */
    where: user_organizationWhereUniqueInput
  }

  /**
   * user_organization updateMany
   */
  export type user_organizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_organizations.
     */
    data: XOR<user_organizationUpdateManyMutationInput, user_organizationUncheckedUpdateManyInput>
    /**
     * Filter which user_organizations to update
     */
    where?: user_organizationWhereInput
    /**
     * Limit how many user_organizations to update.
     */
    limit?: number
  }

  /**
   * user_organization updateManyAndReturn
   */
  export type user_organizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * The data used to update user_organizations.
     */
    data: XOR<user_organizationUpdateManyMutationInput, user_organizationUncheckedUpdateManyInput>
    /**
     * Filter which user_organizations to update
     */
    where?: user_organizationWhereInput
    /**
     * Limit how many user_organizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_organization upsert
   */
  export type user_organizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * The filter to search for the user_organization to update in case it exists.
     */
    where: user_organizationWhereUniqueInput
    /**
     * In case the user_organization found by the `where` argument doesn't exist, create a new user_organization with this data.
     */
    create: XOR<user_organizationCreateInput, user_organizationUncheckedCreateInput>
    /**
     * In case the user_organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_organizationUpdateInput, user_organizationUncheckedUpdateInput>
  }

  /**
   * user_organization delete
   */
  export type user_organizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
    /**
     * Filter which user_organization to delete.
     */
    where: user_organizationWhereUniqueInput
  }

  /**
   * user_organization deleteMany
   */
  export type user_organizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_organizations to delete
     */
    where?: user_organizationWhereInput
    /**
     * Limit how many user_organizations to delete.
     */
    limit?: number
  }

  /**
   * user_organization without action
   */
  export type user_organizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_organization
     */
    select?: user_organizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_organization
     */
    omit?: user_organizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_organizationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssignmentScalarFieldEnum: {
    assignment_id: 'assignment_id',
    classroom_id: 'classroom_id',
    name: 'name',
    description: 'description',
    assignment_number: 'assignment_number',
    due_date: 'due_date',
    created_at: 'created_at'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const Assignment_submissionScalarFieldEnum: {
    assignment_submission_id: 'assignment_submission_id',
    assignment_id: 'assignment_id',
    student_id: 'student_id',
    s3_path: 's3_path',
    submitted_at: 'submitted_at'
  };

  export type Assignment_submissionScalarFieldEnum = (typeof Assignment_submissionScalarFieldEnum)[keyof typeof Assignment_submissionScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    question_id: 'question_id',
    assignment_id: 'assignment_id',
    question_number: 'question_number',
    name: 'name',
    prompt: 'prompt',
    example_solution_s3_path: 'example_solution_s3_path',
    accepted_file_types: 'accepted_file_types',
    created_at: 'created_at'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const Question_submissionScalarFieldEnum: {
    question_submission_id: 'question_submission_id',
    assignment_submission_id: 'assignment_submission_id',
    question_id: 'question_id',
    student_id: 'student_id',
    s3_path: 's3_path',
    created_at: 'created_at'
  };

  export type Question_submissionScalarFieldEnum = (typeof Question_submissionScalarFieldEnum)[keyof typeof Question_submissionScalarFieldEnum]


  export const ClassroomScalarFieldEnum: {
    classroom_id: 'classroom_id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ClassroomScalarFieldEnum = (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    student_id: 'student_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const Student_classroomScalarFieldEnum: {
    student_classroom_id: 'student_classroom_id',
    student_id: 'student_id',
    classroom_id: 'classroom_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Student_classroomScalarFieldEnum = (typeof Student_classroomScalarFieldEnum)[keyof typeof Student_classroomScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    teacher_id: 'teacher_id',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const Teacher_classroomScalarFieldEnum: {
    teacher_classrood_id: 'teacher_classrood_id',
    teacher_id: 'teacher_id',
    classroom_id: 'classroom_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Teacher_classroomScalarFieldEnum = (typeof Teacher_classroomScalarFieldEnum)[keyof typeof Teacher_classroomScalarFieldEnum]


  export const ScholarshipScalarFieldEnum: {
    scholarship_id: 'scholarship_id',
    name: 'name',
    organization_id: 'organization_id',
    award: 'award',
    description: 'description',
    category: 'category',
    eligibility: 'eligibility',
    region: 'region',
    deadline: 'deadline',
    fafsa: 'fafsa',
    gpa: 'gpa',
    created_at: 'created_at'
  };

  export type ScholarshipScalarFieldEnum = (typeof ScholarshipScalarFieldEnum)[keyof typeof ScholarshipScalarFieldEnum]


  export const Student_scholarshipScalarFieldEnum: {
    student_scholarship_id: 'student_scholarship_id',
    student_id: 'student_id',
    scholarship_id: 'scholarship_id',
    is_bookmarked: 'is_bookmarked'
  };

  export type Student_scholarshipScalarFieldEnum = (typeof Student_scholarshipScalarFieldEnum)[keyof typeof Student_scholarshipScalarFieldEnum]


  export const PostScalarFieldEnum: {
    post_id: 'post_id',
    title: 'title',
    content: 'content',
    published: 'published',
    author_id: 'author_id'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const UserScalarFieldEnum: {
    user_id: 'user_id',
    name: 'name',
    email: 'email',
    role: 'role',
    payment_info: 'payment_info',
    invite_code: 'invite_code',
    signup_complete: 'signup_complete',
    created_at: 'created_at',
    updated_at: 'updated_at',
    city: 'city',
    state: 'state',
    country: 'country',
    timezone: 'timezone'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    admin_id: 'admin_id',
    is_active: 'is_active',
    user_id: 'user_id'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    organization_id: 'organization_id',
    name: 'name',
    description: 'description',
    website: 'website',
    old_id: 'old_id'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const User_organizationScalarFieldEnum: {
    user_organization_id: 'user_organization_id',
    user_id: 'user_id',
    organization_id: 'organization_id'
  };

  export type User_organizationScalarFieldEnum = (typeof User_organizationScalarFieldEnum)[keyof typeof User_organizationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type assignmentWhereInput = {
    AND?: assignmentWhereInput | assignmentWhereInput[]
    OR?: assignmentWhereInput[]
    NOT?: assignmentWhereInput | assignmentWhereInput[]
    assignment_id?: IntFilter<"assignment"> | number
    classroom_id?: IntFilter<"assignment"> | number
    name?: StringFilter<"assignment"> | string
    description?: StringNullableFilter<"assignment"> | string | null
    assignment_number?: IntNullableFilter<"assignment"> | number | null
    due_date?: DateTimeFilter<"assignment"> | Date | string
    created_at?: DateTimeNullableFilter<"assignment"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
    assignment_submission?: Assignment_submissionListRelationFilter
    question?: QuestionListRelationFilter
  }

  export type assignmentOrderByWithRelationInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    assignment_number?: SortOrderInput | SortOrder
    due_date?: SortOrder
    created_at?: SortOrderInput | SortOrder
    classroom?: classroomOrderByWithRelationInput
    assignment_submission?: assignment_submissionOrderByRelationAggregateInput
    question?: questionOrderByRelationAggregateInput
  }

  export type assignmentWhereUniqueInput = Prisma.AtLeast<{
    assignment_id?: number
    AND?: assignmentWhereInput | assignmentWhereInput[]
    OR?: assignmentWhereInput[]
    NOT?: assignmentWhereInput | assignmentWhereInput[]
    classroom_id?: IntFilter<"assignment"> | number
    name?: StringFilter<"assignment"> | string
    description?: StringNullableFilter<"assignment"> | string | null
    assignment_number?: IntNullableFilter<"assignment"> | number | null
    due_date?: DateTimeFilter<"assignment"> | Date | string
    created_at?: DateTimeNullableFilter<"assignment"> | Date | string | null
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
    assignment_submission?: Assignment_submissionListRelationFilter
    question?: QuestionListRelationFilter
  }, "assignment_id">

  export type assignmentOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    assignment_number?: SortOrderInput | SortOrder
    due_date?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: assignmentCountOrderByAggregateInput
    _avg?: assignmentAvgOrderByAggregateInput
    _max?: assignmentMaxOrderByAggregateInput
    _min?: assignmentMinOrderByAggregateInput
    _sum?: assignmentSumOrderByAggregateInput
  }

  export type assignmentScalarWhereWithAggregatesInput = {
    AND?: assignmentScalarWhereWithAggregatesInput | assignmentScalarWhereWithAggregatesInput[]
    OR?: assignmentScalarWhereWithAggregatesInput[]
    NOT?: assignmentScalarWhereWithAggregatesInput | assignmentScalarWhereWithAggregatesInput[]
    assignment_id?: IntWithAggregatesFilter<"assignment"> | number
    classroom_id?: IntWithAggregatesFilter<"assignment"> | number
    name?: StringWithAggregatesFilter<"assignment"> | string
    description?: StringNullableWithAggregatesFilter<"assignment"> | string | null
    assignment_number?: IntNullableWithAggregatesFilter<"assignment"> | number | null
    due_date?: DateTimeWithAggregatesFilter<"assignment"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"assignment"> | Date | string | null
  }

  export type assignment_submissionWhereInput = {
    AND?: assignment_submissionWhereInput | assignment_submissionWhereInput[]
    OR?: assignment_submissionWhereInput[]
    NOT?: assignment_submissionWhereInput | assignment_submissionWhereInput[]
    assignment_submission_id?: IntFilter<"assignment_submission"> | number
    assignment_id?: IntFilter<"assignment_submission"> | number
    student_id?: IntFilter<"assignment_submission"> | number
    s3_path?: StringFilter<"assignment_submission"> | string
    submitted_at?: DateTimeNullableFilter<"assignment_submission"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, assignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    question_submission?: Question_submissionListRelationFilter
  }

  export type assignment_submissionOrderByWithRelationInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    assignment?: assignmentOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
    question_submission?: question_submissionOrderByRelationAggregateInput
  }

  export type assignment_submissionWhereUniqueInput = Prisma.AtLeast<{
    assignment_submission_id?: number
    AND?: assignment_submissionWhereInput | assignment_submissionWhereInput[]
    OR?: assignment_submissionWhereInput[]
    NOT?: assignment_submissionWhereInput | assignment_submissionWhereInput[]
    assignment_id?: IntFilter<"assignment_submission"> | number
    student_id?: IntFilter<"assignment_submission"> | number
    s3_path?: StringFilter<"assignment_submission"> | string
    submitted_at?: DateTimeNullableFilter<"assignment_submission"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, assignmentWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    question_submission?: Question_submissionListRelationFilter
  }, "assignment_submission_id">

  export type assignment_submissionOrderByWithAggregationInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    submitted_at?: SortOrderInput | SortOrder
    _count?: assignment_submissionCountOrderByAggregateInput
    _avg?: assignment_submissionAvgOrderByAggregateInput
    _max?: assignment_submissionMaxOrderByAggregateInput
    _min?: assignment_submissionMinOrderByAggregateInput
    _sum?: assignment_submissionSumOrderByAggregateInput
  }

  export type assignment_submissionScalarWhereWithAggregatesInput = {
    AND?: assignment_submissionScalarWhereWithAggregatesInput | assignment_submissionScalarWhereWithAggregatesInput[]
    OR?: assignment_submissionScalarWhereWithAggregatesInput[]
    NOT?: assignment_submissionScalarWhereWithAggregatesInput | assignment_submissionScalarWhereWithAggregatesInput[]
    assignment_submission_id?: IntWithAggregatesFilter<"assignment_submission"> | number
    assignment_id?: IntWithAggregatesFilter<"assignment_submission"> | number
    student_id?: IntWithAggregatesFilter<"assignment_submission"> | number
    s3_path?: StringWithAggregatesFilter<"assignment_submission"> | string
    submitted_at?: DateTimeNullableWithAggregatesFilter<"assignment_submission"> | Date | string | null
  }

  export type questionWhereInput = {
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    question_id?: IntFilter<"question"> | number
    assignment_id?: IntFilter<"question"> | number
    question_number?: IntNullableFilter<"question"> | number | null
    name?: StringNullableFilter<"question"> | string | null
    prompt?: StringNullableFilter<"question"> | string | null
    example_solution_s3_path?: StringNullableFilter<"question"> | string | null
    accepted_file_types?: StringNullableFilter<"question"> | string | null
    created_at?: DateTimeNullableFilter<"question"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, assignmentWhereInput>
    question_submission?: Question_submissionListRelationFilter
  }

  export type questionOrderByWithRelationInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    example_solution_s3_path?: SortOrderInput | SortOrder
    accepted_file_types?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    assignment?: assignmentOrderByWithRelationInput
    question_submission?: question_submissionOrderByRelationAggregateInput
  }

  export type questionWhereUniqueInput = Prisma.AtLeast<{
    question_id?: number
    AND?: questionWhereInput | questionWhereInput[]
    OR?: questionWhereInput[]
    NOT?: questionWhereInput | questionWhereInput[]
    assignment_id?: IntFilter<"question"> | number
    question_number?: IntNullableFilter<"question"> | number | null
    name?: StringNullableFilter<"question"> | string | null
    prompt?: StringNullableFilter<"question"> | string | null
    example_solution_s3_path?: StringNullableFilter<"question"> | string | null
    accepted_file_types?: StringNullableFilter<"question"> | string | null
    created_at?: DateTimeNullableFilter<"question"> | Date | string | null
    assignment?: XOR<AssignmentScalarRelationFilter, assignmentWhereInput>
    question_submission?: Question_submissionListRelationFilter
  }, "question_id">

  export type questionOrderByWithAggregationInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    example_solution_s3_path?: SortOrderInput | SortOrder
    accepted_file_types?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: questionCountOrderByAggregateInput
    _avg?: questionAvgOrderByAggregateInput
    _max?: questionMaxOrderByAggregateInput
    _min?: questionMinOrderByAggregateInput
    _sum?: questionSumOrderByAggregateInput
  }

  export type questionScalarWhereWithAggregatesInput = {
    AND?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    OR?: questionScalarWhereWithAggregatesInput[]
    NOT?: questionScalarWhereWithAggregatesInput | questionScalarWhereWithAggregatesInput[]
    question_id?: IntWithAggregatesFilter<"question"> | number
    assignment_id?: IntWithAggregatesFilter<"question"> | number
    question_number?: IntNullableWithAggregatesFilter<"question"> | number | null
    name?: StringNullableWithAggregatesFilter<"question"> | string | null
    prompt?: StringNullableWithAggregatesFilter<"question"> | string | null
    example_solution_s3_path?: StringNullableWithAggregatesFilter<"question"> | string | null
    accepted_file_types?: StringNullableWithAggregatesFilter<"question"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"question"> | Date | string | null
  }

  export type question_submissionWhereInput = {
    AND?: question_submissionWhereInput | question_submissionWhereInput[]
    OR?: question_submissionWhereInput[]
    NOT?: question_submissionWhereInput | question_submissionWhereInput[]
    question_submission_id?: IntFilter<"question_submission"> | number
    assignment_submission_id?: IntFilter<"question_submission"> | number
    question_id?: IntFilter<"question_submission"> | number
    student_id?: IntFilter<"question_submission"> | number
    s3_path?: StringFilter<"question_submission"> | string
    created_at?: DateTimeNullableFilter<"question_submission"> | Date | string | null
    assignment_submission?: XOR<Assignment_submissionScalarRelationFilter, assignment_submissionWhereInput>
    question?: XOR<QuestionScalarRelationFilter, questionWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }

  export type question_submissionOrderByWithRelationInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    created_at?: SortOrderInput | SortOrder
    assignment_submission?: assignment_submissionOrderByWithRelationInput
    question?: questionOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
  }

  export type question_submissionWhereUniqueInput = Prisma.AtLeast<{
    question_submission_id?: number
    AND?: question_submissionWhereInput | question_submissionWhereInput[]
    OR?: question_submissionWhereInput[]
    NOT?: question_submissionWhereInput | question_submissionWhereInput[]
    assignment_submission_id?: IntFilter<"question_submission"> | number
    question_id?: IntFilter<"question_submission"> | number
    student_id?: IntFilter<"question_submission"> | number
    s3_path?: StringFilter<"question_submission"> | string
    created_at?: DateTimeNullableFilter<"question_submission"> | Date | string | null
    assignment_submission?: XOR<Assignment_submissionScalarRelationFilter, assignment_submissionWhereInput>
    question?: XOR<QuestionScalarRelationFilter, questionWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }, "question_submission_id">

  export type question_submissionOrderByWithAggregationInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: question_submissionCountOrderByAggregateInput
    _avg?: question_submissionAvgOrderByAggregateInput
    _max?: question_submissionMaxOrderByAggregateInput
    _min?: question_submissionMinOrderByAggregateInput
    _sum?: question_submissionSumOrderByAggregateInput
  }

  export type question_submissionScalarWhereWithAggregatesInput = {
    AND?: question_submissionScalarWhereWithAggregatesInput | question_submissionScalarWhereWithAggregatesInput[]
    OR?: question_submissionScalarWhereWithAggregatesInput[]
    NOT?: question_submissionScalarWhereWithAggregatesInput | question_submissionScalarWhereWithAggregatesInput[]
    question_submission_id?: IntWithAggregatesFilter<"question_submission"> | number
    assignment_submission_id?: IntWithAggregatesFilter<"question_submission"> | number
    question_id?: IntWithAggregatesFilter<"question_submission"> | number
    student_id?: IntWithAggregatesFilter<"question_submission"> | number
    s3_path?: StringWithAggregatesFilter<"question_submission"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"question_submission"> | Date | string | null
  }

  export type classroomWhereInput = {
    AND?: classroomWhereInput | classroomWhereInput[]
    OR?: classroomWhereInput[]
    NOT?: classroomWhereInput | classroomWhereInput[]
    classroom_id?: IntFilter<"classroom"> | number
    name?: StringFilter<"classroom"> | string
    description?: StringNullableFilter<"classroom"> | string | null
    created_at?: DateTimeFilter<"classroom"> | Date | string
    updated_at?: DateTimeFilter<"classroom"> | Date | string
    student_classroom?: Student_classroomListRelationFilter
    teacher_classroom?: Teacher_classroomListRelationFilter
    assignment?: AssignmentListRelationFilter
  }

  export type classroomOrderByWithRelationInput = {
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    student_classroom?: student_classroomOrderByRelationAggregateInput
    teacher_classroom?: teacher_classroomOrderByRelationAggregateInput
    assignment?: assignmentOrderByRelationAggregateInput
  }

  export type classroomWhereUniqueInput = Prisma.AtLeast<{
    classroom_id?: number
    AND?: classroomWhereInput | classroomWhereInput[]
    OR?: classroomWhereInput[]
    NOT?: classroomWhereInput | classroomWhereInput[]
    name?: StringFilter<"classroom"> | string
    description?: StringNullableFilter<"classroom"> | string | null
    created_at?: DateTimeFilter<"classroom"> | Date | string
    updated_at?: DateTimeFilter<"classroom"> | Date | string
    student_classroom?: Student_classroomListRelationFilter
    teacher_classroom?: Teacher_classroomListRelationFilter
    assignment?: AssignmentListRelationFilter
  }, "classroom_id">

  export type classroomOrderByWithAggregationInput = {
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: classroomCountOrderByAggregateInput
    _avg?: classroomAvgOrderByAggregateInput
    _max?: classroomMaxOrderByAggregateInput
    _min?: classroomMinOrderByAggregateInput
    _sum?: classroomSumOrderByAggregateInput
  }

  export type classroomScalarWhereWithAggregatesInput = {
    AND?: classroomScalarWhereWithAggregatesInput | classroomScalarWhereWithAggregatesInput[]
    OR?: classroomScalarWhereWithAggregatesInput[]
    NOT?: classroomScalarWhereWithAggregatesInput | classroomScalarWhereWithAggregatesInput[]
    classroom_id?: IntWithAggregatesFilter<"classroom"> | number
    name?: StringWithAggregatesFilter<"classroom"> | string
    description?: StringNullableWithAggregatesFilter<"classroom"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"classroom"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"classroom"> | Date | string
  }

  export type studentWhereInput = {
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    student_id?: IntFilter<"student"> | number
    user_id?: IntFilter<"student"> | number
    created_at?: DateTimeFilter<"student"> | Date | string
    updated_at?: DateTimeFilter<"student"> | Date | string
    assignment_submission?: Assignment_submissionListRelationFilter
    student_classroom?: Student_classroomListRelationFilter
    question_submission?: Question_submissionListRelationFilter
    student_scholarship?: Student_scholarshipListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type studentOrderByWithRelationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    assignment_submission?: assignment_submissionOrderByRelationAggregateInput
    student_classroom?: student_classroomOrderByRelationAggregateInput
    question_submission?: question_submissionOrderByRelationAggregateInput
    student_scholarship?: student_scholarshipOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
  }

  export type studentWhereUniqueInput = Prisma.AtLeast<{
    student_id?: number
    user_id?: number
    AND?: studentWhereInput | studentWhereInput[]
    OR?: studentWhereInput[]
    NOT?: studentWhereInput | studentWhereInput[]
    created_at?: DateTimeFilter<"student"> | Date | string
    updated_at?: DateTimeFilter<"student"> | Date | string
    assignment_submission?: Assignment_submissionListRelationFilter
    student_classroom?: Student_classroomListRelationFilter
    question_submission?: Question_submissionListRelationFilter
    student_scholarship?: Student_scholarshipListRelationFilter
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "student_id" | "user_id">

  export type studentOrderByWithAggregationInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: studentCountOrderByAggregateInput
    _avg?: studentAvgOrderByAggregateInput
    _max?: studentMaxOrderByAggregateInput
    _min?: studentMinOrderByAggregateInput
    _sum?: studentSumOrderByAggregateInput
  }

  export type studentScalarWhereWithAggregatesInput = {
    AND?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    OR?: studentScalarWhereWithAggregatesInput[]
    NOT?: studentScalarWhereWithAggregatesInput | studentScalarWhereWithAggregatesInput[]
    student_id?: IntWithAggregatesFilter<"student"> | number
    user_id?: IntWithAggregatesFilter<"student"> | number
    created_at?: DateTimeWithAggregatesFilter<"student"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"student"> | Date | string
  }

  export type student_classroomWhereInput = {
    AND?: student_classroomWhereInput | student_classroomWhereInput[]
    OR?: student_classroomWhereInput[]
    NOT?: student_classroomWhereInput | student_classroomWhereInput[]
    student_classroom_id?: IntFilter<"student_classroom"> | number
    student_id?: IntFilter<"student_classroom"> | number
    classroom_id?: IntFilter<"student_classroom"> | number
    created_at?: DateTimeFilter<"student_classroom"> | Date | string
    updated_at?: DateTimeFilter<"student_classroom"> | Date | string
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
  }

  export type student_classroomOrderByWithRelationInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    student?: studentOrderByWithRelationInput
    classroom?: classroomOrderByWithRelationInput
  }

  export type student_classroomWhereUniqueInput = Prisma.AtLeast<{
    student_classroom_id?: number
    student_id_classroom_id?: student_classroomStudent_idClassroom_idCompoundUniqueInput
    AND?: student_classroomWhereInput | student_classroomWhereInput[]
    OR?: student_classroomWhereInput[]
    NOT?: student_classroomWhereInput | student_classroomWhereInput[]
    student_id?: IntFilter<"student_classroom"> | number
    classroom_id?: IntFilter<"student_classroom"> | number
    created_at?: DateTimeFilter<"student_classroom"> | Date | string
    updated_at?: DateTimeFilter<"student_classroom"> | Date | string
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
  }, "student_classroom_id" | "student_id_classroom_id">

  export type student_classroomOrderByWithAggregationInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: student_classroomCountOrderByAggregateInput
    _avg?: student_classroomAvgOrderByAggregateInput
    _max?: student_classroomMaxOrderByAggregateInput
    _min?: student_classroomMinOrderByAggregateInput
    _sum?: student_classroomSumOrderByAggregateInput
  }

  export type student_classroomScalarWhereWithAggregatesInput = {
    AND?: student_classroomScalarWhereWithAggregatesInput | student_classroomScalarWhereWithAggregatesInput[]
    OR?: student_classroomScalarWhereWithAggregatesInput[]
    NOT?: student_classroomScalarWhereWithAggregatesInput | student_classroomScalarWhereWithAggregatesInput[]
    student_classroom_id?: IntWithAggregatesFilter<"student_classroom"> | number
    student_id?: IntWithAggregatesFilter<"student_classroom"> | number
    classroom_id?: IntWithAggregatesFilter<"student_classroom"> | number
    created_at?: DateTimeWithAggregatesFilter<"student_classroom"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"student_classroom"> | Date | string
  }

  export type teacherWhereInput = {
    AND?: teacherWhereInput | teacherWhereInput[]
    OR?: teacherWhereInput[]
    NOT?: teacherWhereInput | teacherWhereInput[]
    teacher_id?: IntFilter<"teacher"> | number
    user_id?: IntFilter<"teacher"> | number
    created_at?: DateTimeFilter<"teacher"> | Date | string
    updated_at?: DateTimeFilter<"teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    teacher_classroom?: Teacher_classroomListRelationFilter
  }

  export type teacherOrderByWithRelationInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user?: userOrderByWithRelationInput
    teacher_classroom?: teacher_classroomOrderByRelationAggregateInput
  }

  export type teacherWhereUniqueInput = Prisma.AtLeast<{
    teacher_id?: number
    user_id?: number
    AND?: teacherWhereInput | teacherWhereInput[]
    OR?: teacherWhereInput[]
    NOT?: teacherWhereInput | teacherWhereInput[]
    created_at?: DateTimeFilter<"teacher"> | Date | string
    updated_at?: DateTimeFilter<"teacher"> | Date | string
    user?: XOR<UserScalarRelationFilter, userWhereInput>
    teacher_classroom?: Teacher_classroomListRelationFilter
  }, "teacher_id" | "user_id">

  export type teacherOrderByWithAggregationInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: teacherCountOrderByAggregateInput
    _avg?: teacherAvgOrderByAggregateInput
    _max?: teacherMaxOrderByAggregateInput
    _min?: teacherMinOrderByAggregateInput
    _sum?: teacherSumOrderByAggregateInput
  }

  export type teacherScalarWhereWithAggregatesInput = {
    AND?: teacherScalarWhereWithAggregatesInput | teacherScalarWhereWithAggregatesInput[]
    OR?: teacherScalarWhereWithAggregatesInput[]
    NOT?: teacherScalarWhereWithAggregatesInput | teacherScalarWhereWithAggregatesInput[]
    teacher_id?: IntWithAggregatesFilter<"teacher"> | number
    user_id?: IntWithAggregatesFilter<"teacher"> | number
    created_at?: DateTimeWithAggregatesFilter<"teacher"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"teacher"> | Date | string
  }

  export type teacher_classroomWhereInput = {
    AND?: teacher_classroomWhereInput | teacher_classroomWhereInput[]
    OR?: teacher_classroomWhereInput[]
    NOT?: teacher_classroomWhereInput | teacher_classroomWhereInput[]
    teacher_classrood_id?: IntFilter<"teacher_classroom"> | number
    teacher_id?: IntFilter<"teacher_classroom"> | number
    classroom_id?: IntFilter<"teacher_classroom"> | number
    created_at?: DateTimeFilter<"teacher_classroom"> | Date | string
    updated_at?: DateTimeFilter<"teacher_classroom"> | Date | string
    teacher?: XOR<TeacherScalarRelationFilter, teacherWhereInput>
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
  }

  export type teacher_classroomOrderByWithRelationInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    teacher?: teacherOrderByWithRelationInput
    classroom?: classroomOrderByWithRelationInput
  }

  export type teacher_classroomWhereUniqueInput = Prisma.AtLeast<{
    teacher_classrood_id?: number
    teacher_id_classroom_id?: teacher_classroomTeacher_idClassroom_idCompoundUniqueInput
    AND?: teacher_classroomWhereInput | teacher_classroomWhereInput[]
    OR?: teacher_classroomWhereInput[]
    NOT?: teacher_classroomWhereInput | teacher_classroomWhereInput[]
    teacher_id?: IntFilter<"teacher_classroom"> | number
    classroom_id?: IntFilter<"teacher_classroom"> | number
    created_at?: DateTimeFilter<"teacher_classroom"> | Date | string
    updated_at?: DateTimeFilter<"teacher_classroom"> | Date | string
    teacher?: XOR<TeacherScalarRelationFilter, teacherWhereInput>
    classroom?: XOR<ClassroomScalarRelationFilter, classroomWhereInput>
  }, "teacher_classrood_id" | "teacher_id_classroom_id">

  export type teacher_classroomOrderByWithAggregationInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: teacher_classroomCountOrderByAggregateInput
    _avg?: teacher_classroomAvgOrderByAggregateInput
    _max?: teacher_classroomMaxOrderByAggregateInput
    _min?: teacher_classroomMinOrderByAggregateInput
    _sum?: teacher_classroomSumOrderByAggregateInput
  }

  export type teacher_classroomScalarWhereWithAggregatesInput = {
    AND?: teacher_classroomScalarWhereWithAggregatesInput | teacher_classroomScalarWhereWithAggregatesInput[]
    OR?: teacher_classroomScalarWhereWithAggregatesInput[]
    NOT?: teacher_classroomScalarWhereWithAggregatesInput | teacher_classroomScalarWhereWithAggregatesInput[]
    teacher_classrood_id?: IntWithAggregatesFilter<"teacher_classroom"> | number
    teacher_id?: IntWithAggregatesFilter<"teacher_classroom"> | number
    classroom_id?: IntWithAggregatesFilter<"teacher_classroom"> | number
    created_at?: DateTimeWithAggregatesFilter<"teacher_classroom"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"teacher_classroom"> | Date | string
  }

  export type scholarshipWhereInput = {
    AND?: scholarshipWhereInput | scholarshipWhereInput[]
    OR?: scholarshipWhereInput[]
    NOT?: scholarshipWhereInput | scholarshipWhereInput[]
    scholarship_id?: IntFilter<"scholarship"> | number
    name?: StringFilter<"scholarship"> | string
    organization_id?: IntFilter<"scholarship"> | number
    award?: StringNullableFilter<"scholarship"> | string | null
    description?: StringNullableFilter<"scholarship"> | string | null
    category?: StringNullableFilter<"scholarship"> | string | null
    eligibility?: StringNullableFilter<"scholarship"> | string | null
    region?: StringNullableFilter<"scholarship"> | string | null
    deadline?: DateTimeNullableFilter<"scholarship"> | Date | string | null
    fafsa?: BoolNullableFilter<"scholarship"> | boolean | null
    gpa?: DecimalNullableFilter<"scholarship"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"scholarship"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, organizationWhereInput>
    student_scholarship?: Student_scholarshipListRelationFilter
  }

  export type scholarshipOrderByWithRelationInput = {
    scholarship_id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    award?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    fafsa?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    organization?: organizationOrderByWithRelationInput
    student_scholarship?: student_scholarshipOrderByRelationAggregateInput
  }

  export type scholarshipWhereUniqueInput = Prisma.AtLeast<{
    scholarship_id?: number
    AND?: scholarshipWhereInput | scholarshipWhereInput[]
    OR?: scholarshipWhereInput[]
    NOT?: scholarshipWhereInput | scholarshipWhereInput[]
    name?: StringFilter<"scholarship"> | string
    organization_id?: IntFilter<"scholarship"> | number
    award?: StringNullableFilter<"scholarship"> | string | null
    description?: StringNullableFilter<"scholarship"> | string | null
    category?: StringNullableFilter<"scholarship"> | string | null
    eligibility?: StringNullableFilter<"scholarship"> | string | null
    region?: StringNullableFilter<"scholarship"> | string | null
    deadline?: DateTimeNullableFilter<"scholarship"> | Date | string | null
    fafsa?: BoolNullableFilter<"scholarship"> | boolean | null
    gpa?: DecimalNullableFilter<"scholarship"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"scholarship"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, organizationWhereInput>
    student_scholarship?: Student_scholarshipListRelationFilter
  }, "scholarship_id">

  export type scholarshipOrderByWithAggregationInput = {
    scholarship_id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    award?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    fafsa?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: scholarshipCountOrderByAggregateInput
    _avg?: scholarshipAvgOrderByAggregateInput
    _max?: scholarshipMaxOrderByAggregateInput
    _min?: scholarshipMinOrderByAggregateInput
    _sum?: scholarshipSumOrderByAggregateInput
  }

  export type scholarshipScalarWhereWithAggregatesInput = {
    AND?: scholarshipScalarWhereWithAggregatesInput | scholarshipScalarWhereWithAggregatesInput[]
    OR?: scholarshipScalarWhereWithAggregatesInput[]
    NOT?: scholarshipScalarWhereWithAggregatesInput | scholarshipScalarWhereWithAggregatesInput[]
    scholarship_id?: IntWithAggregatesFilter<"scholarship"> | number
    name?: StringWithAggregatesFilter<"scholarship"> | string
    organization_id?: IntWithAggregatesFilter<"scholarship"> | number
    award?: StringNullableWithAggregatesFilter<"scholarship"> | string | null
    description?: StringNullableWithAggregatesFilter<"scholarship"> | string | null
    category?: StringNullableWithAggregatesFilter<"scholarship"> | string | null
    eligibility?: StringNullableWithAggregatesFilter<"scholarship"> | string | null
    region?: StringNullableWithAggregatesFilter<"scholarship"> | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"scholarship"> | Date | string | null
    fafsa?: BoolNullableWithAggregatesFilter<"scholarship"> | boolean | null
    gpa?: DecimalNullableWithAggregatesFilter<"scholarship"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"scholarship"> | Date | string | null
  }

  export type student_scholarshipWhereInput = {
    AND?: student_scholarshipWhereInput | student_scholarshipWhereInput[]
    OR?: student_scholarshipWhereInput[]
    NOT?: student_scholarshipWhereInput | student_scholarshipWhereInput[]
    student_scholarship_id?: IntFilter<"student_scholarship"> | number
    student_id?: IntFilter<"student_scholarship"> | number
    scholarship_id?: IntFilter<"student_scholarship"> | number
    is_bookmarked?: BoolNullableFilter<"student_scholarship"> | boolean | null
    scholarship?: XOR<ScholarshipScalarRelationFilter, scholarshipWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }

  export type student_scholarshipOrderByWithRelationInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
    is_bookmarked?: SortOrderInput | SortOrder
    scholarship?: scholarshipOrderByWithRelationInput
    student?: studentOrderByWithRelationInput
  }

  export type student_scholarshipWhereUniqueInput = Prisma.AtLeast<{
    student_scholarship_id?: number
    AND?: student_scholarshipWhereInput | student_scholarshipWhereInput[]
    OR?: student_scholarshipWhereInput[]
    NOT?: student_scholarshipWhereInput | student_scholarshipWhereInput[]
    student_id?: IntFilter<"student_scholarship"> | number
    scholarship_id?: IntFilter<"student_scholarship"> | number
    is_bookmarked?: BoolNullableFilter<"student_scholarship"> | boolean | null
    scholarship?: XOR<ScholarshipScalarRelationFilter, scholarshipWhereInput>
    student?: XOR<StudentScalarRelationFilter, studentWhereInput>
  }, "student_scholarship_id">

  export type student_scholarshipOrderByWithAggregationInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
    is_bookmarked?: SortOrderInput | SortOrder
    _count?: student_scholarshipCountOrderByAggregateInput
    _avg?: student_scholarshipAvgOrderByAggregateInput
    _max?: student_scholarshipMaxOrderByAggregateInput
    _min?: student_scholarshipMinOrderByAggregateInput
    _sum?: student_scholarshipSumOrderByAggregateInput
  }

  export type student_scholarshipScalarWhereWithAggregatesInput = {
    AND?: student_scholarshipScalarWhereWithAggregatesInput | student_scholarshipScalarWhereWithAggregatesInput[]
    OR?: student_scholarshipScalarWhereWithAggregatesInput[]
    NOT?: student_scholarshipScalarWhereWithAggregatesInput | student_scholarshipScalarWhereWithAggregatesInput[]
    student_scholarship_id?: IntWithAggregatesFilter<"student_scholarship"> | number
    student_id?: IntWithAggregatesFilter<"student_scholarship"> | number
    scholarship_id?: IntWithAggregatesFilter<"student_scholarship"> | number
    is_bookmarked?: BoolNullableWithAggregatesFilter<"student_scholarship"> | boolean | null
  }

  export type postWhereInput = {
    AND?: postWhereInput | postWhereInput[]
    OR?: postWhereInput[]
    NOT?: postWhereInput | postWhereInput[]
    post_id?: IntFilter<"post"> | number
    title?: StringFilter<"post"> | string
    content?: StringNullableFilter<"post"> | string | null
    published?: BoolFilter<"post"> | boolean
    author_id?: IntNullableFilter<"post"> | number | null
    author?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type postOrderByWithRelationInput = {
    post_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    published?: SortOrder
    author_id?: SortOrderInput | SortOrder
    author?: userOrderByWithRelationInput
  }

  export type postWhereUniqueInput = Prisma.AtLeast<{
    post_id?: number
    AND?: postWhereInput | postWhereInput[]
    OR?: postWhereInput[]
    NOT?: postWhereInput | postWhereInput[]
    title?: StringFilter<"post"> | string
    content?: StringNullableFilter<"post"> | string | null
    published?: BoolFilter<"post"> | boolean
    author_id?: IntNullableFilter<"post"> | number | null
    author?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "post_id">

  export type postOrderByWithAggregationInput = {
    post_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    published?: SortOrder
    author_id?: SortOrderInput | SortOrder
    _count?: postCountOrderByAggregateInput
    _avg?: postAvgOrderByAggregateInput
    _max?: postMaxOrderByAggregateInput
    _min?: postMinOrderByAggregateInput
    _sum?: postSumOrderByAggregateInput
  }

  export type postScalarWhereWithAggregatesInput = {
    AND?: postScalarWhereWithAggregatesInput | postScalarWhereWithAggregatesInput[]
    OR?: postScalarWhereWithAggregatesInput[]
    NOT?: postScalarWhereWithAggregatesInput | postScalarWhereWithAggregatesInput[]
    post_id?: IntWithAggregatesFilter<"post"> | number
    title?: StringWithAggregatesFilter<"post"> | string
    content?: StringNullableWithAggregatesFilter<"post"> | string | null
    published?: BoolWithAggregatesFilter<"post"> | boolean
    author_id?: IntNullableWithAggregatesFilter<"post"> | number | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    user_id?: IntFilter<"user"> | number
    name?: StringNullableFilter<"user"> | string | null
    email?: StringFilter<"user"> | string
    role?: EnumUserRoleFilter<"user"> | $Enums.UserRole
    payment_info?: StringNullableFilter<"user"> | string | null
    invite_code?: UuidNullableFilter<"user"> | string | null
    signup_complete?: BoolNullableFilter<"user"> | boolean | null
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"user"> | Date | string | null
    city?: StringNullableFilter<"user"> | string | null
    state?: StringNullableFilter<"user"> | string | null
    country?: StringNullableFilter<"user"> | string | null
    timezone?: StringNullableFilter<"user"> | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    user_organization?: User_organizationListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    post?: PostListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    role?: SortOrder
    payment_info?: SortOrderInput | SortOrder
    invite_code?: SortOrderInput | SortOrder
    signup_complete?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    admin?: adminOrderByWithRelationInput
    user_organization?: user_organizationOrderByRelationAggregateInput
    student?: studentOrderByWithRelationInput
    teacher?: teacherOrderByWithRelationInput
    post?: postOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    user_id?: number
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringNullableFilter<"user"> | string | null
    role?: EnumUserRoleFilter<"user"> | $Enums.UserRole
    payment_info?: StringNullableFilter<"user"> | string | null
    invite_code?: UuidNullableFilter<"user"> | string | null
    signup_complete?: BoolNullableFilter<"user"> | boolean | null
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"user"> | Date | string | null
    city?: StringNullableFilter<"user"> | string | null
    state?: StringNullableFilter<"user"> | string | null
    country?: StringNullableFilter<"user"> | string | null
    timezone?: StringNullableFilter<"user"> | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, adminWhereInput> | null
    user_organization?: User_organizationListRelationFilter
    student?: XOR<StudentNullableScalarRelationFilter, studentWhereInput> | null
    teacher?: XOR<TeacherNullableScalarRelationFilter, teacherWhereInput> | null
    post?: PostListRelationFilter
  }, "user_id" | "email">

  export type userOrderByWithAggregationInput = {
    user_id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    role?: SortOrder
    payment_info?: SortOrderInput | SortOrder
    invite_code?: SortOrderInput | SortOrder
    signup_complete?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user"> | number
    name?: StringNullableWithAggregatesFilter<"user"> | string | null
    email?: StringWithAggregatesFilter<"user"> | string
    role?: EnumUserRoleWithAggregatesFilter<"user"> | $Enums.UserRole
    payment_info?: StringNullableWithAggregatesFilter<"user"> | string | null
    invite_code?: UuidNullableWithAggregatesFilter<"user"> | string | null
    signup_complete?: BoolNullableWithAggregatesFilter<"user"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    city?: StringNullableWithAggregatesFilter<"user"> | string | null
    state?: StringNullableWithAggregatesFilter<"user"> | string | null
    country?: StringNullableWithAggregatesFilter<"user"> | string | null
    timezone?: StringNullableWithAggregatesFilter<"user"> | string | null
  }

  export type adminWhereInput = {
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    admin_id?: IntFilter<"admin"> | number
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    user_id?: IntFilter<"admin"> | number
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type adminOrderByWithRelationInput = {
    admin_id?: SortOrder
    is_active?: SortOrderInput | SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type adminWhereUniqueInput = Prisma.AtLeast<{
    admin_id?: number
    user_id?: number
    AND?: adminWhereInput | adminWhereInput[]
    OR?: adminWhereInput[]
    NOT?: adminWhereInput | adminWhereInput[]
    is_active?: BoolNullableFilter<"admin"> | boolean | null
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "admin_id" | "user_id">

  export type adminOrderByWithAggregationInput = {
    admin_id?: SortOrder
    is_active?: SortOrderInput | SortOrder
    user_id?: SortOrder
    _count?: adminCountOrderByAggregateInput
    _avg?: adminAvgOrderByAggregateInput
    _max?: adminMaxOrderByAggregateInput
    _min?: adminMinOrderByAggregateInput
    _sum?: adminSumOrderByAggregateInput
  }

  export type adminScalarWhereWithAggregatesInput = {
    AND?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    OR?: adminScalarWhereWithAggregatesInput[]
    NOT?: adminScalarWhereWithAggregatesInput | adminScalarWhereWithAggregatesInput[]
    admin_id?: IntWithAggregatesFilter<"admin"> | number
    is_active?: BoolNullableWithAggregatesFilter<"admin"> | boolean | null
    user_id?: IntWithAggregatesFilter<"admin"> | number
  }

  export type organizationWhereInput = {
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    organization_id?: IntFilter<"organization"> | number
    name?: StringNullableFilter<"organization"> | string | null
    description?: StringNullableFilter<"organization"> | string | null
    website?: StringNullableFilter<"organization"> | string | null
    old_id?: UuidNullableFilter<"organization"> | string | null
    scholarship?: ScholarshipListRelationFilter
    user_organization?: User_organizationListRelationFilter
  }

  export type organizationOrderByWithRelationInput = {
    organization_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    old_id?: SortOrderInput | SortOrder
    scholarship?: scholarshipOrderByRelationAggregateInput
    user_organization?: user_organizationOrderByRelationAggregateInput
  }

  export type organizationWhereUniqueInput = Prisma.AtLeast<{
    organization_id?: number
    AND?: organizationWhereInput | organizationWhereInput[]
    OR?: organizationWhereInput[]
    NOT?: organizationWhereInput | organizationWhereInput[]
    name?: StringNullableFilter<"organization"> | string | null
    description?: StringNullableFilter<"organization"> | string | null
    website?: StringNullableFilter<"organization"> | string | null
    old_id?: UuidNullableFilter<"organization"> | string | null
    scholarship?: ScholarshipListRelationFilter
    user_organization?: User_organizationListRelationFilter
  }, "organization_id">

  export type organizationOrderByWithAggregationInput = {
    organization_id?: SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    old_id?: SortOrderInput | SortOrder
    _count?: organizationCountOrderByAggregateInput
    _avg?: organizationAvgOrderByAggregateInput
    _max?: organizationMaxOrderByAggregateInput
    _min?: organizationMinOrderByAggregateInput
    _sum?: organizationSumOrderByAggregateInput
  }

  export type organizationScalarWhereWithAggregatesInput = {
    AND?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    OR?: organizationScalarWhereWithAggregatesInput[]
    NOT?: organizationScalarWhereWithAggregatesInput | organizationScalarWhereWithAggregatesInput[]
    organization_id?: IntWithAggregatesFilter<"organization"> | number
    name?: StringNullableWithAggregatesFilter<"organization"> | string | null
    description?: StringNullableWithAggregatesFilter<"organization"> | string | null
    website?: StringNullableWithAggregatesFilter<"organization"> | string | null
    old_id?: UuidNullableWithAggregatesFilter<"organization"> | string | null
  }

  export type user_organizationWhereInput = {
    AND?: user_organizationWhereInput | user_organizationWhereInput[]
    OR?: user_organizationWhereInput[]
    NOT?: user_organizationWhereInput | user_organizationWhereInput[]
    user_organization_id?: IntFilter<"user_organization"> | number
    user_id?: IntFilter<"user_organization"> | number
    organization_id?: IntFilter<"user_organization"> | number
    organization?: XOR<OrganizationScalarRelationFilter, organizationWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type user_organizationOrderByWithRelationInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
    organization?: organizationOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type user_organizationWhereUniqueInput = Prisma.AtLeast<{
    user_organization_id?: number
    AND?: user_organizationWhereInput | user_organizationWhereInput[]
    OR?: user_organizationWhereInput[]
    NOT?: user_organizationWhereInput | user_organizationWhereInput[]
    user_id?: IntFilter<"user_organization"> | number
    organization_id?: IntFilter<"user_organization"> | number
    organization?: XOR<OrganizationScalarRelationFilter, organizationWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "user_organization_id">

  export type user_organizationOrderByWithAggregationInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
    _count?: user_organizationCountOrderByAggregateInput
    _avg?: user_organizationAvgOrderByAggregateInput
    _max?: user_organizationMaxOrderByAggregateInput
    _min?: user_organizationMinOrderByAggregateInput
    _sum?: user_organizationSumOrderByAggregateInput
  }

  export type user_organizationScalarWhereWithAggregatesInput = {
    AND?: user_organizationScalarWhereWithAggregatesInput | user_organizationScalarWhereWithAggregatesInput[]
    OR?: user_organizationScalarWhereWithAggregatesInput[]
    NOT?: user_organizationScalarWhereWithAggregatesInput | user_organizationScalarWhereWithAggregatesInput[]
    user_organization_id?: IntWithAggregatesFilter<"user_organization"> | number
    user_id?: IntWithAggregatesFilter<"user_organization"> | number
    organization_id?: IntWithAggregatesFilter<"user_organization"> | number
  }

  export type assignmentCreateInput = {
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    classroom: classroomCreateNestedOneWithoutAssignmentInput
    assignment_submission?: assignment_submissionCreateNestedManyWithoutAssignmentInput
    question?: questionCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentUncheckedCreateInput = {
    assignment_id?: number
    classroom_id: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutAssignmentInput
    question?: questionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: classroomUpdateOneRequiredWithoutAssignmentNestedInput
    assignment_submission?: assignment_submissionUpdateManyWithoutAssignmentNestedInput
    question?: questionUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentUncheckedUpdateInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutAssignmentNestedInput
    question?: questionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentCreateManyInput = {
    assignment_id?: number
    classroom_id: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
  }

  export type assignmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assignmentUncheckedUpdateManyInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assignment_submissionCreateInput = {
    s3_path: string
    submitted_at?: Date | string | null
    assignment: assignmentCreateNestedOneWithoutAssignment_submissionInput
    student: studentCreateNestedOneWithoutAssignment_submissionInput
    question_submission?: question_submissionCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionUncheckedCreateInput = {
    assignment_submission_id?: number
    assignment_id: number
    student_id: number
    s3_path: string
    submitted_at?: Date | string | null
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionUpdateInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: assignmentUpdateOneRequiredWithoutAssignment_submissionNestedInput
    student?: studentUpdateOneRequiredWithoutAssignment_submissionNestedInput
    question_submission?: question_submissionUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUncheckedUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionCreateManyInput = {
    assignment_submission_id?: number
    assignment_id: number
    student_id: number
    s3_path: string
    submitted_at?: Date | string | null
  }

  export type assignment_submissionUpdateManyMutationInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assignment_submissionUncheckedUpdateManyInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionCreateInput = {
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
    assignment: assignmentCreateNestedOneWithoutQuestionInput
    question_submission?: question_submissionCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateInput = {
    question_id?: number
    assignment_id: number
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionUpdateInput = {
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: assignmentUpdateOneRequiredWithoutQuestionNestedInput
    question_submission?: question_submissionUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionCreateManyInput = {
    question_id?: number
    assignment_id: number
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
  }

  export type questionUpdateManyMutationInput = {
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionUncheckedUpdateManyInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionCreateInput = {
    s3_path: string
    created_at?: Date | string | null
    assignment_submission: assignment_submissionCreateNestedOneWithoutQuestion_submissionInput
    question: questionCreateNestedOneWithoutQuestion_submissionInput
    student: studentCreateNestedOneWithoutQuestion_submissionInput
  }

  export type question_submissionUncheckedCreateInput = {
    question_submission_id?: number
    assignment_submission_id: number
    question_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionUpdateInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUpdateOneRequiredWithoutQuestion_submissionNestedInput
    question?: questionUpdateOneRequiredWithoutQuestion_submissionNestedInput
    student?: studentUpdateOneRequiredWithoutQuestion_submissionNestedInput
  }

  export type question_submissionUncheckedUpdateInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionCreateManyInput = {
    question_submission_id?: number
    assignment_submission_id: number
    question_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionUpdateManyMutationInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionUncheckedUpdateManyInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type classroomCreateInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomCreateNestedManyWithoutClassroomInput
    teacher_classroom?: teacher_classroomCreateNestedManyWithoutClassroomInput
    assignment?: assignmentCreateNestedManyWithoutClassroomInput
  }

  export type classroomUncheckedCreateInput = {
    classroom_id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutClassroomInput
    teacher_classroom?: teacher_classroomUncheckedCreateNestedManyWithoutClassroomInput
    assignment?: assignmentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type classroomUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUpdateManyWithoutClassroomNestedInput
    teacher_classroom?: teacher_classroomUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUpdateManyWithoutClassroomNestedInput
  }

  export type classroomUncheckedUpdateInput = {
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUncheckedUpdateManyWithoutClassroomNestedInput
    teacher_classroom?: teacher_classroomUncheckedUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type classroomCreateManyInput = {
    classroom_id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type classroomUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type classroomUncheckedUpdateManyInput = {
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutStudentInput
    user: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutStudentNestedInput
    user?: userUpdateOneRequiredWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUncheckedUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type studentCreateManyInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type studentUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentUncheckedUpdateManyInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_classroomCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    student: studentCreateNestedOneWithoutStudent_classroomInput
    classroom: classroomCreateNestedOneWithoutStudent_classroomInput
  }

  export type student_classroomUncheckedCreateInput = {
    student_classroom_id?: number
    student_id: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type student_classroomUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: studentUpdateOneRequiredWithoutStudent_classroomNestedInput
    classroom?: classroomUpdateOneRequiredWithoutStudent_classroomNestedInput
  }

  export type student_classroomUncheckedUpdateInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_classroomCreateManyInput = {
    student_classroom_id?: number
    student_id: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type student_classroomUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_classroomUncheckedUpdateManyInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacherCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutTeacherInput
    teacher_classroom?: teacher_classroomCreateNestedManyWithoutTeacherInput
  }

  export type teacherUncheckedCreateInput = {
    teacher_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    teacher_classroom?: teacher_classroomUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type teacherUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutTeacherNestedInput
    teacher_classroom?: teacher_classroomUpdateManyWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_classroom?: teacher_classroomUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type teacherCreateManyInput = {
    teacher_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacherUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacherUncheckedUpdateManyInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string
    teacher: teacherCreateNestedOneWithoutTeacher_classroomInput
    classroom: classroomCreateNestedOneWithoutTeacher_classroomInput
  }

  export type teacher_classroomUncheckedCreateInput = {
    teacher_classrood_id?: number
    teacher_id: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: teacherUpdateOneRequiredWithoutTeacher_classroomNestedInput
    classroom?: classroomUpdateOneRequiredWithoutTeacher_classroomNestedInput
  }

  export type teacher_classroomUncheckedUpdateInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomCreateManyInput = {
    teacher_classrood_id?: number
    teacher_id: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomUncheckedUpdateManyInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type scholarshipCreateInput = {
    name: string
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    organization: organizationCreateNestedOneWithoutScholarshipInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutScholarshipInput
  }

  export type scholarshipUncheckedCreateInput = {
    scholarship_id?: number
    name: string
    organization_id: number
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type scholarshipUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: organizationUpdateOneRequiredWithoutScholarshipNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutScholarshipNestedInput
  }

  export type scholarshipUncheckedUpdateInput = {
    scholarship_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type scholarshipCreateManyInput = {
    scholarship_id?: number
    name: string
    organization_id: number
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type scholarshipUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type scholarshipUncheckedUpdateManyInput = {
    scholarship_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_scholarshipCreateInput = {
    is_bookmarked?: boolean | null
    scholarship: scholarshipCreateNestedOneWithoutStudent_scholarshipInput
    student: studentCreateNestedOneWithoutStudent_scholarshipInput
  }

  export type student_scholarshipUncheckedCreateInput = {
    student_scholarship_id?: number
    student_id: number
    scholarship_id: number
    is_bookmarked?: boolean | null
  }

  export type student_scholarshipUpdateInput = {
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scholarship?: scholarshipUpdateOneRequiredWithoutStudent_scholarshipNestedInput
    student?: studentUpdateOneRequiredWithoutStudent_scholarshipNestedInput
  }

  export type student_scholarshipUncheckedUpdateInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    scholarship_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type student_scholarshipCreateManyInput = {
    student_scholarship_id?: number
    student_id: number
    scholarship_id: number
    is_bookmarked?: boolean | null
  }

  export type student_scholarshipUpdateManyMutationInput = {
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type student_scholarshipUncheckedUpdateManyInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    scholarship_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type postCreateInput = {
    title: string
    content?: string | null
    published?: boolean
    author?: userCreateNestedOneWithoutPostInput
  }

  export type postUncheckedCreateInput = {
    post_id?: number
    title: string
    content?: string | null
    published?: boolean
    author_id?: number | null
  }

  export type postUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    author?: userUpdateOneWithoutPostNestedInput
  }

  export type postUncheckedUpdateInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type postCreateManyInput = {
    post_id?: number
    title: string
    content?: string | null
    published?: boolean
    author_id?: number | null
  }

  export type postUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type postUncheckedUpdateManyInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    author_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userCreateInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    user_organization?: user_organizationCreateNestedManyWithoutUserInput
    student?: studentCreateNestedOneWithoutUserInput
    teacher?: teacherCreateNestedOneWithoutUserInput
    post?: postCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedOneWithoutUserInput
    teacher?: teacherUncheckedCreateNestedOneWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUpdateManyWithoutUserNestedInput
    student?: studentUpdateOneWithoutUserNestedInput
    teacher?: teacherUpdateOneWithoutUserNestedInput
    post?: postUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateOneWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type userCreateManyInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
  }

  export type userUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type adminCreateInput = {
    admin_id: number
    is_active?: boolean | null
    user: userCreateNestedOneWithoutAdminInput
  }

  export type adminUncheckedCreateInput = {
    admin_id: number
    is_active?: boolean | null
    user_id: number
  }

  export type adminUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: userUpdateOneRequiredWithoutAdminNestedInput
  }

  export type adminUncheckedUpdateInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type adminCreateManyInput = {
    admin_id: number
    is_active?: boolean | null
    user_id: number
  }

  export type adminUpdateManyMutationInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type adminUncheckedUpdateManyInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type organizationCreateInput = {
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    scholarship?: scholarshipCreateNestedManyWithoutOrganizationInput
    user_organization?: user_organizationCreateNestedManyWithoutOrganizationInput
  }

  export type organizationUncheckedCreateInput = {
    organization_id?: number
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    scholarship?: scholarshipUncheckedCreateNestedManyWithoutOrganizationInput
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type organizationUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    scholarship?: scholarshipUpdateManyWithoutOrganizationNestedInput
    user_organization?: user_organizationUpdateManyWithoutOrganizationNestedInput
  }

  export type organizationUncheckedUpdateInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    scholarship?: scholarshipUncheckedUpdateManyWithoutOrganizationNestedInput
    user_organization?: user_organizationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type organizationCreateManyInput = {
    organization_id?: number
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
  }

  export type organizationUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organizationUncheckedUpdateManyInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_organizationCreateInput = {
    organization: organizationCreateNestedOneWithoutUser_organizationInput
    user: userCreateNestedOneWithoutUser_organizationInput
  }

  export type user_organizationUncheckedCreateInput = {
    user_organization_id?: number
    user_id: number
    organization_id: number
  }

  export type user_organizationUpdateInput = {
    organization?: organizationUpdateOneRequiredWithoutUser_organizationNestedInput
    user?: userUpdateOneRequiredWithoutUser_organizationNestedInput
  }

  export type user_organizationUncheckedUpdateInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_organizationCreateManyInput = {
    user_organization_id?: number
    user_id: number
    organization_id: number
  }

  export type user_organizationUpdateManyMutationInput = {

  }

  export type user_organizationUncheckedUpdateManyInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClassroomScalarRelationFilter = {
    is?: classroomWhereInput
    isNot?: classroomWhereInput
  }

  export type Assignment_submissionListRelationFilter = {
    every?: assignment_submissionWhereInput
    some?: assignment_submissionWhereInput
    none?: assignment_submissionWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: questionWhereInput
    some?: questionWhereInput
    none?: questionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type assignment_submissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assignmentCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assignment_number?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentAvgOrderByAggregateInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    assignment_number?: SortOrder
  }

  export type assignmentMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assignment_number?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assignment_number?: SortOrder
    due_date?: SortOrder
    created_at?: SortOrder
  }

  export type assignmentSumOrderByAggregateInput = {
    assignment_id?: SortOrder
    classroom_id?: SortOrder
    assignment_number?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AssignmentScalarRelationFilter = {
    is?: assignmentWhereInput
    isNot?: assignmentWhereInput
  }

  export type StudentScalarRelationFilter = {
    is?: studentWhereInput
    isNot?: studentWhereInput
  }

  export type Question_submissionListRelationFilter = {
    every?: question_submissionWhereInput
    some?: question_submissionWhereInput
    none?: question_submissionWhereInput
  }

  export type question_submissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assignment_submissionCountOrderByAggregateInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    submitted_at?: SortOrder
  }

  export type assignment_submissionAvgOrderByAggregateInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
  }

  export type assignment_submissionMaxOrderByAggregateInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    submitted_at?: SortOrder
  }

  export type assignment_submissionMinOrderByAggregateInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    submitted_at?: SortOrder
  }

  export type assignment_submissionSumOrderByAggregateInput = {
    assignment_submission_id?: SortOrder
    assignment_id?: SortOrder
    student_id?: SortOrder
  }

  export type questionCountOrderByAggregateInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    example_solution_s3_path?: SortOrder
    accepted_file_types?: SortOrder
    created_at?: SortOrder
  }

  export type questionAvgOrderByAggregateInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrder
  }

  export type questionMaxOrderByAggregateInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    example_solution_s3_path?: SortOrder
    accepted_file_types?: SortOrder
    created_at?: SortOrder
  }

  export type questionMinOrderByAggregateInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrder
    name?: SortOrder
    prompt?: SortOrder
    example_solution_s3_path?: SortOrder
    accepted_file_types?: SortOrder
    created_at?: SortOrder
  }

  export type questionSumOrderByAggregateInput = {
    question_id?: SortOrder
    assignment_id?: SortOrder
    question_number?: SortOrder
  }

  export type Assignment_submissionScalarRelationFilter = {
    is?: assignment_submissionWhereInput
    isNot?: assignment_submissionWhereInput
  }

  export type QuestionScalarRelationFilter = {
    is?: questionWhereInput
    isNot?: questionWhereInput
  }

  export type question_submissionCountOrderByAggregateInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    created_at?: SortOrder
  }

  export type question_submissionAvgOrderByAggregateInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
  }

  export type question_submissionMaxOrderByAggregateInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    created_at?: SortOrder
  }

  export type question_submissionMinOrderByAggregateInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
    s3_path?: SortOrder
    created_at?: SortOrder
  }

  export type question_submissionSumOrderByAggregateInput = {
    question_submission_id?: SortOrder
    assignment_submission_id?: SortOrder
    question_id?: SortOrder
    student_id?: SortOrder
  }

  export type Student_classroomListRelationFilter = {
    every?: student_classroomWhereInput
    some?: student_classroomWhereInput
    none?: student_classroomWhereInput
  }

  export type Teacher_classroomListRelationFilter = {
    every?: teacher_classroomWhereInput
    some?: teacher_classroomWhereInput
    none?: teacher_classroomWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: assignmentWhereInput
    some?: assignmentWhereInput
    none?: assignmentWhereInput
  }

  export type student_classroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teacher_classroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type assignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type classroomCountOrderByAggregateInput = {
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classroomAvgOrderByAggregateInput = {
    classroom_id?: SortOrder
  }

  export type classroomMaxOrderByAggregateInput = {
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classroomMinOrderByAggregateInput = {
    classroom_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type classroomSumOrderByAggregateInput = {
    classroom_id?: SortOrder
  }

  export type Student_scholarshipListRelationFilter = {
    every?: student_scholarshipWhereInput
    some?: student_scholarshipWhereInput
    none?: student_scholarshipWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type student_scholarshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentCountOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type studentAvgOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
  }

  export type studentMaxOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type studentMinOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type studentSumOrderByAggregateInput = {
    student_id?: SortOrder
    user_id?: SortOrder
  }

  export type student_classroomStudent_idClassroom_idCompoundUniqueInput = {
    student_id: number
    classroom_id: number
  }

  export type student_classroomCountOrderByAggregateInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_classroomAvgOrderByAggregateInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
  }

  export type student_classroomMaxOrderByAggregateInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_classroomMinOrderByAggregateInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type student_classroomSumOrderByAggregateInput = {
    student_classroom_id?: SortOrder
    student_id?: SortOrder
    classroom_id?: SortOrder
  }

  export type teacherCountOrderByAggregateInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacherAvgOrderByAggregateInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
  }

  export type teacherMaxOrderByAggregateInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacherMinOrderByAggregateInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacherSumOrderByAggregateInput = {
    teacher_id?: SortOrder
    user_id?: SortOrder
  }

  export type TeacherScalarRelationFilter = {
    is?: teacherWhereInput
    isNot?: teacherWhereInput
  }

  export type teacher_classroomTeacher_idClassroom_idCompoundUniqueInput = {
    teacher_id: number
    classroom_id: number
  }

  export type teacher_classroomCountOrderByAggregateInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacher_classroomAvgOrderByAggregateInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
  }

  export type teacher_classroomMaxOrderByAggregateInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacher_classroomMinOrderByAggregateInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type teacher_classroomSumOrderByAggregateInput = {
    teacher_classrood_id?: SortOrder
    teacher_id?: SortOrder
    classroom_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type OrganizationScalarRelationFilter = {
    is?: organizationWhereInput
    isNot?: organizationWhereInput
  }

  export type scholarshipCountOrderByAggregateInput = {
    scholarship_id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    award?: SortOrder
    description?: SortOrder
    category?: SortOrder
    eligibility?: SortOrder
    region?: SortOrder
    deadline?: SortOrder
    fafsa?: SortOrder
    gpa?: SortOrder
    created_at?: SortOrder
  }

  export type scholarshipAvgOrderByAggregateInput = {
    scholarship_id?: SortOrder
    organization_id?: SortOrder
    gpa?: SortOrder
  }

  export type scholarshipMaxOrderByAggregateInput = {
    scholarship_id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    award?: SortOrder
    description?: SortOrder
    category?: SortOrder
    eligibility?: SortOrder
    region?: SortOrder
    deadline?: SortOrder
    fafsa?: SortOrder
    gpa?: SortOrder
    created_at?: SortOrder
  }

  export type scholarshipMinOrderByAggregateInput = {
    scholarship_id?: SortOrder
    name?: SortOrder
    organization_id?: SortOrder
    award?: SortOrder
    description?: SortOrder
    category?: SortOrder
    eligibility?: SortOrder
    region?: SortOrder
    deadline?: SortOrder
    fafsa?: SortOrder
    gpa?: SortOrder
    created_at?: SortOrder
  }

  export type scholarshipSumOrderByAggregateInput = {
    scholarship_id?: SortOrder
    organization_id?: SortOrder
    gpa?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type ScholarshipScalarRelationFilter = {
    is?: scholarshipWhereInput
    isNot?: scholarshipWhereInput
  }

  export type student_scholarshipCountOrderByAggregateInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
    is_bookmarked?: SortOrder
  }

  export type student_scholarshipAvgOrderByAggregateInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
  }

  export type student_scholarshipMaxOrderByAggregateInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
    is_bookmarked?: SortOrder
  }

  export type student_scholarshipMinOrderByAggregateInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
    is_bookmarked?: SortOrder
  }

  export type student_scholarshipSumOrderByAggregateInput = {
    student_scholarship_id?: SortOrder
    student_id?: SortOrder
    scholarship_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type postCountOrderByAggregateInput = {
    post_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    author_id?: SortOrder
  }

  export type postAvgOrderByAggregateInput = {
    post_id?: SortOrder
    author_id?: SortOrder
  }

  export type postMaxOrderByAggregateInput = {
    post_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    author_id?: SortOrder
  }

  export type postMinOrderByAggregateInput = {
    post_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    published?: SortOrder
    author_id?: SortOrder
  }

  export type postSumOrderByAggregateInput = {
    post_id?: SortOrder
    author_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: adminWhereInput | null
    isNot?: adminWhereInput | null
  }

  export type User_organizationListRelationFilter = {
    every?: user_organizationWhereInput
    some?: user_organizationWhereInput
    none?: user_organizationWhereInput
  }

  export type StudentNullableScalarRelationFilter = {
    is?: studentWhereInput | null
    isNot?: studentWhereInput | null
  }

  export type TeacherNullableScalarRelationFilter = {
    is?: teacherWhereInput | null
    isNot?: teacherWhereInput | null
  }

  export type PostListRelationFilter = {
    every?: postWhereInput
    some?: postWhereInput
    none?: postWhereInput
  }

  export type user_organizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type postOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    payment_info?: SortOrder
    invite_code?: SortOrder
    signup_complete?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    payment_info?: SortOrder
    invite_code?: SortOrder
    signup_complete?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    user_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    role?: SortOrder
    payment_info?: SortOrder
    invite_code?: SortOrder
    signup_complete?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type adminCountOrderByAggregateInput = {
    admin_id?: SortOrder
    is_active?: SortOrder
    user_id?: SortOrder
  }

  export type adminAvgOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type adminMaxOrderByAggregateInput = {
    admin_id?: SortOrder
    is_active?: SortOrder
    user_id?: SortOrder
  }

  export type adminMinOrderByAggregateInput = {
    admin_id?: SortOrder
    is_active?: SortOrder
    user_id?: SortOrder
  }

  export type adminSumOrderByAggregateInput = {
    admin_id?: SortOrder
    user_id?: SortOrder
  }

  export type ScholarshipListRelationFilter = {
    every?: scholarshipWhereInput
    some?: scholarshipWhereInput
    none?: scholarshipWhereInput
  }

  export type scholarshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organizationCountOrderByAggregateInput = {
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    old_id?: SortOrder
  }

  export type organizationAvgOrderByAggregateInput = {
    organization_id?: SortOrder
  }

  export type organizationMaxOrderByAggregateInput = {
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    old_id?: SortOrder
  }

  export type organizationMinOrderByAggregateInput = {
    organization_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    old_id?: SortOrder
  }

  export type organizationSumOrderByAggregateInput = {
    organization_id?: SortOrder
  }

  export type user_organizationCountOrderByAggregateInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type user_organizationAvgOrderByAggregateInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type user_organizationMaxOrderByAggregateInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type user_organizationMinOrderByAggregateInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type user_organizationSumOrderByAggregateInput = {
    user_organization_id?: SortOrder
    user_id?: SortOrder
    organization_id?: SortOrder
  }

  export type classroomCreateNestedOneWithoutAssignmentInput = {
    create?: XOR<classroomCreateWithoutAssignmentInput, classroomUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: classroomCreateOrConnectWithoutAssignmentInput
    connect?: classroomWhereUniqueInput
  }

  export type assignment_submissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput> | assignment_submissionCreateWithoutAssignmentInput[] | assignment_submissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutAssignmentInput | assignment_submissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: assignment_submissionCreateManyAssignmentInputEnvelope
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
  }

  export type questionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput> | questionCreateWithoutAssignmentInput[] | questionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: questionCreateOrConnectWithoutAssignmentInput | questionCreateOrConnectWithoutAssignmentInput[]
    createMany?: questionCreateManyAssignmentInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type assignment_submissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput> | assignment_submissionCreateWithoutAssignmentInput[] | assignment_submissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutAssignmentInput | assignment_submissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: assignment_submissionCreateManyAssignmentInputEnvelope
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
  }

  export type questionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput> | questionCreateWithoutAssignmentInput[] | questionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: questionCreateOrConnectWithoutAssignmentInput | questionCreateOrConnectWithoutAssignmentInput[]
    createMany?: questionCreateManyAssignmentInputEnvelope
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type classroomUpdateOneRequiredWithoutAssignmentNestedInput = {
    create?: XOR<classroomCreateWithoutAssignmentInput, classroomUncheckedCreateWithoutAssignmentInput>
    connectOrCreate?: classroomCreateOrConnectWithoutAssignmentInput
    upsert?: classroomUpsertWithoutAssignmentInput
    connect?: classroomWhereUniqueInput
    update?: XOR<XOR<classroomUpdateToOneWithWhereWithoutAssignmentInput, classroomUpdateWithoutAssignmentInput>, classroomUncheckedUpdateWithoutAssignmentInput>
  }

  export type assignment_submissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput> | assignment_submissionCreateWithoutAssignmentInput[] | assignment_submissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutAssignmentInput | assignment_submissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: assignment_submissionUpsertWithWhereUniqueWithoutAssignmentInput | assignment_submissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: assignment_submissionCreateManyAssignmentInputEnvelope
    set?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    disconnect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    delete?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    update?: assignment_submissionUpdateWithWhereUniqueWithoutAssignmentInput | assignment_submissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: assignment_submissionUpdateManyWithWhereWithoutAssignmentInput | assignment_submissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
  }

  export type questionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput> | questionCreateWithoutAssignmentInput[] | questionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: questionCreateOrConnectWithoutAssignmentInput | questionCreateOrConnectWithoutAssignmentInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutAssignmentInput | questionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: questionCreateManyAssignmentInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutAssignmentInput | questionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: questionUpdateManyWithWhereWithoutAssignmentInput | questionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type assignment_submissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput> | assignment_submissionCreateWithoutAssignmentInput[] | assignment_submissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutAssignmentInput | assignment_submissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: assignment_submissionUpsertWithWhereUniqueWithoutAssignmentInput | assignment_submissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: assignment_submissionCreateManyAssignmentInputEnvelope
    set?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    disconnect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    delete?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    update?: assignment_submissionUpdateWithWhereUniqueWithoutAssignmentInput | assignment_submissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: assignment_submissionUpdateManyWithWhereWithoutAssignmentInput | assignment_submissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
  }

  export type questionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput> | questionCreateWithoutAssignmentInput[] | questionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: questionCreateOrConnectWithoutAssignmentInput | questionCreateOrConnectWithoutAssignmentInput[]
    upsert?: questionUpsertWithWhereUniqueWithoutAssignmentInput | questionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: questionCreateManyAssignmentInputEnvelope
    set?: questionWhereUniqueInput | questionWhereUniqueInput[]
    disconnect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    delete?: questionWhereUniqueInput | questionWhereUniqueInput[]
    connect?: questionWhereUniqueInput | questionWhereUniqueInput[]
    update?: questionUpdateWithWhereUniqueWithoutAssignmentInput | questionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: questionUpdateManyWithWhereWithoutAssignmentInput | questionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: questionScalarWhereInput | questionScalarWhereInput[]
  }

  export type assignmentCreateNestedOneWithoutAssignment_submissionInput = {
    create?: XOR<assignmentCreateWithoutAssignment_submissionInput, assignmentUncheckedCreateWithoutAssignment_submissionInput>
    connectOrCreate?: assignmentCreateOrConnectWithoutAssignment_submissionInput
    connect?: assignmentWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutAssignment_submissionInput = {
    create?: XOR<studentCreateWithoutAssignment_submissionInput, studentUncheckedCreateWithoutAssignment_submissionInput>
    connectOrCreate?: studentCreateOrConnectWithoutAssignment_submissionInput
    connect?: studentWhereUniqueInput
  }

  export type question_submissionCreateNestedManyWithoutAssignment_submissionInput = {
    create?: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput> | question_submissionCreateWithoutAssignment_submissionInput[] | question_submissionUncheckedCreateWithoutAssignment_submissionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutAssignment_submissionInput | question_submissionCreateOrConnectWithoutAssignment_submissionInput[]
    createMany?: question_submissionCreateManyAssignment_submissionInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type question_submissionUncheckedCreateNestedManyWithoutAssignment_submissionInput = {
    create?: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput> | question_submissionCreateWithoutAssignment_submissionInput[] | question_submissionUncheckedCreateWithoutAssignment_submissionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutAssignment_submissionInput | question_submissionCreateOrConnectWithoutAssignment_submissionInput[]
    createMany?: question_submissionCreateManyAssignment_submissionInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type assignmentUpdateOneRequiredWithoutAssignment_submissionNestedInput = {
    create?: XOR<assignmentCreateWithoutAssignment_submissionInput, assignmentUncheckedCreateWithoutAssignment_submissionInput>
    connectOrCreate?: assignmentCreateOrConnectWithoutAssignment_submissionInput
    upsert?: assignmentUpsertWithoutAssignment_submissionInput
    connect?: assignmentWhereUniqueInput
    update?: XOR<XOR<assignmentUpdateToOneWithWhereWithoutAssignment_submissionInput, assignmentUpdateWithoutAssignment_submissionInput>, assignmentUncheckedUpdateWithoutAssignment_submissionInput>
  }

  export type studentUpdateOneRequiredWithoutAssignment_submissionNestedInput = {
    create?: XOR<studentCreateWithoutAssignment_submissionInput, studentUncheckedCreateWithoutAssignment_submissionInput>
    connectOrCreate?: studentCreateOrConnectWithoutAssignment_submissionInput
    upsert?: studentUpsertWithoutAssignment_submissionInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutAssignment_submissionInput, studentUpdateWithoutAssignment_submissionInput>, studentUncheckedUpdateWithoutAssignment_submissionInput>
  }

  export type question_submissionUpdateManyWithoutAssignment_submissionNestedInput = {
    create?: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput> | question_submissionCreateWithoutAssignment_submissionInput[] | question_submissionUncheckedCreateWithoutAssignment_submissionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutAssignment_submissionInput | question_submissionCreateOrConnectWithoutAssignment_submissionInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutAssignment_submissionInput | question_submissionUpsertWithWhereUniqueWithoutAssignment_submissionInput[]
    createMany?: question_submissionCreateManyAssignment_submissionInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutAssignment_submissionInput | question_submissionUpdateWithWhereUniqueWithoutAssignment_submissionInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutAssignment_submissionInput | question_submissionUpdateManyWithWhereWithoutAssignment_submissionInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type question_submissionUncheckedUpdateManyWithoutAssignment_submissionNestedInput = {
    create?: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput> | question_submissionCreateWithoutAssignment_submissionInput[] | question_submissionUncheckedCreateWithoutAssignment_submissionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutAssignment_submissionInput | question_submissionCreateOrConnectWithoutAssignment_submissionInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutAssignment_submissionInput | question_submissionUpsertWithWhereUniqueWithoutAssignment_submissionInput[]
    createMany?: question_submissionCreateManyAssignment_submissionInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutAssignment_submissionInput | question_submissionUpdateWithWhereUniqueWithoutAssignment_submissionInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutAssignment_submissionInput | question_submissionUpdateManyWithWhereWithoutAssignment_submissionInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type assignmentCreateNestedOneWithoutQuestionInput = {
    create?: XOR<assignmentCreateWithoutQuestionInput, assignmentUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: assignmentCreateOrConnectWithoutQuestionInput
    connect?: assignmentWhereUniqueInput
  }

  export type question_submissionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput> | question_submissionCreateWithoutQuestionInput[] | question_submissionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutQuestionInput | question_submissionCreateOrConnectWithoutQuestionInput[]
    createMany?: question_submissionCreateManyQuestionInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type question_submissionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput> | question_submissionCreateWithoutQuestionInput[] | question_submissionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutQuestionInput | question_submissionCreateOrConnectWithoutQuestionInput[]
    createMany?: question_submissionCreateManyQuestionInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type assignmentUpdateOneRequiredWithoutQuestionNestedInput = {
    create?: XOR<assignmentCreateWithoutQuestionInput, assignmentUncheckedCreateWithoutQuestionInput>
    connectOrCreate?: assignmentCreateOrConnectWithoutQuestionInput
    upsert?: assignmentUpsertWithoutQuestionInput
    connect?: assignmentWhereUniqueInput
    update?: XOR<XOR<assignmentUpdateToOneWithWhereWithoutQuestionInput, assignmentUpdateWithoutQuestionInput>, assignmentUncheckedUpdateWithoutQuestionInput>
  }

  export type question_submissionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput> | question_submissionCreateWithoutQuestionInput[] | question_submissionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutQuestionInput | question_submissionCreateOrConnectWithoutQuestionInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutQuestionInput | question_submissionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: question_submissionCreateManyQuestionInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutQuestionInput | question_submissionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutQuestionInput | question_submissionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type question_submissionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput> | question_submissionCreateWithoutQuestionInput[] | question_submissionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutQuestionInput | question_submissionCreateOrConnectWithoutQuestionInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutQuestionInput | question_submissionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: question_submissionCreateManyQuestionInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutQuestionInput | question_submissionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutQuestionInput | question_submissionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type assignment_submissionCreateNestedOneWithoutQuestion_submissionInput = {
    create?: XOR<assignment_submissionCreateWithoutQuestion_submissionInput, assignment_submissionUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutQuestion_submissionInput
    connect?: assignment_submissionWhereUniqueInput
  }

  export type questionCreateNestedOneWithoutQuestion_submissionInput = {
    create?: XOR<questionCreateWithoutQuestion_submissionInput, questionUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestion_submissionInput
    connect?: questionWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutQuestion_submissionInput = {
    create?: XOR<studentCreateWithoutQuestion_submissionInput, studentUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: studentCreateOrConnectWithoutQuestion_submissionInput
    connect?: studentWhereUniqueInput
  }

  export type assignment_submissionUpdateOneRequiredWithoutQuestion_submissionNestedInput = {
    create?: XOR<assignment_submissionCreateWithoutQuestion_submissionInput, assignment_submissionUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutQuestion_submissionInput
    upsert?: assignment_submissionUpsertWithoutQuestion_submissionInput
    connect?: assignment_submissionWhereUniqueInput
    update?: XOR<XOR<assignment_submissionUpdateToOneWithWhereWithoutQuestion_submissionInput, assignment_submissionUpdateWithoutQuestion_submissionInput>, assignment_submissionUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type questionUpdateOneRequiredWithoutQuestion_submissionNestedInput = {
    create?: XOR<questionCreateWithoutQuestion_submissionInput, questionUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: questionCreateOrConnectWithoutQuestion_submissionInput
    upsert?: questionUpsertWithoutQuestion_submissionInput
    connect?: questionWhereUniqueInput
    update?: XOR<XOR<questionUpdateToOneWithWhereWithoutQuestion_submissionInput, questionUpdateWithoutQuestion_submissionInput>, questionUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type studentUpdateOneRequiredWithoutQuestion_submissionNestedInput = {
    create?: XOR<studentCreateWithoutQuestion_submissionInput, studentUncheckedCreateWithoutQuestion_submissionInput>
    connectOrCreate?: studentCreateOrConnectWithoutQuestion_submissionInput
    upsert?: studentUpsertWithoutQuestion_submissionInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutQuestion_submissionInput, studentUpdateWithoutQuestion_submissionInput>, studentUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type student_classroomCreateNestedManyWithoutClassroomInput = {
    create?: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput> | student_classroomCreateWithoutClassroomInput[] | student_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutClassroomInput | student_classroomCreateOrConnectWithoutClassroomInput[]
    createMany?: student_classroomCreateManyClassroomInputEnvelope
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
  }

  export type teacher_classroomCreateNestedManyWithoutClassroomInput = {
    create?: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput> | teacher_classroomCreateWithoutClassroomInput[] | teacher_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutClassroomInput | teacher_classroomCreateOrConnectWithoutClassroomInput[]
    createMany?: teacher_classroomCreateManyClassroomInputEnvelope
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
  }

  export type assignmentCreateNestedManyWithoutClassroomInput = {
    create?: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput> | assignmentCreateWithoutClassroomInput[] | assignmentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: assignmentCreateOrConnectWithoutClassroomInput | assignmentCreateOrConnectWithoutClassroomInput[]
    createMany?: assignmentCreateManyClassroomInputEnvelope
    connect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
  }

  export type student_classroomUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput> | student_classroomCreateWithoutClassroomInput[] | student_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutClassroomInput | student_classroomCreateOrConnectWithoutClassroomInput[]
    createMany?: student_classroomCreateManyClassroomInputEnvelope
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
  }

  export type teacher_classroomUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput> | teacher_classroomCreateWithoutClassroomInput[] | teacher_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutClassroomInput | teacher_classroomCreateOrConnectWithoutClassroomInput[]
    createMany?: teacher_classroomCreateManyClassroomInputEnvelope
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
  }

  export type assignmentUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput> | assignmentCreateWithoutClassroomInput[] | assignmentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: assignmentCreateOrConnectWithoutClassroomInput | assignmentCreateOrConnectWithoutClassroomInput[]
    createMany?: assignmentCreateManyClassroomInputEnvelope
    connect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
  }

  export type student_classroomUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput> | student_classroomCreateWithoutClassroomInput[] | student_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutClassroomInput | student_classroomCreateOrConnectWithoutClassroomInput[]
    upsert?: student_classroomUpsertWithWhereUniqueWithoutClassroomInput | student_classroomUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: student_classroomCreateManyClassroomInputEnvelope
    set?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    disconnect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    delete?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    update?: student_classroomUpdateWithWhereUniqueWithoutClassroomInput | student_classroomUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: student_classroomUpdateManyWithWhereWithoutClassroomInput | student_classroomUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
  }

  export type teacher_classroomUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput> | teacher_classroomCreateWithoutClassroomInput[] | teacher_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutClassroomInput | teacher_classroomCreateOrConnectWithoutClassroomInput[]
    upsert?: teacher_classroomUpsertWithWhereUniqueWithoutClassroomInput | teacher_classroomUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: teacher_classroomCreateManyClassroomInputEnvelope
    set?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    disconnect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    delete?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    update?: teacher_classroomUpdateWithWhereUniqueWithoutClassroomInput | teacher_classroomUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: teacher_classroomUpdateManyWithWhereWithoutClassroomInput | teacher_classroomUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
  }

  export type assignmentUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput> | assignmentCreateWithoutClassroomInput[] | assignmentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: assignmentCreateOrConnectWithoutClassroomInput | assignmentCreateOrConnectWithoutClassroomInput[]
    upsert?: assignmentUpsertWithWhereUniqueWithoutClassroomInput | assignmentUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: assignmentCreateManyClassroomInputEnvelope
    set?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    disconnect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    delete?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    connect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    update?: assignmentUpdateWithWhereUniqueWithoutClassroomInput | assignmentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: assignmentUpdateManyWithWhereWithoutClassroomInput | assignmentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: assignmentScalarWhereInput | assignmentScalarWhereInput[]
  }

  export type student_classroomUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput> | student_classroomCreateWithoutClassroomInput[] | student_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutClassroomInput | student_classroomCreateOrConnectWithoutClassroomInput[]
    upsert?: student_classroomUpsertWithWhereUniqueWithoutClassroomInput | student_classroomUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: student_classroomCreateManyClassroomInputEnvelope
    set?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    disconnect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    delete?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    update?: student_classroomUpdateWithWhereUniqueWithoutClassroomInput | student_classroomUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: student_classroomUpdateManyWithWhereWithoutClassroomInput | student_classroomUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
  }

  export type teacher_classroomUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput> | teacher_classroomCreateWithoutClassroomInput[] | teacher_classroomUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutClassroomInput | teacher_classroomCreateOrConnectWithoutClassroomInput[]
    upsert?: teacher_classroomUpsertWithWhereUniqueWithoutClassroomInput | teacher_classroomUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: teacher_classroomCreateManyClassroomInputEnvelope
    set?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    disconnect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    delete?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    update?: teacher_classroomUpdateWithWhereUniqueWithoutClassroomInput | teacher_classroomUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: teacher_classroomUpdateManyWithWhereWithoutClassroomInput | teacher_classroomUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
  }

  export type assignmentUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput> | assignmentCreateWithoutClassroomInput[] | assignmentUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: assignmentCreateOrConnectWithoutClassroomInput | assignmentCreateOrConnectWithoutClassroomInput[]
    upsert?: assignmentUpsertWithWhereUniqueWithoutClassroomInput | assignmentUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: assignmentCreateManyClassroomInputEnvelope
    set?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    disconnect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    delete?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    connect?: assignmentWhereUniqueInput | assignmentWhereUniqueInput[]
    update?: assignmentUpdateWithWhereUniqueWithoutClassroomInput | assignmentUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: assignmentUpdateManyWithWhereWithoutClassroomInput | assignmentUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: assignmentScalarWhereInput | assignmentScalarWhereInput[]
  }

  export type assignment_submissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput> | assignment_submissionCreateWithoutStudentInput[] | assignment_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutStudentInput | assignment_submissionCreateOrConnectWithoutStudentInput[]
    createMany?: assignment_submissionCreateManyStudentInputEnvelope
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
  }

  export type student_classroomCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput> | student_classroomCreateWithoutStudentInput[] | student_classroomUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutStudentInput | student_classroomCreateOrConnectWithoutStudentInput[]
    createMany?: student_classroomCreateManyStudentInputEnvelope
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
  }

  export type question_submissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput> | question_submissionCreateWithoutStudentInput[] | question_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutStudentInput | question_submissionCreateOrConnectWithoutStudentInput[]
    createMany?: question_submissionCreateManyStudentInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type student_scholarshipCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput> | student_scholarshipCreateWithoutStudentInput[] | student_scholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutStudentInput | student_scholarshipCreateOrConnectWithoutStudentInput[]
    createMany?: student_scholarshipCreateManyStudentInputEnvelope
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutStudentInput = {
    create?: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    connectOrCreate?: userCreateOrConnectWithoutStudentInput
    connect?: userWhereUniqueInput
  }

  export type assignment_submissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput> | assignment_submissionCreateWithoutStudentInput[] | assignment_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutStudentInput | assignment_submissionCreateOrConnectWithoutStudentInput[]
    createMany?: assignment_submissionCreateManyStudentInputEnvelope
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
  }

  export type student_classroomUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput> | student_classroomCreateWithoutStudentInput[] | student_classroomUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutStudentInput | student_classroomCreateOrConnectWithoutStudentInput[]
    createMany?: student_classroomCreateManyStudentInputEnvelope
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
  }

  export type question_submissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput> | question_submissionCreateWithoutStudentInput[] | question_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutStudentInput | question_submissionCreateOrConnectWithoutStudentInput[]
    createMany?: question_submissionCreateManyStudentInputEnvelope
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
  }

  export type student_scholarshipUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput> | student_scholarshipCreateWithoutStudentInput[] | student_scholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutStudentInput | student_scholarshipCreateOrConnectWithoutStudentInput[]
    createMany?: student_scholarshipCreateManyStudentInputEnvelope
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
  }

  export type assignment_submissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput> | assignment_submissionCreateWithoutStudentInput[] | assignment_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutStudentInput | assignment_submissionCreateOrConnectWithoutStudentInput[]
    upsert?: assignment_submissionUpsertWithWhereUniqueWithoutStudentInput | assignment_submissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: assignment_submissionCreateManyStudentInputEnvelope
    set?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    disconnect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    delete?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    update?: assignment_submissionUpdateWithWhereUniqueWithoutStudentInput | assignment_submissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: assignment_submissionUpdateManyWithWhereWithoutStudentInput | assignment_submissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
  }

  export type student_classroomUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput> | student_classroomCreateWithoutStudentInput[] | student_classroomUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutStudentInput | student_classroomCreateOrConnectWithoutStudentInput[]
    upsert?: student_classroomUpsertWithWhereUniqueWithoutStudentInput | student_classroomUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_classroomCreateManyStudentInputEnvelope
    set?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    disconnect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    delete?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    update?: student_classroomUpdateWithWhereUniqueWithoutStudentInput | student_classroomUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_classroomUpdateManyWithWhereWithoutStudentInput | student_classroomUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
  }

  export type question_submissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput> | question_submissionCreateWithoutStudentInput[] | question_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutStudentInput | question_submissionCreateOrConnectWithoutStudentInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutStudentInput | question_submissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: question_submissionCreateManyStudentInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutStudentInput | question_submissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutStudentInput | question_submissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type student_scholarshipUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput> | student_scholarshipCreateWithoutStudentInput[] | student_scholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutStudentInput | student_scholarshipCreateOrConnectWithoutStudentInput[]
    upsert?: student_scholarshipUpsertWithWhereUniqueWithoutStudentInput | student_scholarshipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_scholarshipCreateManyStudentInputEnvelope
    set?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    disconnect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    delete?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    update?: student_scholarshipUpdateWithWhereUniqueWithoutStudentInput | student_scholarshipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_scholarshipUpdateManyWithWhereWithoutStudentInput | student_scholarshipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
  }

  export type userUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    connectOrCreate?: userCreateOrConnectWithoutStudentInput
    upsert?: userUpsertWithoutStudentInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutStudentInput, userUpdateWithoutStudentInput>, userUncheckedUpdateWithoutStudentInput>
  }

  export type assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput> | assignment_submissionCreateWithoutStudentInput[] | assignment_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: assignment_submissionCreateOrConnectWithoutStudentInput | assignment_submissionCreateOrConnectWithoutStudentInput[]
    upsert?: assignment_submissionUpsertWithWhereUniqueWithoutStudentInput | assignment_submissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: assignment_submissionCreateManyStudentInputEnvelope
    set?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    disconnect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    delete?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    connect?: assignment_submissionWhereUniqueInput | assignment_submissionWhereUniqueInput[]
    update?: assignment_submissionUpdateWithWhereUniqueWithoutStudentInput | assignment_submissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: assignment_submissionUpdateManyWithWhereWithoutStudentInput | assignment_submissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
  }

  export type student_classroomUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput> | student_classroomCreateWithoutStudentInput[] | student_classroomUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_classroomCreateOrConnectWithoutStudentInput | student_classroomCreateOrConnectWithoutStudentInput[]
    upsert?: student_classroomUpsertWithWhereUniqueWithoutStudentInput | student_classroomUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_classroomCreateManyStudentInputEnvelope
    set?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    disconnect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    delete?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    connect?: student_classroomWhereUniqueInput | student_classroomWhereUniqueInput[]
    update?: student_classroomUpdateWithWhereUniqueWithoutStudentInput | student_classroomUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_classroomUpdateManyWithWhereWithoutStudentInput | student_classroomUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
  }

  export type question_submissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput> | question_submissionCreateWithoutStudentInput[] | question_submissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: question_submissionCreateOrConnectWithoutStudentInput | question_submissionCreateOrConnectWithoutStudentInput[]
    upsert?: question_submissionUpsertWithWhereUniqueWithoutStudentInput | question_submissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: question_submissionCreateManyStudentInputEnvelope
    set?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    disconnect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    delete?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    connect?: question_submissionWhereUniqueInput | question_submissionWhereUniqueInput[]
    update?: question_submissionUpdateWithWhereUniqueWithoutStudentInput | question_submissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: question_submissionUpdateManyWithWhereWithoutStudentInput | question_submissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
  }

  export type student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput> | student_scholarshipCreateWithoutStudentInput[] | student_scholarshipUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutStudentInput | student_scholarshipCreateOrConnectWithoutStudentInput[]
    upsert?: student_scholarshipUpsertWithWhereUniqueWithoutStudentInput | student_scholarshipUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: student_scholarshipCreateManyStudentInputEnvelope
    set?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    disconnect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    delete?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    update?: student_scholarshipUpdateWithWhereUniqueWithoutStudentInput | student_scholarshipUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: student_scholarshipUpdateManyWithWhereWithoutStudentInput | student_scholarshipUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
  }

  export type studentCreateNestedOneWithoutStudent_classroomInput = {
    create?: XOR<studentCreateWithoutStudent_classroomInput, studentUncheckedCreateWithoutStudent_classroomInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_classroomInput
    connect?: studentWhereUniqueInput
  }

  export type classroomCreateNestedOneWithoutStudent_classroomInput = {
    create?: XOR<classroomCreateWithoutStudent_classroomInput, classroomUncheckedCreateWithoutStudent_classroomInput>
    connectOrCreate?: classroomCreateOrConnectWithoutStudent_classroomInput
    connect?: classroomWhereUniqueInput
  }

  export type studentUpdateOneRequiredWithoutStudent_classroomNestedInput = {
    create?: XOR<studentCreateWithoutStudent_classroomInput, studentUncheckedCreateWithoutStudent_classroomInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_classroomInput
    upsert?: studentUpsertWithoutStudent_classroomInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutStudent_classroomInput, studentUpdateWithoutStudent_classroomInput>, studentUncheckedUpdateWithoutStudent_classroomInput>
  }

  export type classroomUpdateOneRequiredWithoutStudent_classroomNestedInput = {
    create?: XOR<classroomCreateWithoutStudent_classroomInput, classroomUncheckedCreateWithoutStudent_classroomInput>
    connectOrCreate?: classroomCreateOrConnectWithoutStudent_classroomInput
    upsert?: classroomUpsertWithoutStudent_classroomInput
    connect?: classroomWhereUniqueInput
    update?: XOR<XOR<classroomUpdateToOneWithWhereWithoutStudent_classroomInput, classroomUpdateWithoutStudent_classroomInput>, classroomUncheckedUpdateWithoutStudent_classroomInput>
  }

  export type userCreateNestedOneWithoutTeacherInput = {
    create?: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: userCreateOrConnectWithoutTeacherInput
    connect?: userWhereUniqueInput
  }

  export type teacher_classroomCreateNestedManyWithoutTeacherInput = {
    create?: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput> | teacher_classroomCreateWithoutTeacherInput[] | teacher_classroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutTeacherInput | teacher_classroomCreateOrConnectWithoutTeacherInput[]
    createMany?: teacher_classroomCreateManyTeacherInputEnvelope
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
  }

  export type teacher_classroomUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput> | teacher_classroomCreateWithoutTeacherInput[] | teacher_classroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutTeacherInput | teacher_classroomCreateOrConnectWithoutTeacherInput[]
    createMany?: teacher_classroomCreateManyTeacherInputEnvelope
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: userCreateOrConnectWithoutTeacherInput
    upsert?: userUpsertWithoutTeacherInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutTeacherInput, userUpdateWithoutTeacherInput>, userUncheckedUpdateWithoutTeacherInput>
  }

  export type teacher_classroomUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput> | teacher_classroomCreateWithoutTeacherInput[] | teacher_classroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutTeacherInput | teacher_classroomCreateOrConnectWithoutTeacherInput[]
    upsert?: teacher_classroomUpsertWithWhereUniqueWithoutTeacherInput | teacher_classroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: teacher_classroomCreateManyTeacherInputEnvelope
    set?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    disconnect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    delete?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    update?: teacher_classroomUpdateWithWhereUniqueWithoutTeacherInput | teacher_classroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: teacher_classroomUpdateManyWithWhereWithoutTeacherInput | teacher_classroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
  }

  export type teacher_classroomUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput> | teacher_classroomCreateWithoutTeacherInput[] | teacher_classroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: teacher_classroomCreateOrConnectWithoutTeacherInput | teacher_classroomCreateOrConnectWithoutTeacherInput[]
    upsert?: teacher_classroomUpsertWithWhereUniqueWithoutTeacherInput | teacher_classroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: teacher_classroomCreateManyTeacherInputEnvelope
    set?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    disconnect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    delete?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    connect?: teacher_classroomWhereUniqueInput | teacher_classroomWhereUniqueInput[]
    update?: teacher_classroomUpdateWithWhereUniqueWithoutTeacherInput | teacher_classroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: teacher_classroomUpdateManyWithWhereWithoutTeacherInput | teacher_classroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
  }

  export type teacherCreateNestedOneWithoutTeacher_classroomInput = {
    create?: XOR<teacherCreateWithoutTeacher_classroomInput, teacherUncheckedCreateWithoutTeacher_classroomInput>
    connectOrCreate?: teacherCreateOrConnectWithoutTeacher_classroomInput
    connect?: teacherWhereUniqueInput
  }

  export type classroomCreateNestedOneWithoutTeacher_classroomInput = {
    create?: XOR<classroomCreateWithoutTeacher_classroomInput, classroomUncheckedCreateWithoutTeacher_classroomInput>
    connectOrCreate?: classroomCreateOrConnectWithoutTeacher_classroomInput
    connect?: classroomWhereUniqueInput
  }

  export type teacherUpdateOneRequiredWithoutTeacher_classroomNestedInput = {
    create?: XOR<teacherCreateWithoutTeacher_classroomInput, teacherUncheckedCreateWithoutTeacher_classroomInput>
    connectOrCreate?: teacherCreateOrConnectWithoutTeacher_classroomInput
    upsert?: teacherUpsertWithoutTeacher_classroomInput
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutTeacher_classroomInput, teacherUpdateWithoutTeacher_classroomInput>, teacherUncheckedUpdateWithoutTeacher_classroomInput>
  }

  export type classroomUpdateOneRequiredWithoutTeacher_classroomNestedInput = {
    create?: XOR<classroomCreateWithoutTeacher_classroomInput, classroomUncheckedCreateWithoutTeacher_classroomInput>
    connectOrCreate?: classroomCreateOrConnectWithoutTeacher_classroomInput
    upsert?: classroomUpsertWithoutTeacher_classroomInput
    connect?: classroomWhereUniqueInput
    update?: XOR<XOR<classroomUpdateToOneWithWhereWithoutTeacher_classroomInput, classroomUpdateWithoutTeacher_classroomInput>, classroomUncheckedUpdateWithoutTeacher_classroomInput>
  }

  export type organizationCreateNestedOneWithoutScholarshipInput = {
    create?: XOR<organizationCreateWithoutScholarshipInput, organizationUncheckedCreateWithoutScholarshipInput>
    connectOrCreate?: organizationCreateOrConnectWithoutScholarshipInput
    connect?: organizationWhereUniqueInput
  }

  export type student_scholarshipCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput> | student_scholarshipCreateWithoutScholarshipInput[] | student_scholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutScholarshipInput | student_scholarshipCreateOrConnectWithoutScholarshipInput[]
    createMany?: student_scholarshipCreateManyScholarshipInputEnvelope
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
  }

  export type student_scholarshipUncheckedCreateNestedManyWithoutScholarshipInput = {
    create?: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput> | student_scholarshipCreateWithoutScholarshipInput[] | student_scholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutScholarshipInput | student_scholarshipCreateOrConnectWithoutScholarshipInput[]
    createMany?: student_scholarshipCreateManyScholarshipInputEnvelope
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type organizationUpdateOneRequiredWithoutScholarshipNestedInput = {
    create?: XOR<organizationCreateWithoutScholarshipInput, organizationUncheckedCreateWithoutScholarshipInput>
    connectOrCreate?: organizationCreateOrConnectWithoutScholarshipInput
    upsert?: organizationUpsertWithoutScholarshipInput
    connect?: organizationWhereUniqueInput
    update?: XOR<XOR<organizationUpdateToOneWithWhereWithoutScholarshipInput, organizationUpdateWithoutScholarshipInput>, organizationUncheckedUpdateWithoutScholarshipInput>
  }

  export type student_scholarshipUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput> | student_scholarshipCreateWithoutScholarshipInput[] | student_scholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutScholarshipInput | student_scholarshipCreateOrConnectWithoutScholarshipInput[]
    upsert?: student_scholarshipUpsertWithWhereUniqueWithoutScholarshipInput | student_scholarshipUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: student_scholarshipCreateManyScholarshipInputEnvelope
    set?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    disconnect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    delete?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    update?: student_scholarshipUpdateWithWhereUniqueWithoutScholarshipInput | student_scholarshipUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: student_scholarshipUpdateManyWithWhereWithoutScholarshipInput | student_scholarshipUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
  }

  export type student_scholarshipUncheckedUpdateManyWithoutScholarshipNestedInput = {
    create?: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput> | student_scholarshipCreateWithoutScholarshipInput[] | student_scholarshipUncheckedCreateWithoutScholarshipInput[]
    connectOrCreate?: student_scholarshipCreateOrConnectWithoutScholarshipInput | student_scholarshipCreateOrConnectWithoutScholarshipInput[]
    upsert?: student_scholarshipUpsertWithWhereUniqueWithoutScholarshipInput | student_scholarshipUpsertWithWhereUniqueWithoutScholarshipInput[]
    createMany?: student_scholarshipCreateManyScholarshipInputEnvelope
    set?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    disconnect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    delete?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    connect?: student_scholarshipWhereUniqueInput | student_scholarshipWhereUniqueInput[]
    update?: student_scholarshipUpdateWithWhereUniqueWithoutScholarshipInput | student_scholarshipUpdateWithWhereUniqueWithoutScholarshipInput[]
    updateMany?: student_scholarshipUpdateManyWithWhereWithoutScholarshipInput | student_scholarshipUpdateManyWithWhereWithoutScholarshipInput[]
    deleteMany?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
  }

  export type scholarshipCreateNestedOneWithoutStudent_scholarshipInput = {
    create?: XOR<scholarshipCreateWithoutStudent_scholarshipInput, scholarshipUncheckedCreateWithoutStudent_scholarshipInput>
    connectOrCreate?: scholarshipCreateOrConnectWithoutStudent_scholarshipInput
    connect?: scholarshipWhereUniqueInput
  }

  export type studentCreateNestedOneWithoutStudent_scholarshipInput = {
    create?: XOR<studentCreateWithoutStudent_scholarshipInput, studentUncheckedCreateWithoutStudent_scholarshipInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_scholarshipInput
    connect?: studentWhereUniqueInput
  }

  export type scholarshipUpdateOneRequiredWithoutStudent_scholarshipNestedInput = {
    create?: XOR<scholarshipCreateWithoutStudent_scholarshipInput, scholarshipUncheckedCreateWithoutStudent_scholarshipInput>
    connectOrCreate?: scholarshipCreateOrConnectWithoutStudent_scholarshipInput
    upsert?: scholarshipUpsertWithoutStudent_scholarshipInput
    connect?: scholarshipWhereUniqueInput
    update?: XOR<XOR<scholarshipUpdateToOneWithWhereWithoutStudent_scholarshipInput, scholarshipUpdateWithoutStudent_scholarshipInput>, scholarshipUncheckedUpdateWithoutStudent_scholarshipInput>
  }

  export type studentUpdateOneRequiredWithoutStudent_scholarshipNestedInput = {
    create?: XOR<studentCreateWithoutStudent_scholarshipInput, studentUncheckedCreateWithoutStudent_scholarshipInput>
    connectOrCreate?: studentCreateOrConnectWithoutStudent_scholarshipInput
    upsert?: studentUpsertWithoutStudent_scholarshipInput
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutStudent_scholarshipInput, studentUpdateWithoutStudent_scholarshipInput>, studentUncheckedUpdateWithoutStudent_scholarshipInput>
  }

  export type userCreateNestedOneWithoutPostInput = {
    create?: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    connectOrCreate?: userCreateOrConnectWithoutPostInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneWithoutPostNestedInput = {
    create?: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    connectOrCreate?: userCreateOrConnectWithoutPostInput
    upsert?: userUpsertWithoutPostInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPostInput, userUpdateWithoutPostInput>, userUncheckedUpdateWithoutPostInput>
  }

  export type adminCreateNestedOneWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    connect?: adminWhereUniqueInput
  }

  export type user_organizationCreateNestedManyWithoutUserInput = {
    create?: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput> | user_organizationCreateWithoutUserInput[] | user_organizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutUserInput | user_organizationCreateOrConnectWithoutUserInput[]
    createMany?: user_organizationCreateManyUserInputEnvelope
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
  }

  export type studentCreateNestedOneWithoutUserInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
    connectOrCreate?: studentCreateOrConnectWithoutUserInput
    connect?: studentWhereUniqueInput
  }

  export type teacherCreateNestedOneWithoutUserInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput
    connect?: teacherWhereUniqueInput
  }

  export type postCreateNestedManyWithoutAuthorInput = {
    create?: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput> | postCreateWithoutAuthorInput[] | postUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: postCreateOrConnectWithoutAuthorInput | postCreateOrConnectWithoutAuthorInput[]
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
  }

  export type adminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    connect?: adminWhereUniqueInput
  }

  export type user_organizationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput> | user_organizationCreateWithoutUserInput[] | user_organizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutUserInput | user_organizationCreateOrConnectWithoutUserInput[]
    createMany?: user_organizationCreateManyUserInputEnvelope
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
  }

  export type studentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
    connectOrCreate?: studentCreateOrConnectWithoutUserInput
    connect?: studentWhereUniqueInput
  }

  export type teacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput
    connect?: teacherWhereUniqueInput
  }

  export type postUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput> | postCreateWithoutAuthorInput[] | postUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: postCreateOrConnectWithoutAuthorInput | postCreateOrConnectWithoutAuthorInput[]
    createMany?: postCreateManyAuthorInputEnvelope
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type adminUpdateOneWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    upsert?: adminUpsertWithoutUserInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUserInput, adminUpdateWithoutUserInput>, adminUncheckedUpdateWithoutUserInput>
  }

  export type user_organizationUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput> | user_organizationCreateWithoutUserInput[] | user_organizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutUserInput | user_organizationCreateOrConnectWithoutUserInput[]
    upsert?: user_organizationUpsertWithWhereUniqueWithoutUserInput | user_organizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_organizationCreateManyUserInputEnvelope
    set?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    disconnect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    delete?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    update?: user_organizationUpdateWithWhereUniqueWithoutUserInput | user_organizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_organizationUpdateManyWithWhereWithoutUserInput | user_organizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
  }

  export type studentUpdateOneWithoutUserNestedInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
    connectOrCreate?: studentCreateOrConnectWithoutUserInput
    upsert?: studentUpsertWithoutUserInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutUserInput, studentUpdateWithoutUserInput>, studentUncheckedUpdateWithoutUserInput>
  }

  export type teacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput
    upsert?: teacherUpsertWithoutUserInput
    disconnect?: teacherWhereInput | boolean
    delete?: teacherWhereInput | boolean
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutUserInput, teacherUpdateWithoutUserInput>, teacherUncheckedUpdateWithoutUserInput>
  }

  export type postUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput> | postCreateWithoutAuthorInput[] | postUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: postCreateOrConnectWithoutAuthorInput | postCreateOrConnectWithoutAuthorInput[]
    upsert?: postUpsertWithWhereUniqueWithoutAuthorInput | postUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: postCreateManyAuthorInputEnvelope
    set?: postWhereUniqueInput | postWhereUniqueInput[]
    disconnect?: postWhereUniqueInput | postWhereUniqueInput[]
    delete?: postWhereUniqueInput | postWhereUniqueInput[]
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
    update?: postUpdateWithWhereUniqueWithoutAuthorInput | postUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: postUpdateManyWithWhereWithoutAuthorInput | postUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: postScalarWhereInput | postScalarWhereInput[]
  }

  export type adminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    connectOrCreate?: adminCreateOrConnectWithoutUserInput
    upsert?: adminUpsertWithoutUserInput
    disconnect?: adminWhereInput | boolean
    delete?: adminWhereInput | boolean
    connect?: adminWhereUniqueInput
    update?: XOR<XOR<adminUpdateToOneWithWhereWithoutUserInput, adminUpdateWithoutUserInput>, adminUncheckedUpdateWithoutUserInput>
  }

  export type user_organizationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput> | user_organizationCreateWithoutUserInput[] | user_organizationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutUserInput | user_organizationCreateOrConnectWithoutUserInput[]
    upsert?: user_organizationUpsertWithWhereUniqueWithoutUserInput | user_organizationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_organizationCreateManyUserInputEnvelope
    set?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    disconnect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    delete?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    update?: user_organizationUpdateWithWhereUniqueWithoutUserInput | user_organizationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_organizationUpdateManyWithWhereWithoutUserInput | user_organizationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
  }

  export type studentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
    connectOrCreate?: studentCreateOrConnectWithoutUserInput
    upsert?: studentUpsertWithoutUserInput
    disconnect?: studentWhereInput | boolean
    delete?: studentWhereInput | boolean
    connect?: studentWhereUniqueInput
    update?: XOR<XOR<studentUpdateToOneWithWhereWithoutUserInput, studentUpdateWithoutUserInput>, studentUncheckedUpdateWithoutUserInput>
  }

  export type teacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: teacherCreateOrConnectWithoutUserInput
    upsert?: teacherUpsertWithoutUserInput
    disconnect?: teacherWhereInput | boolean
    delete?: teacherWhereInput | boolean
    connect?: teacherWhereUniqueInput
    update?: XOR<XOR<teacherUpdateToOneWithWhereWithoutUserInput, teacherUpdateWithoutUserInput>, teacherUncheckedUpdateWithoutUserInput>
  }

  export type postUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput> | postCreateWithoutAuthorInput[] | postUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: postCreateOrConnectWithoutAuthorInput | postCreateOrConnectWithoutAuthorInput[]
    upsert?: postUpsertWithWhereUniqueWithoutAuthorInput | postUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: postCreateManyAuthorInputEnvelope
    set?: postWhereUniqueInput | postWhereUniqueInput[]
    disconnect?: postWhereUniqueInput | postWhereUniqueInput[]
    delete?: postWhereUniqueInput | postWhereUniqueInput[]
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
    update?: postUpdateWithWhereUniqueWithoutAuthorInput | postUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: postUpdateManyWithWhereWithoutAuthorInput | postUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: postScalarWhereInput | postScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutAdminInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    connectOrCreate?: userCreateOrConnectWithoutAdminInput
    upsert?: userUpsertWithoutAdminInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutAdminInput, userUpdateWithoutAdminInput>, userUncheckedUpdateWithoutAdminInput>
  }

  export type scholarshipCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput> | scholarshipCreateWithoutOrganizationInput[] | scholarshipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: scholarshipCreateOrConnectWithoutOrganizationInput | scholarshipCreateOrConnectWithoutOrganizationInput[]
    createMany?: scholarshipCreateManyOrganizationInputEnvelope
    connect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
  }

  export type user_organizationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput> | user_organizationCreateWithoutOrganizationInput[] | user_organizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutOrganizationInput | user_organizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: user_organizationCreateManyOrganizationInputEnvelope
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
  }

  export type scholarshipUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput> | scholarshipCreateWithoutOrganizationInput[] | scholarshipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: scholarshipCreateOrConnectWithoutOrganizationInput | scholarshipCreateOrConnectWithoutOrganizationInput[]
    createMany?: scholarshipCreateManyOrganizationInputEnvelope
    connect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
  }

  export type user_organizationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput> | user_organizationCreateWithoutOrganizationInput[] | user_organizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutOrganizationInput | user_organizationCreateOrConnectWithoutOrganizationInput[]
    createMany?: user_organizationCreateManyOrganizationInputEnvelope
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
  }

  export type scholarshipUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput> | scholarshipCreateWithoutOrganizationInput[] | scholarshipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: scholarshipCreateOrConnectWithoutOrganizationInput | scholarshipCreateOrConnectWithoutOrganizationInput[]
    upsert?: scholarshipUpsertWithWhereUniqueWithoutOrganizationInput | scholarshipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: scholarshipCreateManyOrganizationInputEnvelope
    set?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    disconnect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    delete?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    connect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    update?: scholarshipUpdateWithWhereUniqueWithoutOrganizationInput | scholarshipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: scholarshipUpdateManyWithWhereWithoutOrganizationInput | scholarshipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: scholarshipScalarWhereInput | scholarshipScalarWhereInput[]
  }

  export type user_organizationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput> | user_organizationCreateWithoutOrganizationInput[] | user_organizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutOrganizationInput | user_organizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: user_organizationUpsertWithWhereUniqueWithoutOrganizationInput | user_organizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: user_organizationCreateManyOrganizationInputEnvelope
    set?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    disconnect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    delete?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    update?: user_organizationUpdateWithWhereUniqueWithoutOrganizationInput | user_organizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: user_organizationUpdateManyWithWhereWithoutOrganizationInput | user_organizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
  }

  export type scholarshipUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput> | scholarshipCreateWithoutOrganizationInput[] | scholarshipUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: scholarshipCreateOrConnectWithoutOrganizationInput | scholarshipCreateOrConnectWithoutOrganizationInput[]
    upsert?: scholarshipUpsertWithWhereUniqueWithoutOrganizationInput | scholarshipUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: scholarshipCreateManyOrganizationInputEnvelope
    set?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    disconnect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    delete?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    connect?: scholarshipWhereUniqueInput | scholarshipWhereUniqueInput[]
    update?: scholarshipUpdateWithWhereUniqueWithoutOrganizationInput | scholarshipUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: scholarshipUpdateManyWithWhereWithoutOrganizationInput | scholarshipUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: scholarshipScalarWhereInput | scholarshipScalarWhereInput[]
  }

  export type user_organizationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput> | user_organizationCreateWithoutOrganizationInput[] | user_organizationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: user_organizationCreateOrConnectWithoutOrganizationInput | user_organizationCreateOrConnectWithoutOrganizationInput[]
    upsert?: user_organizationUpsertWithWhereUniqueWithoutOrganizationInput | user_organizationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: user_organizationCreateManyOrganizationInputEnvelope
    set?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    disconnect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    delete?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    connect?: user_organizationWhereUniqueInput | user_organizationWhereUniqueInput[]
    update?: user_organizationUpdateWithWhereUniqueWithoutOrganizationInput | user_organizationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: user_organizationUpdateManyWithWhereWithoutOrganizationInput | user_organizationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
  }

  export type organizationCreateNestedOneWithoutUser_organizationInput = {
    create?: XOR<organizationCreateWithoutUser_organizationInput, organizationUncheckedCreateWithoutUser_organizationInput>
    connectOrCreate?: organizationCreateOrConnectWithoutUser_organizationInput
    connect?: organizationWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUser_organizationInput = {
    create?: XOR<userCreateWithoutUser_organizationInput, userUncheckedCreateWithoutUser_organizationInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_organizationInput
    connect?: userWhereUniqueInput
  }

  export type organizationUpdateOneRequiredWithoutUser_organizationNestedInput = {
    create?: XOR<organizationCreateWithoutUser_organizationInput, organizationUncheckedCreateWithoutUser_organizationInput>
    connectOrCreate?: organizationCreateOrConnectWithoutUser_organizationInput
    upsert?: organizationUpsertWithoutUser_organizationInput
    connect?: organizationWhereUniqueInput
    update?: XOR<XOR<organizationUpdateToOneWithWhereWithoutUser_organizationInput, organizationUpdateWithoutUser_organizationInput>, organizationUncheckedUpdateWithoutUser_organizationInput>
  }

  export type userUpdateOneRequiredWithoutUser_organizationNestedInput = {
    create?: XOR<userCreateWithoutUser_organizationInput, userUncheckedCreateWithoutUser_organizationInput>
    connectOrCreate?: userCreateOrConnectWithoutUser_organizationInput
    upsert?: userUpsertWithoutUser_organizationInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUser_organizationInput, userUpdateWithoutUser_organizationInput>, userUncheckedUpdateWithoutUser_organizationInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type classroomCreateWithoutAssignmentInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomCreateNestedManyWithoutClassroomInput
    teacher_classroom?: teacher_classroomCreateNestedManyWithoutClassroomInput
  }

  export type classroomUncheckedCreateWithoutAssignmentInput = {
    classroom_id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutClassroomInput
    teacher_classroom?: teacher_classroomUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type classroomCreateOrConnectWithoutAssignmentInput = {
    where: classroomWhereUniqueInput
    create: XOR<classroomCreateWithoutAssignmentInput, classroomUncheckedCreateWithoutAssignmentInput>
  }

  export type assignment_submissionCreateWithoutAssignmentInput = {
    s3_path: string
    submitted_at?: Date | string | null
    student: studentCreateNestedOneWithoutAssignment_submissionInput
    question_submission?: question_submissionCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionUncheckedCreateWithoutAssignmentInput = {
    assignment_submission_id?: number
    student_id: number
    s3_path: string
    submitted_at?: Date | string | null
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionCreateOrConnectWithoutAssignmentInput = {
    where: assignment_submissionWhereUniqueInput
    create: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput>
  }

  export type assignment_submissionCreateManyAssignmentInputEnvelope = {
    data: assignment_submissionCreateManyAssignmentInput | assignment_submissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type questionCreateWithoutAssignmentInput = {
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
    question_submission?: question_submissionCreateNestedManyWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutAssignmentInput = {
    question_id?: number
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type questionCreateOrConnectWithoutAssignmentInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput>
  }

  export type questionCreateManyAssignmentInputEnvelope = {
    data: questionCreateManyAssignmentInput | questionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type classroomUpsertWithoutAssignmentInput = {
    update: XOR<classroomUpdateWithoutAssignmentInput, classroomUncheckedUpdateWithoutAssignmentInput>
    create: XOR<classroomCreateWithoutAssignmentInput, classroomUncheckedCreateWithoutAssignmentInput>
    where?: classroomWhereInput
  }

  export type classroomUpdateToOneWithWhereWithoutAssignmentInput = {
    where?: classroomWhereInput
    data: XOR<classroomUpdateWithoutAssignmentInput, classroomUncheckedUpdateWithoutAssignmentInput>
  }

  export type classroomUpdateWithoutAssignmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUpdateManyWithoutClassroomNestedInput
    teacher_classroom?: teacher_classroomUpdateManyWithoutClassroomNestedInput
  }

  export type classroomUncheckedUpdateWithoutAssignmentInput = {
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUncheckedUpdateManyWithoutClassroomNestedInput
    teacher_classroom?: teacher_classroomUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type assignment_submissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: assignment_submissionWhereUniqueInput
    update: XOR<assignment_submissionUpdateWithoutAssignmentInput, assignment_submissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<assignment_submissionCreateWithoutAssignmentInput, assignment_submissionUncheckedCreateWithoutAssignmentInput>
  }

  export type assignment_submissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: assignment_submissionWhereUniqueInput
    data: XOR<assignment_submissionUpdateWithoutAssignmentInput, assignment_submissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type assignment_submissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: assignment_submissionScalarWhereInput
    data: XOR<assignment_submissionUpdateManyMutationInput, assignment_submissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type assignment_submissionScalarWhereInput = {
    AND?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
    OR?: assignment_submissionScalarWhereInput[]
    NOT?: assignment_submissionScalarWhereInput | assignment_submissionScalarWhereInput[]
    assignment_submission_id?: IntFilter<"assignment_submission"> | number
    assignment_id?: IntFilter<"assignment_submission"> | number
    student_id?: IntFilter<"assignment_submission"> | number
    s3_path?: StringFilter<"assignment_submission"> | string
    submitted_at?: DateTimeNullableFilter<"assignment_submission"> | Date | string | null
  }

  export type questionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: questionWhereUniqueInput
    update: XOR<questionUpdateWithoutAssignmentInput, questionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<questionCreateWithoutAssignmentInput, questionUncheckedCreateWithoutAssignmentInput>
  }

  export type questionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: questionWhereUniqueInput
    data: XOR<questionUpdateWithoutAssignmentInput, questionUncheckedUpdateWithoutAssignmentInput>
  }

  export type questionUpdateManyWithWhereWithoutAssignmentInput = {
    where: questionScalarWhereInput
    data: XOR<questionUpdateManyMutationInput, questionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type questionScalarWhereInput = {
    AND?: questionScalarWhereInput | questionScalarWhereInput[]
    OR?: questionScalarWhereInput[]
    NOT?: questionScalarWhereInput | questionScalarWhereInput[]
    question_id?: IntFilter<"question"> | number
    assignment_id?: IntFilter<"question"> | number
    question_number?: IntNullableFilter<"question"> | number | null
    name?: StringNullableFilter<"question"> | string | null
    prompt?: StringNullableFilter<"question"> | string | null
    example_solution_s3_path?: StringNullableFilter<"question"> | string | null
    accepted_file_types?: StringNullableFilter<"question"> | string | null
    created_at?: DateTimeNullableFilter<"question"> | Date | string | null
  }

  export type assignmentCreateWithoutAssignment_submissionInput = {
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    classroom: classroomCreateNestedOneWithoutAssignmentInput
    question?: questionCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentUncheckedCreateWithoutAssignment_submissionInput = {
    assignment_id?: number
    classroom_id: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    question?: questionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentCreateOrConnectWithoutAssignment_submissionInput = {
    where: assignmentWhereUniqueInput
    create: XOR<assignmentCreateWithoutAssignment_submissionInput, assignmentUncheckedCreateWithoutAssignment_submissionInput>
  }

  export type studentCreateWithoutAssignment_submissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutStudentInput
    user: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutAssignment_submissionInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutAssignment_submissionInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutAssignment_submissionInput, studentUncheckedCreateWithoutAssignment_submissionInput>
  }

  export type question_submissionCreateWithoutAssignment_submissionInput = {
    s3_path: string
    created_at?: Date | string | null
    question: questionCreateNestedOneWithoutQuestion_submissionInput
    student: studentCreateNestedOneWithoutQuestion_submissionInput
  }

  export type question_submissionUncheckedCreateWithoutAssignment_submissionInput = {
    question_submission_id?: number
    question_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionCreateOrConnectWithoutAssignment_submissionInput = {
    where: question_submissionWhereUniqueInput
    create: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput>
  }

  export type question_submissionCreateManyAssignment_submissionInputEnvelope = {
    data: question_submissionCreateManyAssignment_submissionInput | question_submissionCreateManyAssignment_submissionInput[]
    skipDuplicates?: boolean
  }

  export type assignmentUpsertWithoutAssignment_submissionInput = {
    update: XOR<assignmentUpdateWithoutAssignment_submissionInput, assignmentUncheckedUpdateWithoutAssignment_submissionInput>
    create: XOR<assignmentCreateWithoutAssignment_submissionInput, assignmentUncheckedCreateWithoutAssignment_submissionInput>
    where?: assignmentWhereInput
  }

  export type assignmentUpdateToOneWithWhereWithoutAssignment_submissionInput = {
    where?: assignmentWhereInput
    data: XOR<assignmentUpdateWithoutAssignment_submissionInput, assignmentUncheckedUpdateWithoutAssignment_submissionInput>
  }

  export type assignmentUpdateWithoutAssignment_submissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: classroomUpdateOneRequiredWithoutAssignmentNestedInput
    question?: questionUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentUncheckedUpdateWithoutAssignment_submissionInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: questionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type studentUpsertWithoutAssignment_submissionInput = {
    update: XOR<studentUpdateWithoutAssignment_submissionInput, studentUncheckedUpdateWithoutAssignment_submissionInput>
    create: XOR<studentCreateWithoutAssignment_submissionInput, studentUncheckedCreateWithoutAssignment_submissionInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutAssignment_submissionInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutAssignment_submissionInput, studentUncheckedUpdateWithoutAssignment_submissionInput>
  }

  export type studentUpdateWithoutAssignment_submissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutStudentNestedInput
    user?: userUpdateOneRequiredWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutAssignment_submissionInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUncheckedUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type question_submissionUpsertWithWhereUniqueWithoutAssignment_submissionInput = {
    where: question_submissionWhereUniqueInput
    update: XOR<question_submissionUpdateWithoutAssignment_submissionInput, question_submissionUncheckedUpdateWithoutAssignment_submissionInput>
    create: XOR<question_submissionCreateWithoutAssignment_submissionInput, question_submissionUncheckedCreateWithoutAssignment_submissionInput>
  }

  export type question_submissionUpdateWithWhereUniqueWithoutAssignment_submissionInput = {
    where: question_submissionWhereUniqueInput
    data: XOR<question_submissionUpdateWithoutAssignment_submissionInput, question_submissionUncheckedUpdateWithoutAssignment_submissionInput>
  }

  export type question_submissionUpdateManyWithWhereWithoutAssignment_submissionInput = {
    where: question_submissionScalarWhereInput
    data: XOR<question_submissionUpdateManyMutationInput, question_submissionUncheckedUpdateManyWithoutAssignment_submissionInput>
  }

  export type question_submissionScalarWhereInput = {
    AND?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
    OR?: question_submissionScalarWhereInput[]
    NOT?: question_submissionScalarWhereInput | question_submissionScalarWhereInput[]
    question_submission_id?: IntFilter<"question_submission"> | number
    assignment_submission_id?: IntFilter<"question_submission"> | number
    question_id?: IntFilter<"question_submission"> | number
    student_id?: IntFilter<"question_submission"> | number
    s3_path?: StringFilter<"question_submission"> | string
    created_at?: DateTimeNullableFilter<"question_submission"> | Date | string | null
  }

  export type assignmentCreateWithoutQuestionInput = {
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    classroom: classroomCreateNestedOneWithoutAssignmentInput
    assignment_submission?: assignment_submissionCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentUncheckedCreateWithoutQuestionInput = {
    assignment_id?: number
    classroom_id: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentCreateOrConnectWithoutQuestionInput = {
    where: assignmentWhereUniqueInput
    create: XOR<assignmentCreateWithoutQuestionInput, assignmentUncheckedCreateWithoutQuestionInput>
  }

  export type question_submissionCreateWithoutQuestionInput = {
    s3_path: string
    created_at?: Date | string | null
    assignment_submission: assignment_submissionCreateNestedOneWithoutQuestion_submissionInput
    student: studentCreateNestedOneWithoutQuestion_submissionInput
  }

  export type question_submissionUncheckedCreateWithoutQuestionInput = {
    question_submission_id?: number
    assignment_submission_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionCreateOrConnectWithoutQuestionInput = {
    where: question_submissionWhereUniqueInput
    create: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput>
  }

  export type question_submissionCreateManyQuestionInputEnvelope = {
    data: question_submissionCreateManyQuestionInput | question_submissionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type assignmentUpsertWithoutQuestionInput = {
    update: XOR<assignmentUpdateWithoutQuestionInput, assignmentUncheckedUpdateWithoutQuestionInput>
    create: XOR<assignmentCreateWithoutQuestionInput, assignmentUncheckedCreateWithoutQuestionInput>
    where?: assignmentWhereInput
  }

  export type assignmentUpdateToOneWithWhereWithoutQuestionInput = {
    where?: assignmentWhereInput
    data: XOR<assignmentUpdateWithoutQuestionInput, assignmentUncheckedUpdateWithoutQuestionInput>
  }

  export type assignmentUpdateWithoutQuestionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classroom?: classroomUpdateOneRequiredWithoutAssignmentNestedInput
    assignment_submission?: assignment_submissionUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentUncheckedUpdateWithoutQuestionInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type question_submissionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: question_submissionWhereUniqueInput
    update: XOR<question_submissionUpdateWithoutQuestionInput, question_submissionUncheckedUpdateWithoutQuestionInput>
    create: XOR<question_submissionCreateWithoutQuestionInput, question_submissionUncheckedCreateWithoutQuestionInput>
  }

  export type question_submissionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: question_submissionWhereUniqueInput
    data: XOR<question_submissionUpdateWithoutQuestionInput, question_submissionUncheckedUpdateWithoutQuestionInput>
  }

  export type question_submissionUpdateManyWithWhereWithoutQuestionInput = {
    where: question_submissionScalarWhereInput
    data: XOR<question_submissionUpdateManyMutationInput, question_submissionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type assignment_submissionCreateWithoutQuestion_submissionInput = {
    s3_path: string
    submitted_at?: Date | string | null
    assignment: assignmentCreateNestedOneWithoutAssignment_submissionInput
    student: studentCreateNestedOneWithoutAssignment_submissionInput
  }

  export type assignment_submissionUncheckedCreateWithoutQuestion_submissionInput = {
    assignment_submission_id?: number
    assignment_id: number
    student_id: number
    s3_path: string
    submitted_at?: Date | string | null
  }

  export type assignment_submissionCreateOrConnectWithoutQuestion_submissionInput = {
    where: assignment_submissionWhereUniqueInput
    create: XOR<assignment_submissionCreateWithoutQuestion_submissionInput, assignment_submissionUncheckedCreateWithoutQuestion_submissionInput>
  }

  export type questionCreateWithoutQuestion_submissionInput = {
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
    assignment: assignmentCreateNestedOneWithoutQuestionInput
  }

  export type questionUncheckedCreateWithoutQuestion_submissionInput = {
    question_id?: number
    assignment_id: number
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
  }

  export type questionCreateOrConnectWithoutQuestion_submissionInput = {
    where: questionWhereUniqueInput
    create: XOR<questionCreateWithoutQuestion_submissionInput, questionUncheckedCreateWithoutQuestion_submissionInput>
  }

  export type studentCreateWithoutQuestion_submissionInput = {
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutStudentInput
    user: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutQuestion_submissionInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutQuestion_submissionInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutQuestion_submissionInput, studentUncheckedCreateWithoutQuestion_submissionInput>
  }

  export type assignment_submissionUpsertWithoutQuestion_submissionInput = {
    update: XOR<assignment_submissionUpdateWithoutQuestion_submissionInput, assignment_submissionUncheckedUpdateWithoutQuestion_submissionInput>
    create: XOR<assignment_submissionCreateWithoutQuestion_submissionInput, assignment_submissionUncheckedCreateWithoutQuestion_submissionInput>
    where?: assignment_submissionWhereInput
  }

  export type assignment_submissionUpdateToOneWithWhereWithoutQuestion_submissionInput = {
    where?: assignment_submissionWhereInput
    data: XOR<assignment_submissionUpdateWithoutQuestion_submissionInput, assignment_submissionUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type assignment_submissionUpdateWithoutQuestion_submissionInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: assignmentUpdateOneRequiredWithoutAssignment_submissionNestedInput
    student?: studentUpdateOneRequiredWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateWithoutQuestion_submissionInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionUpsertWithoutQuestion_submissionInput = {
    update: XOR<questionUpdateWithoutQuestion_submissionInput, questionUncheckedUpdateWithoutQuestion_submissionInput>
    create: XOR<questionCreateWithoutQuestion_submissionInput, questionUncheckedCreateWithoutQuestion_submissionInput>
    where?: questionWhereInput
  }

  export type questionUpdateToOneWithWhereWithoutQuestion_submissionInput = {
    where?: questionWhereInput
    data: XOR<questionUpdateWithoutQuestion_submissionInput, questionUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type questionUpdateWithoutQuestion_submissionInput = {
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: assignmentUpdateOneRequiredWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutQuestion_submissionInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentUpsertWithoutQuestion_submissionInput = {
    update: XOR<studentUpdateWithoutQuestion_submissionInput, studentUncheckedUpdateWithoutQuestion_submissionInput>
    create: XOR<studentCreateWithoutQuestion_submissionInput, studentUncheckedCreateWithoutQuestion_submissionInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutQuestion_submissionInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutQuestion_submissionInput, studentUncheckedUpdateWithoutQuestion_submissionInput>
  }

  export type studentUpdateWithoutQuestion_submissionInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutStudentNestedInput
    user?: userUpdateOneRequiredWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutQuestion_submissionInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUncheckedUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type student_classroomCreateWithoutClassroomInput = {
    created_at?: Date | string
    updated_at?: Date | string
    student: studentCreateNestedOneWithoutStudent_classroomInput
  }

  export type student_classroomUncheckedCreateWithoutClassroomInput = {
    student_classroom_id?: number
    student_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type student_classroomCreateOrConnectWithoutClassroomInput = {
    where: student_classroomWhereUniqueInput
    create: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput>
  }

  export type student_classroomCreateManyClassroomInputEnvelope = {
    data: student_classroomCreateManyClassroomInput | student_classroomCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type teacher_classroomCreateWithoutClassroomInput = {
    created_at?: Date | string
    updated_at?: Date | string
    teacher: teacherCreateNestedOneWithoutTeacher_classroomInput
  }

  export type teacher_classroomUncheckedCreateWithoutClassroomInput = {
    teacher_classrood_id?: number
    teacher_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomCreateOrConnectWithoutClassroomInput = {
    where: teacher_classroomWhereUniqueInput
    create: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput>
  }

  export type teacher_classroomCreateManyClassroomInputEnvelope = {
    data: teacher_classroomCreateManyClassroomInput | teacher_classroomCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type assignmentCreateWithoutClassroomInput = {
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    assignment_submission?: assignment_submissionCreateNestedManyWithoutAssignmentInput
    question?: questionCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentUncheckedCreateWithoutClassroomInput = {
    assignment_id?: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutAssignmentInput
    question?: questionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type assignmentCreateOrConnectWithoutClassroomInput = {
    where: assignmentWhereUniqueInput
    create: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput>
  }

  export type assignmentCreateManyClassroomInputEnvelope = {
    data: assignmentCreateManyClassroomInput | assignmentCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type student_classroomUpsertWithWhereUniqueWithoutClassroomInput = {
    where: student_classroomWhereUniqueInput
    update: XOR<student_classroomUpdateWithoutClassroomInput, student_classroomUncheckedUpdateWithoutClassroomInput>
    create: XOR<student_classroomCreateWithoutClassroomInput, student_classroomUncheckedCreateWithoutClassroomInput>
  }

  export type student_classroomUpdateWithWhereUniqueWithoutClassroomInput = {
    where: student_classroomWhereUniqueInput
    data: XOR<student_classroomUpdateWithoutClassroomInput, student_classroomUncheckedUpdateWithoutClassroomInput>
  }

  export type student_classroomUpdateManyWithWhereWithoutClassroomInput = {
    where: student_classroomScalarWhereInput
    data: XOR<student_classroomUpdateManyMutationInput, student_classroomUncheckedUpdateManyWithoutClassroomInput>
  }

  export type student_classroomScalarWhereInput = {
    AND?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
    OR?: student_classroomScalarWhereInput[]
    NOT?: student_classroomScalarWhereInput | student_classroomScalarWhereInput[]
    student_classroom_id?: IntFilter<"student_classroom"> | number
    student_id?: IntFilter<"student_classroom"> | number
    classroom_id?: IntFilter<"student_classroom"> | number
    created_at?: DateTimeFilter<"student_classroom"> | Date | string
    updated_at?: DateTimeFilter<"student_classroom"> | Date | string
  }

  export type teacher_classroomUpsertWithWhereUniqueWithoutClassroomInput = {
    where: teacher_classroomWhereUniqueInput
    update: XOR<teacher_classroomUpdateWithoutClassroomInput, teacher_classroomUncheckedUpdateWithoutClassroomInput>
    create: XOR<teacher_classroomCreateWithoutClassroomInput, teacher_classroomUncheckedCreateWithoutClassroomInput>
  }

  export type teacher_classroomUpdateWithWhereUniqueWithoutClassroomInput = {
    where: teacher_classroomWhereUniqueInput
    data: XOR<teacher_classroomUpdateWithoutClassroomInput, teacher_classroomUncheckedUpdateWithoutClassroomInput>
  }

  export type teacher_classroomUpdateManyWithWhereWithoutClassroomInput = {
    where: teacher_classroomScalarWhereInput
    data: XOR<teacher_classroomUpdateManyMutationInput, teacher_classroomUncheckedUpdateManyWithoutClassroomInput>
  }

  export type teacher_classroomScalarWhereInput = {
    AND?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
    OR?: teacher_classroomScalarWhereInput[]
    NOT?: teacher_classroomScalarWhereInput | teacher_classroomScalarWhereInput[]
    teacher_classrood_id?: IntFilter<"teacher_classroom"> | number
    teacher_id?: IntFilter<"teacher_classroom"> | number
    classroom_id?: IntFilter<"teacher_classroom"> | number
    created_at?: DateTimeFilter<"teacher_classroom"> | Date | string
    updated_at?: DateTimeFilter<"teacher_classroom"> | Date | string
  }

  export type assignmentUpsertWithWhereUniqueWithoutClassroomInput = {
    where: assignmentWhereUniqueInput
    update: XOR<assignmentUpdateWithoutClassroomInput, assignmentUncheckedUpdateWithoutClassroomInput>
    create: XOR<assignmentCreateWithoutClassroomInput, assignmentUncheckedCreateWithoutClassroomInput>
  }

  export type assignmentUpdateWithWhereUniqueWithoutClassroomInput = {
    where: assignmentWhereUniqueInput
    data: XOR<assignmentUpdateWithoutClassroomInput, assignmentUncheckedUpdateWithoutClassroomInput>
  }

  export type assignmentUpdateManyWithWhereWithoutClassroomInput = {
    where: assignmentScalarWhereInput
    data: XOR<assignmentUpdateManyMutationInput, assignmentUncheckedUpdateManyWithoutClassroomInput>
  }

  export type assignmentScalarWhereInput = {
    AND?: assignmentScalarWhereInput | assignmentScalarWhereInput[]
    OR?: assignmentScalarWhereInput[]
    NOT?: assignmentScalarWhereInput | assignmentScalarWhereInput[]
    assignment_id?: IntFilter<"assignment"> | number
    classroom_id?: IntFilter<"assignment"> | number
    name?: StringFilter<"assignment"> | string
    description?: StringNullableFilter<"assignment"> | string | null
    assignment_number?: IntNullableFilter<"assignment"> | number | null
    due_date?: DateTimeFilter<"assignment"> | Date | string
    created_at?: DateTimeNullableFilter<"assignment"> | Date | string | null
  }

  export type assignment_submissionCreateWithoutStudentInput = {
    s3_path: string
    submitted_at?: Date | string | null
    assignment: assignmentCreateNestedOneWithoutAssignment_submissionInput
    question_submission?: question_submissionCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionUncheckedCreateWithoutStudentInput = {
    assignment_submission_id?: number
    assignment_id: number
    s3_path: string
    submitted_at?: Date | string | null
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutAssignment_submissionInput
  }

  export type assignment_submissionCreateOrConnectWithoutStudentInput = {
    where: assignment_submissionWhereUniqueInput
    create: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput>
  }

  export type assignment_submissionCreateManyStudentInputEnvelope = {
    data: assignment_submissionCreateManyStudentInput | assignment_submissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type student_classroomCreateWithoutStudentInput = {
    created_at?: Date | string
    updated_at?: Date | string
    classroom: classroomCreateNestedOneWithoutStudent_classroomInput
  }

  export type student_classroomUncheckedCreateWithoutStudentInput = {
    student_classroom_id?: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type student_classroomCreateOrConnectWithoutStudentInput = {
    where: student_classroomWhereUniqueInput
    create: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput>
  }

  export type student_classroomCreateManyStudentInputEnvelope = {
    data: student_classroomCreateManyStudentInput | student_classroomCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type question_submissionCreateWithoutStudentInput = {
    s3_path: string
    created_at?: Date | string | null
    assignment_submission: assignment_submissionCreateNestedOneWithoutQuestion_submissionInput
    question: questionCreateNestedOneWithoutQuestion_submissionInput
  }

  export type question_submissionUncheckedCreateWithoutStudentInput = {
    question_submission_id?: number
    assignment_submission_id: number
    question_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionCreateOrConnectWithoutStudentInput = {
    where: question_submissionWhereUniqueInput
    create: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput>
  }

  export type question_submissionCreateManyStudentInputEnvelope = {
    data: question_submissionCreateManyStudentInput | question_submissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type student_scholarshipCreateWithoutStudentInput = {
    is_bookmarked?: boolean | null
    scholarship: scholarshipCreateNestedOneWithoutStudent_scholarshipInput
  }

  export type student_scholarshipUncheckedCreateWithoutStudentInput = {
    student_scholarship_id?: number
    scholarship_id: number
    is_bookmarked?: boolean | null
  }

  export type student_scholarshipCreateOrConnectWithoutStudentInput = {
    where: student_scholarshipWhereUniqueInput
    create: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput>
  }

  export type student_scholarshipCreateManyStudentInputEnvelope = {
    data: student_scholarshipCreateManyStudentInput | student_scholarshipCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutStudentInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    user_organization?: user_organizationCreateNestedManyWithoutUserInput
    teacher?: teacherCreateNestedOneWithoutUserInput
    post?: postCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateWithoutStudentInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutUserInput
    teacher?: teacherUncheckedCreateNestedOneWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userCreateOrConnectWithoutStudentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
  }

  export type assignment_submissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: assignment_submissionWhereUniqueInput
    update: XOR<assignment_submissionUpdateWithoutStudentInput, assignment_submissionUncheckedUpdateWithoutStudentInput>
    create: XOR<assignment_submissionCreateWithoutStudentInput, assignment_submissionUncheckedCreateWithoutStudentInput>
  }

  export type assignment_submissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: assignment_submissionWhereUniqueInput
    data: XOR<assignment_submissionUpdateWithoutStudentInput, assignment_submissionUncheckedUpdateWithoutStudentInput>
  }

  export type assignment_submissionUpdateManyWithWhereWithoutStudentInput = {
    where: assignment_submissionScalarWhereInput
    data: XOR<assignment_submissionUpdateManyMutationInput, assignment_submissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type student_classroomUpsertWithWhereUniqueWithoutStudentInput = {
    where: student_classroomWhereUniqueInput
    update: XOR<student_classroomUpdateWithoutStudentInput, student_classroomUncheckedUpdateWithoutStudentInput>
    create: XOR<student_classroomCreateWithoutStudentInput, student_classroomUncheckedCreateWithoutStudentInput>
  }

  export type student_classroomUpdateWithWhereUniqueWithoutStudentInput = {
    where: student_classroomWhereUniqueInput
    data: XOR<student_classroomUpdateWithoutStudentInput, student_classroomUncheckedUpdateWithoutStudentInput>
  }

  export type student_classroomUpdateManyWithWhereWithoutStudentInput = {
    where: student_classroomScalarWhereInput
    data: XOR<student_classroomUpdateManyMutationInput, student_classroomUncheckedUpdateManyWithoutStudentInput>
  }

  export type question_submissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: question_submissionWhereUniqueInput
    update: XOR<question_submissionUpdateWithoutStudentInput, question_submissionUncheckedUpdateWithoutStudentInput>
    create: XOR<question_submissionCreateWithoutStudentInput, question_submissionUncheckedCreateWithoutStudentInput>
  }

  export type question_submissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: question_submissionWhereUniqueInput
    data: XOR<question_submissionUpdateWithoutStudentInput, question_submissionUncheckedUpdateWithoutStudentInput>
  }

  export type question_submissionUpdateManyWithWhereWithoutStudentInput = {
    where: question_submissionScalarWhereInput
    data: XOR<question_submissionUpdateManyMutationInput, question_submissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type student_scholarshipUpsertWithWhereUniqueWithoutStudentInput = {
    where: student_scholarshipWhereUniqueInput
    update: XOR<student_scholarshipUpdateWithoutStudentInput, student_scholarshipUncheckedUpdateWithoutStudentInput>
    create: XOR<student_scholarshipCreateWithoutStudentInput, student_scholarshipUncheckedCreateWithoutStudentInput>
  }

  export type student_scholarshipUpdateWithWhereUniqueWithoutStudentInput = {
    where: student_scholarshipWhereUniqueInput
    data: XOR<student_scholarshipUpdateWithoutStudentInput, student_scholarshipUncheckedUpdateWithoutStudentInput>
  }

  export type student_scholarshipUpdateManyWithWhereWithoutStudentInput = {
    where: student_scholarshipScalarWhereInput
    data: XOR<student_scholarshipUpdateManyMutationInput, student_scholarshipUncheckedUpdateManyWithoutStudentInput>
  }

  export type student_scholarshipScalarWhereInput = {
    AND?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
    OR?: student_scholarshipScalarWhereInput[]
    NOT?: student_scholarshipScalarWhereInput | student_scholarshipScalarWhereInput[]
    student_scholarship_id?: IntFilter<"student_scholarship"> | number
    student_id?: IntFilter<"student_scholarship"> | number
    scholarship_id?: IntFilter<"student_scholarship"> | number
    is_bookmarked?: BoolNullableFilter<"student_scholarship"> | boolean | null
  }

  export type userUpsertWithoutStudentInput = {
    update: XOR<userUpdateWithoutStudentInput, userUncheckedUpdateWithoutStudentInput>
    create: XOR<userCreateWithoutStudentInput, userUncheckedCreateWithoutStudentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutStudentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutStudentInput, userUncheckedUpdateWithoutStudentInput>
  }

  export type userUpdateWithoutStudentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUpdateManyWithoutUserNestedInput
    teacher?: teacherUpdateOneWithoutUserNestedInput
    post?: postUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateWithoutStudentInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUncheckedUpdateManyWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateOneWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type studentCreateWithoutStudent_classroomInput = {
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutStudentInput
    user: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutStudent_classroomInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutStudent_classroomInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudent_classroomInput, studentUncheckedCreateWithoutStudent_classroomInput>
  }

  export type classroomCreateWithoutStudent_classroomInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher_classroom?: teacher_classroomCreateNestedManyWithoutClassroomInput
    assignment?: assignmentCreateNestedManyWithoutClassroomInput
  }

  export type classroomUncheckedCreateWithoutStudent_classroomInput = {
    classroom_id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    teacher_classroom?: teacher_classroomUncheckedCreateNestedManyWithoutClassroomInput
    assignment?: assignmentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type classroomCreateOrConnectWithoutStudent_classroomInput = {
    where: classroomWhereUniqueInput
    create: XOR<classroomCreateWithoutStudent_classroomInput, classroomUncheckedCreateWithoutStudent_classroomInput>
  }

  export type studentUpsertWithoutStudent_classroomInput = {
    update: XOR<studentUpdateWithoutStudent_classroomInput, studentUncheckedUpdateWithoutStudent_classroomInput>
    create: XOR<studentCreateWithoutStudent_classroomInput, studentUncheckedCreateWithoutStudent_classroomInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutStudent_classroomInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutStudent_classroomInput, studentUncheckedUpdateWithoutStudent_classroomInput>
  }

  export type studentUpdateWithoutStudent_classroomInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutStudentNestedInput
    user?: userUpdateOneRequiredWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutStudent_classroomInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type classroomUpsertWithoutStudent_classroomInput = {
    update: XOR<classroomUpdateWithoutStudent_classroomInput, classroomUncheckedUpdateWithoutStudent_classroomInput>
    create: XOR<classroomCreateWithoutStudent_classroomInput, classroomUncheckedCreateWithoutStudent_classroomInput>
    where?: classroomWhereInput
  }

  export type classroomUpdateToOneWithWhereWithoutStudent_classroomInput = {
    where?: classroomWhereInput
    data: XOR<classroomUpdateWithoutStudent_classroomInput, classroomUncheckedUpdateWithoutStudent_classroomInput>
  }

  export type classroomUpdateWithoutStudent_classroomInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_classroom?: teacher_classroomUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUpdateManyWithoutClassroomNestedInput
  }

  export type classroomUncheckedUpdateWithoutStudent_classroomInput = {
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_classroom?: teacher_classroomUncheckedUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type userCreateWithoutTeacherInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    user_organization?: user_organizationCreateNestedManyWithoutUserInput
    student?: studentCreateNestedOneWithoutUserInput
    post?: postCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateWithoutTeacherInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedOneWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userCreateOrConnectWithoutTeacherInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
  }

  export type teacher_classroomCreateWithoutTeacherInput = {
    created_at?: Date | string
    updated_at?: Date | string
    classroom: classroomCreateNestedOneWithoutTeacher_classroomInput
  }

  export type teacher_classroomUncheckedCreateWithoutTeacherInput = {
    teacher_classrood_id?: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomCreateOrConnectWithoutTeacherInput = {
    where: teacher_classroomWhereUniqueInput
    create: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput>
  }

  export type teacher_classroomCreateManyTeacherInputEnvelope = {
    data: teacher_classroomCreateManyTeacherInput | teacher_classroomCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutTeacherInput = {
    update: XOR<userUpdateWithoutTeacherInput, userUncheckedUpdateWithoutTeacherInput>
    create: XOR<userCreateWithoutTeacherInput, userUncheckedCreateWithoutTeacherInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutTeacherInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutTeacherInput, userUncheckedUpdateWithoutTeacherInput>
  }

  export type userUpdateWithoutTeacherInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUpdateManyWithoutUserNestedInput
    student?: studentUpdateOneWithoutUserNestedInput
    post?: postUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateWithoutTeacherInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateOneWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type teacher_classroomUpsertWithWhereUniqueWithoutTeacherInput = {
    where: teacher_classroomWhereUniqueInput
    update: XOR<teacher_classroomUpdateWithoutTeacherInput, teacher_classroomUncheckedUpdateWithoutTeacherInput>
    create: XOR<teacher_classroomCreateWithoutTeacherInput, teacher_classroomUncheckedCreateWithoutTeacherInput>
  }

  export type teacher_classroomUpdateWithWhereUniqueWithoutTeacherInput = {
    where: teacher_classroomWhereUniqueInput
    data: XOR<teacher_classroomUpdateWithoutTeacherInput, teacher_classroomUncheckedUpdateWithoutTeacherInput>
  }

  export type teacher_classroomUpdateManyWithWhereWithoutTeacherInput = {
    where: teacher_classroomScalarWhereInput
    data: XOR<teacher_classroomUpdateManyMutationInput, teacher_classroomUncheckedUpdateManyWithoutTeacherInput>
  }

  export type teacherCreateWithoutTeacher_classroomInput = {
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutTeacher_classroomInput = {
    teacher_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacherCreateOrConnectWithoutTeacher_classroomInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutTeacher_classroomInput, teacherUncheckedCreateWithoutTeacher_classroomInput>
  }

  export type classroomCreateWithoutTeacher_classroomInput = {
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomCreateNestedManyWithoutClassroomInput
    assignment?: assignmentCreateNestedManyWithoutClassroomInput
  }

  export type classroomUncheckedCreateWithoutTeacher_classroomInput = {
    classroom_id?: number
    name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutClassroomInput
    assignment?: assignmentUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type classroomCreateOrConnectWithoutTeacher_classroomInput = {
    where: classroomWhereUniqueInput
    create: XOR<classroomCreateWithoutTeacher_classroomInput, classroomUncheckedCreateWithoutTeacher_classroomInput>
  }

  export type teacherUpsertWithoutTeacher_classroomInput = {
    update: XOR<teacherUpdateWithoutTeacher_classroomInput, teacherUncheckedUpdateWithoutTeacher_classroomInput>
    create: XOR<teacherCreateWithoutTeacher_classroomInput, teacherUncheckedCreateWithoutTeacher_classroomInput>
    where?: teacherWhereInput
  }

  export type teacherUpdateToOneWithWhereWithoutTeacher_classroomInput = {
    where?: teacherWhereInput
    data: XOR<teacherUpdateWithoutTeacher_classroomInput, teacherUncheckedUpdateWithoutTeacher_classroomInput>
  }

  export type teacherUpdateWithoutTeacher_classroomInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutTeacher_classroomInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type classroomUpsertWithoutTeacher_classroomInput = {
    update: XOR<classroomUpdateWithoutTeacher_classroomInput, classroomUncheckedUpdateWithoutTeacher_classroomInput>
    create: XOR<classroomCreateWithoutTeacher_classroomInput, classroomUncheckedCreateWithoutTeacher_classroomInput>
    where?: classroomWhereInput
  }

  export type classroomUpdateToOneWithWhereWithoutTeacher_classroomInput = {
    where?: classroomWhereInput
    data: XOR<classroomUpdateWithoutTeacher_classroomInput, classroomUncheckedUpdateWithoutTeacher_classroomInput>
  }

  export type classroomUpdateWithoutTeacher_classroomInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUpdateManyWithoutClassroomNestedInput
  }

  export type classroomUncheckedUpdateWithoutTeacher_classroomInput = {
    classroom_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student_classroom?: student_classroomUncheckedUpdateManyWithoutClassroomNestedInput
    assignment?: assignmentUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type organizationCreateWithoutScholarshipInput = {
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    user_organization?: user_organizationCreateNestedManyWithoutOrganizationInput
  }

  export type organizationUncheckedCreateWithoutScholarshipInput = {
    organization_id?: number
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type organizationCreateOrConnectWithoutScholarshipInput = {
    where: organizationWhereUniqueInput
    create: XOR<organizationCreateWithoutScholarshipInput, organizationUncheckedCreateWithoutScholarshipInput>
  }

  export type student_scholarshipCreateWithoutScholarshipInput = {
    is_bookmarked?: boolean | null
    student: studentCreateNestedOneWithoutStudent_scholarshipInput
  }

  export type student_scholarshipUncheckedCreateWithoutScholarshipInput = {
    student_scholarship_id?: number
    student_id: number
    is_bookmarked?: boolean | null
  }

  export type student_scholarshipCreateOrConnectWithoutScholarshipInput = {
    where: student_scholarshipWhereUniqueInput
    create: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput>
  }

  export type student_scholarshipCreateManyScholarshipInputEnvelope = {
    data: student_scholarshipCreateManyScholarshipInput | student_scholarshipCreateManyScholarshipInput[]
    skipDuplicates?: boolean
  }

  export type organizationUpsertWithoutScholarshipInput = {
    update: XOR<organizationUpdateWithoutScholarshipInput, organizationUncheckedUpdateWithoutScholarshipInput>
    create: XOR<organizationCreateWithoutScholarshipInput, organizationUncheckedCreateWithoutScholarshipInput>
    where?: organizationWhereInput
  }

  export type organizationUpdateToOneWithWhereWithoutScholarshipInput = {
    where?: organizationWhereInput
    data: XOR<organizationUpdateWithoutScholarshipInput, organizationUncheckedUpdateWithoutScholarshipInput>
  }

  export type organizationUpdateWithoutScholarshipInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_organization?: user_organizationUpdateManyWithoutOrganizationNestedInput
  }

  export type organizationUncheckedUpdateWithoutScholarshipInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_organization?: user_organizationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type student_scholarshipUpsertWithWhereUniqueWithoutScholarshipInput = {
    where: student_scholarshipWhereUniqueInput
    update: XOR<student_scholarshipUpdateWithoutScholarshipInput, student_scholarshipUncheckedUpdateWithoutScholarshipInput>
    create: XOR<student_scholarshipCreateWithoutScholarshipInput, student_scholarshipUncheckedCreateWithoutScholarshipInput>
  }

  export type student_scholarshipUpdateWithWhereUniqueWithoutScholarshipInput = {
    where: student_scholarshipWhereUniqueInput
    data: XOR<student_scholarshipUpdateWithoutScholarshipInput, student_scholarshipUncheckedUpdateWithoutScholarshipInput>
  }

  export type student_scholarshipUpdateManyWithWhereWithoutScholarshipInput = {
    where: student_scholarshipScalarWhereInput
    data: XOR<student_scholarshipUpdateManyMutationInput, student_scholarshipUncheckedUpdateManyWithoutScholarshipInput>
  }

  export type scholarshipCreateWithoutStudent_scholarshipInput = {
    name: string
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    organization: organizationCreateNestedOneWithoutScholarshipInput
  }

  export type scholarshipUncheckedCreateWithoutStudent_scholarshipInput = {
    scholarship_id?: number
    name: string
    organization_id: number
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type scholarshipCreateOrConnectWithoutStudent_scholarshipInput = {
    where: scholarshipWhereUniqueInput
    create: XOR<scholarshipCreateWithoutStudent_scholarshipInput, scholarshipUncheckedCreateWithoutStudent_scholarshipInput>
  }

  export type studentCreateWithoutStudent_scholarshipInput = {
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionCreateNestedManyWithoutStudentInput
    user: userCreateNestedOneWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutStudent_scholarshipInput = {
    student_id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutStudent_scholarshipInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutStudent_scholarshipInput, studentUncheckedCreateWithoutStudent_scholarshipInput>
  }

  export type scholarshipUpsertWithoutStudent_scholarshipInput = {
    update: XOR<scholarshipUpdateWithoutStudent_scholarshipInput, scholarshipUncheckedUpdateWithoutStudent_scholarshipInput>
    create: XOR<scholarshipCreateWithoutStudent_scholarshipInput, scholarshipUncheckedCreateWithoutStudent_scholarshipInput>
    where?: scholarshipWhereInput
  }

  export type scholarshipUpdateToOneWithWhereWithoutStudent_scholarshipInput = {
    where?: scholarshipWhereInput
    data: XOR<scholarshipUpdateWithoutStudent_scholarshipInput, scholarshipUncheckedUpdateWithoutStudent_scholarshipInput>
  }

  export type scholarshipUpdateWithoutStudent_scholarshipInput = {
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: organizationUpdateOneRequiredWithoutScholarshipNestedInput
  }

  export type scholarshipUncheckedUpdateWithoutStudent_scholarshipInput = {
    scholarship_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    organization_id?: IntFieldUpdateOperationsInput | number
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentUpsertWithoutStudent_scholarshipInput = {
    update: XOR<studentUpdateWithoutStudent_scholarshipInput, studentUncheckedUpdateWithoutStudent_scholarshipInput>
    create: XOR<studentCreateWithoutStudent_scholarshipInput, studentUncheckedCreateWithoutStudent_scholarshipInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutStudent_scholarshipInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutStudent_scholarshipInput, studentUncheckedUpdateWithoutStudent_scholarshipInput>
  }

  export type studentUpdateWithoutStudent_scholarshipInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUpdateManyWithoutStudentNestedInput
    user?: userUpdateOneRequiredWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutStudent_scholarshipInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUncheckedUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type userCreateWithoutPostInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    user_organization?: user_organizationCreateNestedManyWithoutUserInput
    student?: studentCreateNestedOneWithoutUserInput
    teacher?: teacherCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPostInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedOneWithoutUserInput
    teacher?: teacherUncheckedCreateNestedOneWithoutUserInput
  }

  export type userCreateOrConnectWithoutPostInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
  }

  export type userUpsertWithoutPostInput = {
    update: XOR<userUpdateWithoutPostInput, userUncheckedUpdateWithoutPostInput>
    create: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPostInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPostInput, userUncheckedUpdateWithoutPostInput>
  }

  export type userUpdateWithoutPostInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUpdateManyWithoutUserNestedInput
    student?: studentUpdateOneWithoutUserNestedInput
    teacher?: teacherUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPostInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    user_organization?: user_organizationUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateOneWithoutUserNestedInput
  }

  export type adminCreateWithoutUserInput = {
    admin_id: number
    is_active?: boolean | null
  }

  export type adminUncheckedCreateWithoutUserInput = {
    admin_id: number
    is_active?: boolean | null
  }

  export type adminCreateOrConnectWithoutUserInput = {
    where: adminWhereUniqueInput
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
  }

  export type user_organizationCreateWithoutUserInput = {
    organization: organizationCreateNestedOneWithoutUser_organizationInput
  }

  export type user_organizationUncheckedCreateWithoutUserInput = {
    user_organization_id?: number
    organization_id: number
  }

  export type user_organizationCreateOrConnectWithoutUserInput = {
    where: user_organizationWhereUniqueInput
    create: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput>
  }

  export type user_organizationCreateManyUserInputEnvelope = {
    data: user_organizationCreateManyUserInput | user_organizationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type studentCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipCreateNestedManyWithoutStudentInput
  }

  export type studentUncheckedCreateWithoutUserInput = {
    student_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    assignment_submission?: assignment_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_classroom?: student_classroomUncheckedCreateNestedManyWithoutStudentInput
    question_submission?: question_submissionUncheckedCreateNestedManyWithoutStudentInput
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutStudentInput
  }

  export type studentCreateOrConnectWithoutUserInput = {
    where: studentWhereUniqueInput
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
  }

  export type teacherCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string
    teacher_classroom?: teacher_classroomCreateNestedManyWithoutTeacherInput
  }

  export type teacherUncheckedCreateWithoutUserInput = {
    teacher_id?: number
    created_at?: Date | string
    updated_at?: Date | string
    teacher_classroom?: teacher_classroomUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type teacherCreateOrConnectWithoutUserInput = {
    where: teacherWhereUniqueInput
    create: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
  }

  export type postCreateWithoutAuthorInput = {
    title: string
    content?: string | null
    published?: boolean
  }

  export type postUncheckedCreateWithoutAuthorInput = {
    post_id?: number
    title: string
    content?: string | null
    published?: boolean
  }

  export type postCreateOrConnectWithoutAuthorInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput>
  }

  export type postCreateManyAuthorInputEnvelope = {
    data: postCreateManyAuthorInput | postCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type adminUpsertWithoutUserInput = {
    update: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
    create: XOR<adminCreateWithoutUserInput, adminUncheckedCreateWithoutUserInput>
    where?: adminWhereInput
  }

  export type adminUpdateToOneWithWhereWithoutUserInput = {
    where?: adminWhereInput
    data: XOR<adminUpdateWithoutUserInput, adminUncheckedUpdateWithoutUserInput>
  }

  export type adminUpdateWithoutUserInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type adminUncheckedUpdateWithoutUserInput = {
    admin_id?: IntFieldUpdateOperationsInput | number
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_organizationUpsertWithWhereUniqueWithoutUserInput = {
    where: user_organizationWhereUniqueInput
    update: XOR<user_organizationUpdateWithoutUserInput, user_organizationUncheckedUpdateWithoutUserInput>
    create: XOR<user_organizationCreateWithoutUserInput, user_organizationUncheckedCreateWithoutUserInput>
  }

  export type user_organizationUpdateWithWhereUniqueWithoutUserInput = {
    where: user_organizationWhereUniqueInput
    data: XOR<user_organizationUpdateWithoutUserInput, user_organizationUncheckedUpdateWithoutUserInput>
  }

  export type user_organizationUpdateManyWithWhereWithoutUserInput = {
    where: user_organizationScalarWhereInput
    data: XOR<user_organizationUpdateManyMutationInput, user_organizationUncheckedUpdateManyWithoutUserInput>
  }

  export type user_organizationScalarWhereInput = {
    AND?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
    OR?: user_organizationScalarWhereInput[]
    NOT?: user_organizationScalarWhereInput | user_organizationScalarWhereInput[]
    user_organization_id?: IntFilter<"user_organization"> | number
    user_id?: IntFilter<"user_organization"> | number
    organization_id?: IntFilter<"user_organization"> | number
  }

  export type studentUpsertWithoutUserInput = {
    update: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
    create: XOR<studentCreateWithoutUserInput, studentUncheckedCreateWithoutUserInput>
    where?: studentWhereInput
  }

  export type studentUpdateToOneWithWhereWithoutUserInput = {
    where?: studentWhereInput
    data: XOR<studentUpdateWithoutUserInput, studentUncheckedUpdateWithoutUserInput>
  }

  export type studentUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUpdateManyWithoutStudentNestedInput
  }

  export type studentUncheckedUpdateWithoutUserInput = {
    student_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_classroom?: student_classroomUncheckedUpdateManyWithoutStudentNestedInput
    question_submission?: question_submissionUncheckedUpdateManyWithoutStudentNestedInput
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type teacherUpsertWithoutUserInput = {
    update: XOR<teacherUpdateWithoutUserInput, teacherUncheckedUpdateWithoutUserInput>
    create: XOR<teacherCreateWithoutUserInput, teacherUncheckedCreateWithoutUserInput>
    where?: teacherWhereInput
  }

  export type teacherUpdateToOneWithWhereWithoutUserInput = {
    where?: teacherWhereInput
    data: XOR<teacherUpdateWithoutUserInput, teacherUncheckedUpdateWithoutUserInput>
  }

  export type teacherUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_classroom?: teacher_classroomUpdateManyWithoutTeacherNestedInput
  }

  export type teacherUncheckedUpdateWithoutUserInput = {
    teacher_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher_classroom?: teacher_classroomUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type postUpsertWithWhereUniqueWithoutAuthorInput = {
    where: postWhereUniqueInput
    update: XOR<postUpdateWithoutAuthorInput, postUncheckedUpdateWithoutAuthorInput>
    create: XOR<postCreateWithoutAuthorInput, postUncheckedCreateWithoutAuthorInput>
  }

  export type postUpdateWithWhereUniqueWithoutAuthorInput = {
    where: postWhereUniqueInput
    data: XOR<postUpdateWithoutAuthorInput, postUncheckedUpdateWithoutAuthorInput>
  }

  export type postUpdateManyWithWhereWithoutAuthorInput = {
    where: postScalarWhereInput
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyWithoutAuthorInput>
  }

  export type postScalarWhereInput = {
    AND?: postScalarWhereInput | postScalarWhereInput[]
    OR?: postScalarWhereInput[]
    NOT?: postScalarWhereInput | postScalarWhereInput[]
    post_id?: IntFilter<"post"> | number
    title?: StringFilter<"post"> | string
    content?: StringNullableFilter<"post"> | string | null
    published?: BoolFilter<"post"> | boolean
    author_id?: IntNullableFilter<"post"> | number | null
  }

  export type userCreateWithoutAdminInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    user_organization?: user_organizationCreateNestedManyWithoutUserInput
    student?: studentCreateNestedOneWithoutUserInput
    teacher?: teacherCreateNestedOneWithoutUserInput
    post?: postCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateWithoutAdminInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    user_organization?: user_organizationUncheckedCreateNestedManyWithoutUserInput
    student?: studentUncheckedCreateNestedOneWithoutUserInput
    teacher?: teacherUncheckedCreateNestedOneWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userCreateOrConnectWithoutAdminInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
  }

  export type userUpsertWithoutAdminInput = {
    update: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
    create: XOR<userCreateWithoutAdminInput, userUncheckedCreateWithoutAdminInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutAdminInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutAdminInput, userUncheckedUpdateWithoutAdminInput>
  }

  export type userUpdateWithoutAdminInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    user_organization?: user_organizationUpdateManyWithoutUserNestedInput
    student?: studentUpdateOneWithoutUserNestedInput
    teacher?: teacherUpdateOneWithoutUserNestedInput
    post?: postUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateWithoutAdminInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    user_organization?: user_organizationUncheckedUpdateManyWithoutUserNestedInput
    student?: studentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateOneWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type scholarshipCreateWithoutOrganizationInput = {
    name: string
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    student_scholarship?: student_scholarshipCreateNestedManyWithoutScholarshipInput
  }

  export type scholarshipUncheckedCreateWithoutOrganizationInput = {
    scholarship_id?: number
    name: string
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
    student_scholarship?: student_scholarshipUncheckedCreateNestedManyWithoutScholarshipInput
  }

  export type scholarshipCreateOrConnectWithoutOrganizationInput = {
    where: scholarshipWhereUniqueInput
    create: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput>
  }

  export type scholarshipCreateManyOrganizationInputEnvelope = {
    data: scholarshipCreateManyOrganizationInput | scholarshipCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type user_organizationCreateWithoutOrganizationInput = {
    user: userCreateNestedOneWithoutUser_organizationInput
  }

  export type user_organizationUncheckedCreateWithoutOrganizationInput = {
    user_organization_id?: number
    user_id: number
  }

  export type user_organizationCreateOrConnectWithoutOrganizationInput = {
    where: user_organizationWhereUniqueInput
    create: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput>
  }

  export type user_organizationCreateManyOrganizationInputEnvelope = {
    data: user_organizationCreateManyOrganizationInput | user_organizationCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type scholarshipUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: scholarshipWhereUniqueInput
    update: XOR<scholarshipUpdateWithoutOrganizationInput, scholarshipUncheckedUpdateWithoutOrganizationInput>
    create: XOR<scholarshipCreateWithoutOrganizationInput, scholarshipUncheckedCreateWithoutOrganizationInput>
  }

  export type scholarshipUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: scholarshipWhereUniqueInput
    data: XOR<scholarshipUpdateWithoutOrganizationInput, scholarshipUncheckedUpdateWithoutOrganizationInput>
  }

  export type scholarshipUpdateManyWithWhereWithoutOrganizationInput = {
    where: scholarshipScalarWhereInput
    data: XOR<scholarshipUpdateManyMutationInput, scholarshipUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type scholarshipScalarWhereInput = {
    AND?: scholarshipScalarWhereInput | scholarshipScalarWhereInput[]
    OR?: scholarshipScalarWhereInput[]
    NOT?: scholarshipScalarWhereInput | scholarshipScalarWhereInput[]
    scholarship_id?: IntFilter<"scholarship"> | number
    name?: StringFilter<"scholarship"> | string
    organization_id?: IntFilter<"scholarship"> | number
    award?: StringNullableFilter<"scholarship"> | string | null
    description?: StringNullableFilter<"scholarship"> | string | null
    category?: StringNullableFilter<"scholarship"> | string | null
    eligibility?: StringNullableFilter<"scholarship"> | string | null
    region?: StringNullableFilter<"scholarship"> | string | null
    deadline?: DateTimeNullableFilter<"scholarship"> | Date | string | null
    fafsa?: BoolNullableFilter<"scholarship"> | boolean | null
    gpa?: DecimalNullableFilter<"scholarship"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeNullableFilter<"scholarship"> | Date | string | null
  }

  export type user_organizationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: user_organizationWhereUniqueInput
    update: XOR<user_organizationUpdateWithoutOrganizationInput, user_organizationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<user_organizationCreateWithoutOrganizationInput, user_organizationUncheckedCreateWithoutOrganizationInput>
  }

  export type user_organizationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: user_organizationWhereUniqueInput
    data: XOR<user_organizationUpdateWithoutOrganizationInput, user_organizationUncheckedUpdateWithoutOrganizationInput>
  }

  export type user_organizationUpdateManyWithWhereWithoutOrganizationInput = {
    where: user_organizationScalarWhereInput
    data: XOR<user_organizationUpdateManyMutationInput, user_organizationUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type organizationCreateWithoutUser_organizationInput = {
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    scholarship?: scholarshipCreateNestedManyWithoutOrganizationInput
  }

  export type organizationUncheckedCreateWithoutUser_organizationInput = {
    organization_id?: number
    name?: string | null
    description?: string | null
    website?: string | null
    old_id?: string | null
    scholarship?: scholarshipUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type organizationCreateOrConnectWithoutUser_organizationInput = {
    where: organizationWhereUniqueInput
    create: XOR<organizationCreateWithoutUser_organizationInput, organizationUncheckedCreateWithoutUser_organizationInput>
  }

  export type userCreateWithoutUser_organizationInput = {
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminCreateNestedOneWithoutUserInput
    student?: studentCreateNestedOneWithoutUserInput
    teacher?: teacherCreateNestedOneWithoutUserInput
    post?: postCreateNestedManyWithoutAuthorInput
  }

  export type userUncheckedCreateWithoutUser_organizationInput = {
    user_id?: number
    name?: string | null
    email: string
    role?: $Enums.UserRole
    payment_info?: string | null
    invite_code?: string | null
    signup_complete?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    city?: string | null
    state?: string | null
    country?: string | null
    timezone?: string | null
    admin?: adminUncheckedCreateNestedOneWithoutUserInput
    student?: studentUncheckedCreateNestedOneWithoutUserInput
    teacher?: teacherUncheckedCreateNestedOneWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type userCreateOrConnectWithoutUser_organizationInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUser_organizationInput, userUncheckedCreateWithoutUser_organizationInput>
  }

  export type organizationUpsertWithoutUser_organizationInput = {
    update: XOR<organizationUpdateWithoutUser_organizationInput, organizationUncheckedUpdateWithoutUser_organizationInput>
    create: XOR<organizationCreateWithoutUser_organizationInput, organizationUncheckedCreateWithoutUser_organizationInput>
    where?: organizationWhereInput
  }

  export type organizationUpdateToOneWithWhereWithoutUser_organizationInput = {
    where?: organizationWhereInput
    data: XOR<organizationUpdateWithoutUser_organizationInput, organizationUncheckedUpdateWithoutUser_organizationInput>
  }

  export type organizationUpdateWithoutUser_organizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    scholarship?: scholarshipUpdateManyWithoutOrganizationNestedInput
  }

  export type organizationUncheckedUpdateWithoutUser_organizationInput = {
    organization_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    old_id?: NullableStringFieldUpdateOperationsInput | string | null
    scholarship?: scholarshipUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type userUpsertWithoutUser_organizationInput = {
    update: XOR<userUpdateWithoutUser_organizationInput, userUncheckedUpdateWithoutUser_organizationInput>
    create: XOR<userCreateWithoutUser_organizationInput, userUncheckedCreateWithoutUser_organizationInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUser_organizationInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUser_organizationInput, userUncheckedUpdateWithoutUser_organizationInput>
  }

  export type userUpdateWithoutUser_organizationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUpdateOneWithoutUserNestedInput
    student?: studentUpdateOneWithoutUserNestedInput
    teacher?: teacherUpdateOneWithoutUserNestedInput
    post?: postUpdateManyWithoutAuthorNestedInput
  }

  export type userUncheckedUpdateWithoutUser_organizationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    payment_info?: NullableStringFieldUpdateOperationsInput | string | null
    invite_code?: NullableStringFieldUpdateOperationsInput | string | null
    signup_complete?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: adminUncheckedUpdateOneWithoutUserNestedInput
    student?: studentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: teacherUncheckedUpdateOneWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type assignment_submissionCreateManyAssignmentInput = {
    assignment_submission_id?: number
    student_id: number
    s3_path: string
    submitted_at?: Date | string | null
  }

  export type questionCreateManyAssignmentInput = {
    question_id?: number
    question_number?: number | null
    name?: string | null
    prompt?: string | null
    example_solution_s3_path?: string | null
    accepted_file_types?: string | null
    created_at?: Date | string | null
  }

  export type assignment_submissionUpdateWithoutAssignmentInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: studentUpdateOneRequiredWithoutAssignment_submissionNestedInput
    question_submission?: question_submissionUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateWithoutAssignmentInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUncheckedUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateManyWithoutAssignmentInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionUpdateWithoutAssignmentInput = {
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateWithoutAssignmentInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type questionUncheckedUpdateManyWithoutAssignmentInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    question_number?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableStringFieldUpdateOperationsInput | string | null
    example_solution_s3_path?: NullableStringFieldUpdateOperationsInput | string | null
    accepted_file_types?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionCreateManyAssignment_submissionInput = {
    question_submission_id?: number
    question_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionUpdateWithoutAssignment_submissionInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question?: questionUpdateOneRequiredWithoutQuestion_submissionNestedInput
    student?: studentUpdateOneRequiredWithoutQuestion_submissionNestedInput
  }

  export type question_submissionUncheckedUpdateWithoutAssignment_submissionInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionUncheckedUpdateManyWithoutAssignment_submissionInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionCreateManyQuestionInput = {
    question_submission_id?: number
    assignment_submission_id: number
    student_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type question_submissionUpdateWithoutQuestionInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUpdateOneRequiredWithoutQuestion_submissionNestedInput
    student?: studentUpdateOneRequiredWithoutQuestion_submissionNestedInput
  }

  export type question_submissionUncheckedUpdateWithoutQuestionInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionUncheckedUpdateManyWithoutQuestionInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_classroomCreateManyClassroomInput = {
    student_classroom_id?: number
    student_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomCreateManyClassroomInput = {
    teacher_classrood_id?: number
    teacher_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type assignmentCreateManyClassroomInput = {
    assignment_id?: number
    name: string
    description?: string | null
    assignment_number?: number | null
    due_date: Date | string
    created_at?: Date | string | null
  }

  export type student_classroomUpdateWithoutClassroomInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: studentUpdateOneRequiredWithoutStudent_classroomNestedInput
  }

  export type student_classroomUncheckedUpdateWithoutClassroomInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_classroomUncheckedUpdateManyWithoutClassroomInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomUpdateWithoutClassroomInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: teacherUpdateOneRequiredWithoutTeacher_classroomNestedInput
  }

  export type teacher_classroomUncheckedUpdateWithoutClassroomInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomUncheckedUpdateManyWithoutClassroomInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type assignmentUpdateWithoutClassroomInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUpdateManyWithoutAssignmentNestedInput
    question?: questionUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentUncheckedUpdateWithoutClassroomInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUncheckedUpdateManyWithoutAssignmentNestedInput
    question?: questionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type assignmentUncheckedUpdateManyWithoutClassroomInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignment_number?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type assignment_submissionCreateManyStudentInput = {
    assignment_submission_id?: number
    assignment_id: number
    s3_path: string
    submitted_at?: Date | string | null
  }

  export type student_classroomCreateManyStudentInput = {
    student_classroom_id?: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type question_submissionCreateManyStudentInput = {
    question_submission_id?: number
    assignment_submission_id: number
    question_id: number
    s3_path: string
    created_at?: Date | string | null
  }

  export type student_scholarshipCreateManyStudentInput = {
    student_scholarship_id?: number
    scholarship_id: number
    is_bookmarked?: boolean | null
  }

  export type assignment_submissionUpdateWithoutStudentInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment?: assignmentUpdateOneRequiredWithoutAssignment_submissionNestedInput
    question_submission?: question_submissionUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateWithoutStudentInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    question_submission?: question_submissionUncheckedUpdateManyWithoutAssignment_submissionNestedInput
  }

  export type assignment_submissionUncheckedUpdateManyWithoutStudentInput = {
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    submitted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_classroomUpdateWithoutStudentInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: classroomUpdateOneRequiredWithoutStudent_classroomNestedInput
  }

  export type student_classroomUncheckedUpdateWithoutStudentInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_classroomUncheckedUpdateManyWithoutStudentInput = {
    student_classroom_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type question_submissionUpdateWithoutStudentInput = {
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignment_submission?: assignment_submissionUpdateOneRequiredWithoutQuestion_submissionNestedInput
    question?: questionUpdateOneRequiredWithoutQuestion_submissionNestedInput
  }

  export type question_submissionUncheckedUpdateWithoutStudentInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type question_submissionUncheckedUpdateManyWithoutStudentInput = {
    question_submission_id?: IntFieldUpdateOperationsInput | number
    assignment_submission_id?: IntFieldUpdateOperationsInput | number
    question_id?: IntFieldUpdateOperationsInput | number
    s3_path?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type student_scholarshipUpdateWithoutStudentInput = {
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    scholarship?: scholarshipUpdateOneRequiredWithoutStudent_scholarshipNestedInput
  }

  export type student_scholarshipUncheckedUpdateWithoutStudentInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    scholarship_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type student_scholarshipUncheckedUpdateManyWithoutStudentInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    scholarship_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teacher_classroomCreateManyTeacherInput = {
    teacher_classrood_id?: number
    classroom_id: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type teacher_classroomUpdateWithoutTeacherInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: classroomUpdateOneRequiredWithoutTeacher_classroomNestedInput
  }

  export type teacher_classroomUncheckedUpdateWithoutTeacherInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teacher_classroomUncheckedUpdateManyWithoutTeacherInput = {
    teacher_classrood_id?: IntFieldUpdateOperationsInput | number
    classroom_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type student_scholarshipCreateManyScholarshipInput = {
    student_scholarship_id?: number
    student_id: number
    is_bookmarked?: boolean | null
  }

  export type student_scholarshipUpdateWithoutScholarshipInput = {
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    student?: studentUpdateOneRequiredWithoutStudent_scholarshipNestedInput
  }

  export type student_scholarshipUncheckedUpdateWithoutScholarshipInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type student_scholarshipUncheckedUpdateManyWithoutScholarshipInput = {
    student_scholarship_id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    is_bookmarked?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_organizationCreateManyUserInput = {
    user_organization_id?: number
    organization_id: number
  }

  export type postCreateManyAuthorInput = {
    post_id?: number
    title: string
    content?: string | null
    published?: boolean
  }

  export type user_organizationUpdateWithoutUserInput = {
    organization?: organizationUpdateOneRequiredWithoutUser_organizationNestedInput
  }

  export type user_organizationUncheckedUpdateWithoutUserInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_organizationUncheckedUpdateManyWithoutUserInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    organization_id?: IntFieldUpdateOperationsInput | number
  }

  export type postUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type postUncheckedUpdateWithoutAuthorInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type postUncheckedUpdateManyWithoutAuthorInput = {
    post_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type scholarshipCreateManyOrganizationInput = {
    scholarship_id?: number
    name: string
    award?: string | null
    description?: string | null
    category?: string | null
    eligibility?: string | null
    region?: string | null
    deadline?: Date | string | null
    fafsa?: boolean | null
    gpa?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string | null
  }

  export type user_organizationCreateManyOrganizationInput = {
    user_organization_id?: number
    user_id: number
  }

  export type scholarshipUpdateWithoutOrganizationInput = {
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_scholarship?: student_scholarshipUpdateManyWithoutScholarshipNestedInput
  }

  export type scholarshipUncheckedUpdateWithoutOrganizationInput = {
    scholarship_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student_scholarship?: student_scholarshipUncheckedUpdateManyWithoutScholarshipNestedInput
  }

  export type scholarshipUncheckedUpdateManyWithoutOrganizationInput = {
    scholarship_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    award?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fafsa?: NullableBoolFieldUpdateOperationsInput | boolean | null
    gpa?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_organizationUpdateWithoutOrganizationInput = {
    user?: userUpdateOneRequiredWithoutUser_organizationNestedInput
  }

  export type user_organizationUncheckedUpdateWithoutOrganizationInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_organizationUncheckedUpdateManyWithoutOrganizationInput = {
    user_organization_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}